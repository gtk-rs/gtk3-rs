// This file was generated by gir (b91816f) from gir-files (71d73f0)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, time_t, FILE};

pub type gboolean = c_int;
pub const GFALSE:  c_int = 0;
pub const GTRUE:   c_int = 1;

pub type gconstpointer = *const c_void;
pub type gpointer = *mut c_void;

#[repr(C)]
pub struct Volatile<T>(T);


// Aliases
pub type GDateDay = u8;
pub type GDateYear = u16;
pub type GMutexLocker = gpointer;
pub type GPid = c_int;
pub type GQuark = u32;
pub type GStrv = gpointer;
pub type GTime = i32;
pub type GTimeSpan = i64;
pub type GType = size_t;

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GBookmarkFileError {
    InvalidUri = 0,
    InvalidValue = 1,
    AppNotRegistered = 2,
    UriNotFound = 3,
    Read = 4,
    UnknownEncoding = 5,
    Write = 6,
    FileNotFound = 7,
}
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = GBookmarkFileError::InvalidUri;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = GBookmarkFileError::InvalidValue;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = GBookmarkFileError::AppNotRegistered;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = GBookmarkFileError::UriNotFound;
pub const G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = GBookmarkFileError::Read;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = GBookmarkFileError::UnknownEncoding;
pub const G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = GBookmarkFileError::Write;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = GBookmarkFileError::FileNotFound;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GChecksumType {
    Md5 = 0,
    Sha1 = 1,
    Sha256 = 2,
    Sha512 = 3,
}
pub const G_CHECKSUM_MD5: GChecksumType = GChecksumType::Md5;
pub const G_CHECKSUM_SHA1: GChecksumType = GChecksumType::Sha1;
pub const G_CHECKSUM_SHA256: GChecksumType = GChecksumType::Sha256;
pub const G_CHECKSUM_SHA512: GChecksumType = GChecksumType::Sha512;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GConvertError {
    NoConversion = 0,
    IllegalSequence = 1,
    Failed = 2,
    PartialInput = 3,
    BadUri = 4,
    NotAbsolutePath = 5,
    NoMemory = 6,
}
pub const G_CONVERT_ERROR_NO_CONVERSION: GConvertError = GConvertError::NoConversion;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = GConvertError::IllegalSequence;
pub const G_CONVERT_ERROR_FAILED: GConvertError = GConvertError::Failed;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = GConvertError::PartialInput;
pub const G_CONVERT_ERROR_BAD_URI: GConvertError = GConvertError::BadUri;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = GConvertError::NotAbsolutePath;
pub const G_CONVERT_ERROR_NO_MEMORY: GConvertError = GConvertError::NoMemory;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDateDMY {
    Day = 0,
    Month = 1,
    Year = 2,
}
pub const G_DATE_DAY: GDateDMY = GDateDMY::Day;
pub const G_DATE_MONTH: GDateDMY = GDateDMY::Month;
pub const G_DATE_YEAR: GDateDMY = GDateDMY::Year;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDateMonth {
    BadMonth = 0,
    January = 1,
    February = 2,
    March = 3,
    April = 4,
    May = 5,
    June = 6,
    July = 7,
    August = 8,
    September = 9,
    October = 10,
    November = 11,
    December = 12,
}
pub const G_DATE_BAD_MONTH: GDateMonth = GDateMonth::BadMonth;
pub const G_DATE_JANUARY: GDateMonth = GDateMonth::January;
pub const G_DATE_FEBRUARY: GDateMonth = GDateMonth::February;
pub const G_DATE_MARCH: GDateMonth = GDateMonth::March;
pub const G_DATE_APRIL: GDateMonth = GDateMonth::April;
pub const G_DATE_MAY: GDateMonth = GDateMonth::May;
pub const G_DATE_JUNE: GDateMonth = GDateMonth::June;
pub const G_DATE_JULY: GDateMonth = GDateMonth::July;
pub const G_DATE_AUGUST: GDateMonth = GDateMonth::August;
pub const G_DATE_SEPTEMBER: GDateMonth = GDateMonth::September;
pub const G_DATE_OCTOBER: GDateMonth = GDateMonth::October;
pub const G_DATE_NOVEMBER: GDateMonth = GDateMonth::November;
pub const G_DATE_DECEMBER: GDateMonth = GDateMonth::December;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDateWeekday {
    BadWeekday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    Sunday = 7,
}
pub const G_DATE_BAD_WEEKDAY: GDateWeekday = GDateWeekday::BadWeekday;
pub const G_DATE_MONDAY: GDateWeekday = GDateWeekday::Monday;
pub const G_DATE_TUESDAY: GDateWeekday = GDateWeekday::Tuesday;
pub const G_DATE_WEDNESDAY: GDateWeekday = GDateWeekday::Wednesday;
pub const G_DATE_THURSDAY: GDateWeekday = GDateWeekday::Thursday;
pub const G_DATE_FRIDAY: GDateWeekday = GDateWeekday::Friday;
pub const G_DATE_SATURDAY: GDateWeekday = GDateWeekday::Saturday;
pub const G_DATE_SUNDAY: GDateWeekday = GDateWeekday::Sunday;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GErrorType {
    Unknown = 0,
    UnexpEof = 1,
    UnexpEofInString = 2,
    UnexpEofInComment = 3,
    NonDigitInConst = 4,
    DigitRadix = 5,
    FloatRadix = 6,
    FloatMalformed = 7,
}
pub const G_ERR_UNKNOWN: GErrorType = GErrorType::Unknown;
pub const G_ERR_UNEXP_EOF: GErrorType = GErrorType::UnexpEof;
pub const G_ERR_UNEXP_EOF_IN_STRING: GErrorType = GErrorType::UnexpEofInString;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = GErrorType::UnexpEofInComment;
pub const G_ERR_NON_DIGIT_IN_CONST: GErrorType = GErrorType::NonDigitInConst;
pub const G_ERR_DIGIT_RADIX: GErrorType = GErrorType::DigitRadix;
pub const G_ERR_FLOAT_RADIX: GErrorType = GErrorType::FloatRadix;
pub const G_ERR_FLOAT_MALFORMED: GErrorType = GErrorType::FloatMalformed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFileError {
    Exist = 0,
    Isdir = 1,
    Acces = 2,
    Nametoolong = 3,
    Noent = 4,
    Notdir = 5,
    Nxio = 6,
    Nodev = 7,
    Rofs = 8,
    Txtbsy = 9,
    Fault = 10,
    Loop = 11,
    Nospc = 12,
    Nomem = 13,
    Mfile = 14,
    Nfile = 15,
    Badf = 16,
    Inval = 17,
    Pipe = 18,
    Again = 19,
    Intr = 20,
    Io = 21,
    Perm = 22,
    Nosys = 23,
    Failed = 24,
}
pub const G_FILE_ERROR_EXIST: GFileError = GFileError::Exist;
pub const G_FILE_ERROR_ISDIR: GFileError = GFileError::Isdir;
pub const G_FILE_ERROR_ACCES: GFileError = GFileError::Acces;
pub const G_FILE_ERROR_NAMETOOLONG: GFileError = GFileError::Nametoolong;
pub const G_FILE_ERROR_NOENT: GFileError = GFileError::Noent;
pub const G_FILE_ERROR_NOTDIR: GFileError = GFileError::Notdir;
pub const G_FILE_ERROR_NXIO: GFileError = GFileError::Nxio;
pub const G_FILE_ERROR_NODEV: GFileError = GFileError::Nodev;
pub const G_FILE_ERROR_ROFS: GFileError = GFileError::Rofs;
pub const G_FILE_ERROR_TXTBSY: GFileError = GFileError::Txtbsy;
pub const G_FILE_ERROR_FAULT: GFileError = GFileError::Fault;
pub const G_FILE_ERROR_LOOP: GFileError = GFileError::Loop;
pub const G_FILE_ERROR_NOSPC: GFileError = GFileError::Nospc;
pub const G_FILE_ERROR_NOMEM: GFileError = GFileError::Nomem;
pub const G_FILE_ERROR_MFILE: GFileError = GFileError::Mfile;
pub const G_FILE_ERROR_NFILE: GFileError = GFileError::Nfile;
pub const G_FILE_ERROR_BADF: GFileError = GFileError::Badf;
pub const G_FILE_ERROR_INVAL: GFileError = GFileError::Inval;
pub const G_FILE_ERROR_PIPE: GFileError = GFileError::Pipe;
pub const G_FILE_ERROR_AGAIN: GFileError = GFileError::Again;
pub const G_FILE_ERROR_INTR: GFileError = GFileError::Intr;
pub const G_FILE_ERROR_IO: GFileError = GFileError::Io;
pub const G_FILE_ERROR_PERM: GFileError = GFileError::Perm;
pub const G_FILE_ERROR_NOSYS: GFileError = GFileError::Nosys;
pub const G_FILE_ERROR_FAILED: GFileError = GFileError::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GIOChannelError {
    Fbig = 0,
    Inval = 1,
    Io = 2,
    Isdir = 3,
    Nospc = 4,
    Nxio = 5,
    Overflow = 6,
    Pipe = 7,
    Failed = 8,
}
pub const G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = GIOChannelError::Fbig;
pub const G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = GIOChannelError::Inval;
pub const G_IO_CHANNEL_ERROR_IO: GIOChannelError = GIOChannelError::Io;
pub const G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = GIOChannelError::Isdir;
pub const G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = GIOChannelError::Nospc;
pub const G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = GIOChannelError::Nxio;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = GIOChannelError::Overflow;
pub const G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = GIOChannelError::Pipe;
pub const G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = GIOChannelError::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GIOError {
    None = 0,
    Again = 1,
    Inval = 2,
    Unknown = 3,
}
pub const G_IO_ERROR_NONE: GIOError = GIOError::None;
pub const G_IO_ERROR_AGAIN: GIOError = GIOError::Again;
pub const G_IO_ERROR_INVAL: GIOError = GIOError::Inval;
pub const G_IO_ERROR_UNKNOWN: GIOError = GIOError::Unknown;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GIOStatus {
    Error = 0,
    Normal = 1,
    Eof = 2,
    Again = 3,
}
pub const G_IO_STATUS_ERROR: GIOStatus = GIOStatus::Error;
pub const G_IO_STATUS_NORMAL: GIOStatus = GIOStatus::Normal;
pub const G_IO_STATUS_EOF: GIOStatus = GIOStatus::Eof;
pub const G_IO_STATUS_AGAIN: GIOStatus = GIOStatus::Again;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GKeyFileError {
    UnknownEncoding = 0,
    Parse = 1,
    NotFound = 2,
    KeyNotFound = 3,
    GroupNotFound = 4,
    InvalidValue = 5,
}
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = GKeyFileError::UnknownEncoding;
pub const G_KEY_FILE_ERROR_PARSE: GKeyFileError = GKeyFileError::Parse;
pub const G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = GKeyFileError::NotFound;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = GKeyFileError::KeyNotFound;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = GKeyFileError::GroupNotFound;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = GKeyFileError::InvalidValue;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GLogWriterOutput {
    Handled = 1,
    Unhandled = 0,
}
pub const G_LOG_WRITER_HANDLED: GLogWriterOutput = GLogWriterOutput::Handled;
pub const G_LOG_WRITER_UNHANDLED: GLogWriterOutput = GLogWriterOutput::Unhandled;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GMarkupError {
    BadUtf8 = 0,
    Empty = 1,
    Parse = 2,
    UnknownElement = 3,
    UnknownAttribute = 4,
    InvalidContent = 5,
    MissingAttribute = 6,
}
pub const G_MARKUP_ERROR_BAD_UTF8: GMarkupError = GMarkupError::BadUtf8;
pub const G_MARKUP_ERROR_EMPTY: GMarkupError = GMarkupError::Empty;
pub const G_MARKUP_ERROR_PARSE: GMarkupError = GMarkupError::Parse;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = GMarkupError::UnknownElement;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = GMarkupError::UnknownAttribute;
pub const G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = GMarkupError::InvalidContent;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = GMarkupError::MissingAttribute;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GNormalizeMode {
    Default = 0,
    DefaultCompose = 1,
    All = 2,
    AllCompose = 3,
}
pub const G_NORMALIZE_DEFAULT: GNormalizeMode = GNormalizeMode::Default;
pub const G_NORMALIZE_NFD: GNormalizeMode = GNormalizeMode::Default;
pub const G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = GNormalizeMode::DefaultCompose;
pub const G_NORMALIZE_NFC: GNormalizeMode = GNormalizeMode::DefaultCompose;
pub const G_NORMALIZE_ALL: GNormalizeMode = GNormalizeMode::All;
pub const G_NORMALIZE_NFKD: GNormalizeMode = GNormalizeMode::All;
pub const G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = GNormalizeMode::AllCompose;
pub const G_NORMALIZE_NFKC: GNormalizeMode = GNormalizeMode::AllCompose;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GOnceStatus {
    Notcalled = 0,
    Progress = 1,
    Ready = 2,
}
pub const G_ONCE_STATUS_NOTCALLED: GOnceStatus = GOnceStatus::Notcalled;
pub const G_ONCE_STATUS_PROGRESS: GOnceStatus = GOnceStatus::Progress;
pub const G_ONCE_STATUS_READY: GOnceStatus = GOnceStatus::Ready;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GOptionArg {
    None = 0,
    String = 1,
    Int = 2,
    Callback = 3,
    Filename = 4,
    StringArray = 5,
    FilenameArray = 6,
    Double = 7,
    Int64 = 8,
}
pub const G_OPTION_ARG_NONE: GOptionArg = GOptionArg::None;
pub const G_OPTION_ARG_STRING: GOptionArg = GOptionArg::String;
pub const G_OPTION_ARG_INT: GOptionArg = GOptionArg::Int;
pub const G_OPTION_ARG_CALLBACK: GOptionArg = GOptionArg::Callback;
pub const G_OPTION_ARG_FILENAME: GOptionArg = GOptionArg::Filename;
pub const G_OPTION_ARG_STRING_ARRAY: GOptionArg = GOptionArg::StringArray;
pub const G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = GOptionArg::FilenameArray;
pub const G_OPTION_ARG_DOUBLE: GOptionArg = GOptionArg::Double;
pub const G_OPTION_ARG_INT64: GOptionArg = GOptionArg::Int64;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GOptionError {
    UnknownOption = 0,
    BadValue = 1,
    Failed = 2,
}
pub const G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = GOptionError::UnknownOption;
pub const G_OPTION_ERROR_BAD_VALUE: GOptionError = GOptionError::BadValue;
pub const G_OPTION_ERROR_FAILED: GOptionError = GOptionError::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GRegexError {
    Compile = 0,
    Optimize = 1,
    Replace = 2,
    Match = 3,
    Internal = 4,
    StrayBackslash = 101,
    MissingControlChar = 102,
    UnrecognizedEscape = 103,
    QuantifiersOutOfOrder = 104,
    QuantifierTooBig = 105,
    UnterminatedCharacterClass = 106,
    InvalidEscapeInCharacterClass = 107,
    RangeOutOfOrder = 108,
    NothingToRepeat = 109,
    UnrecognizedCharacter = 112,
    PosixNamedClassOutsideClass = 113,
    UnmatchedParenthesis = 114,
    InexistentSubpatternReference = 115,
    UnterminatedComment = 118,
    ExpressionTooLarge = 120,
    MemoryError = 121,
    VariableLengthLookbehind = 125,
    MalformedCondition = 126,
    TooManyConditionalBranches = 127,
    AssertionExpected = 128,
    UnknownPosixClassName = 130,
    PosixCollatingElementsNotSupported = 131,
    HexCodeTooLarge = 134,
    InvalidCondition = 135,
    SingleByteMatchInLookbehind = 136,
    InfiniteLoop = 140,
    MissingSubpatternNameTerminator = 142,
    DuplicateSubpatternName = 143,
    MalformedProperty = 146,
    UnknownProperty = 147,
    SubpatternNameTooLong = 148,
    TooManySubpatterns = 149,
    InvalidOctalValue = 151,
    TooManyBranchesInDefine = 154,
    DefineRepetion = 155,
    InconsistentNewlineOptions = 156,
    MissingBackReference = 157,
    InvalidRelativeReference = 158,
    BacktrackingControlVerbArgumentForbidden = 159,
    UnknownBacktrackingControlVerb = 160,
    NumberTooBig = 161,
    MissingSubpatternName = 162,
    MissingDigit = 163,
    InvalidDataCharacter = 164,
    ExtraSubpatternName = 165,
    BacktrackingControlVerbArgumentRequired = 166,
    InvalidControlChar = 168,
    MissingName = 169,
    NotSupportedInClass = 171,
    TooManyForwardReferences = 172,
    NameTooLong = 175,
    CharacterValueTooLarge = 176,
}
pub const G_REGEX_ERROR_COMPILE: GRegexError = GRegexError::Compile;
pub const G_REGEX_ERROR_OPTIMIZE: GRegexError = GRegexError::Optimize;
pub const G_REGEX_ERROR_REPLACE: GRegexError = GRegexError::Replace;
pub const G_REGEX_ERROR_MATCH: GRegexError = GRegexError::Match;
pub const G_REGEX_ERROR_INTERNAL: GRegexError = GRegexError::Internal;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = GRegexError::StrayBackslash;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = GRegexError::MissingControlChar;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = GRegexError::UnrecognizedEscape;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = GRegexError::QuantifiersOutOfOrder;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = GRegexError::QuantifierTooBig;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = GRegexError::UnterminatedCharacterClass;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = GRegexError::InvalidEscapeInCharacterClass;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = GRegexError::RangeOutOfOrder;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = GRegexError::NothingToRepeat;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = GRegexError::UnrecognizedCharacter;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = GRegexError::PosixNamedClassOutsideClass;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = GRegexError::UnmatchedParenthesis;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = GRegexError::InexistentSubpatternReference;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = GRegexError::UnterminatedComment;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = GRegexError::ExpressionTooLarge;
pub const G_REGEX_ERROR_MEMORY_ERROR: GRegexError = GRegexError::MemoryError;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = GRegexError::VariableLengthLookbehind;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = GRegexError::MalformedCondition;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = GRegexError::TooManyConditionalBranches;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = GRegexError::AssertionExpected;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = GRegexError::UnknownPosixClassName;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = GRegexError::PosixCollatingElementsNotSupported;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = GRegexError::HexCodeTooLarge;
pub const G_REGEX_ERROR_INVALID_CONDITION: GRegexError = GRegexError::InvalidCondition;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = GRegexError::SingleByteMatchInLookbehind;
pub const G_REGEX_ERROR_INFINITE_LOOP: GRegexError = GRegexError::InfiniteLoop;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = GRegexError::MissingSubpatternNameTerminator;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = GRegexError::DuplicateSubpatternName;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = GRegexError::MalformedProperty;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = GRegexError::UnknownProperty;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = GRegexError::SubpatternNameTooLong;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = GRegexError::TooManySubpatterns;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = GRegexError::InvalidOctalValue;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = GRegexError::TooManyBranchesInDefine;
pub const G_REGEX_ERROR_DEFINE_REPETION: GRegexError = GRegexError::DefineRepetion;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = GRegexError::InconsistentNewlineOptions;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = GRegexError::MissingBackReference;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = GRegexError::InvalidRelativeReference;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = GRegexError::BacktrackingControlVerbArgumentForbidden;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = GRegexError::UnknownBacktrackingControlVerb;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = GRegexError::NumberTooBig;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = GRegexError::MissingSubpatternName;
pub const G_REGEX_ERROR_MISSING_DIGIT: GRegexError = GRegexError::MissingDigit;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = GRegexError::InvalidDataCharacter;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = GRegexError::ExtraSubpatternName;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = GRegexError::BacktrackingControlVerbArgumentRequired;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = GRegexError::InvalidControlChar;
pub const G_REGEX_ERROR_MISSING_NAME: GRegexError = GRegexError::MissingName;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = GRegexError::NotSupportedInClass;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = GRegexError::TooManyForwardReferences;
pub const G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = GRegexError::NameTooLong;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = GRegexError::CharacterValueTooLarge;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSeekType {
    Cur = 0,
    Set = 1,
    End = 2,
}
pub const G_SEEK_CUR: GSeekType = GSeekType::Cur;
pub const G_SEEK_SET: GSeekType = GSeekType::Set;
pub const G_SEEK_END: GSeekType = GSeekType::End;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GShellError {
    BadQuoting = 0,
    EmptyString = 1,
    Failed = 2,
}
pub const G_SHELL_ERROR_BAD_QUOTING: GShellError = GShellError::BadQuoting;
pub const G_SHELL_ERROR_EMPTY_STRING: GShellError = GShellError::EmptyString;
pub const G_SHELL_ERROR_FAILED: GShellError = GShellError::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSliceConfig {
    AlwaysMalloc = 1,
    BypassMagazines = 2,
    WorkingSetMsecs = 3,
    ColorIncrement = 4,
    ChunkSizes = 5,
    ContentionCounter = 6,
}
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = GSliceConfig::AlwaysMalloc;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = GSliceConfig::BypassMagazines;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = GSliceConfig::WorkingSetMsecs;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = GSliceConfig::ColorIncrement;
pub const G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = GSliceConfig::ChunkSizes;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = GSliceConfig::ContentionCounter;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSpawnError {
    Fork = 0,
    Read = 1,
    Chdir = 2,
    Acces = 3,
    Perm = 4,
    TooBig = 5,
    Noexec = 6,
    Nametoolong = 7,
    Noent = 8,
    Nomem = 9,
    Notdir = 10,
    Loop = 11,
    Txtbusy = 12,
    Io = 13,
    Nfile = 14,
    Mfile = 15,
    Inval = 16,
    Isdir = 17,
    Libbad = 18,
    Failed = 19,
}
pub const G_SPAWN_ERROR_FORK: GSpawnError = GSpawnError::Fork;
pub const G_SPAWN_ERROR_READ: GSpawnError = GSpawnError::Read;
pub const G_SPAWN_ERROR_CHDIR: GSpawnError = GSpawnError::Chdir;
pub const G_SPAWN_ERROR_ACCES: GSpawnError = GSpawnError::Acces;
pub const G_SPAWN_ERROR_PERM: GSpawnError = GSpawnError::Perm;
pub const G_SPAWN_ERROR_TOO_BIG: GSpawnError = GSpawnError::TooBig;
pub const G_SPAWN_ERROR_2BIG: GSpawnError = GSpawnError::TooBig;
pub const G_SPAWN_ERROR_NOEXEC: GSpawnError = GSpawnError::Noexec;
pub const G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = GSpawnError::Nametoolong;
pub const G_SPAWN_ERROR_NOENT: GSpawnError = GSpawnError::Noent;
pub const G_SPAWN_ERROR_NOMEM: GSpawnError = GSpawnError::Nomem;
pub const G_SPAWN_ERROR_NOTDIR: GSpawnError = GSpawnError::Notdir;
pub const G_SPAWN_ERROR_LOOP: GSpawnError = GSpawnError::Loop;
pub const G_SPAWN_ERROR_TXTBUSY: GSpawnError = GSpawnError::Txtbusy;
pub const G_SPAWN_ERROR_IO: GSpawnError = GSpawnError::Io;
pub const G_SPAWN_ERROR_NFILE: GSpawnError = GSpawnError::Nfile;
pub const G_SPAWN_ERROR_MFILE: GSpawnError = GSpawnError::Mfile;
pub const G_SPAWN_ERROR_INVAL: GSpawnError = GSpawnError::Inval;
pub const G_SPAWN_ERROR_ISDIR: GSpawnError = GSpawnError::Isdir;
pub const G_SPAWN_ERROR_LIBBAD: GSpawnError = GSpawnError::Libbad;
pub const G_SPAWN_ERROR_FAILED: GSpawnError = GSpawnError::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTestFileType {
    Dist = 0,
    Built = 1,
}
pub const G_TEST_DIST: GTestFileType = GTestFileType::Dist;
pub const G_TEST_BUILT: GTestFileType = GTestFileType::Built;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTestLogType {
    None = 0,
    Error = 1,
    StartBinary = 2,
    ListCase = 3,
    SkipCase = 4,
    StartCase = 5,
    StopCase = 6,
    MinResult = 7,
    MaxResult = 8,
    Message = 9,
    StartSuite = 10,
    StopSuite = 11,
}
pub const G_TEST_LOG_NONE: GTestLogType = GTestLogType::None;
pub const G_TEST_LOG_ERROR: GTestLogType = GTestLogType::Error;
pub const G_TEST_LOG_START_BINARY: GTestLogType = GTestLogType::StartBinary;
pub const G_TEST_LOG_LIST_CASE: GTestLogType = GTestLogType::ListCase;
pub const G_TEST_LOG_SKIP_CASE: GTestLogType = GTestLogType::SkipCase;
pub const G_TEST_LOG_START_CASE: GTestLogType = GTestLogType::StartCase;
pub const G_TEST_LOG_STOP_CASE: GTestLogType = GTestLogType::StopCase;
pub const G_TEST_LOG_MIN_RESULT: GTestLogType = GTestLogType::MinResult;
pub const G_TEST_LOG_MAX_RESULT: GTestLogType = GTestLogType::MaxResult;
pub const G_TEST_LOG_MESSAGE: GTestLogType = GTestLogType::Message;
pub const G_TEST_LOG_START_SUITE: GTestLogType = GTestLogType::StartSuite;
pub const G_TEST_LOG_STOP_SUITE: GTestLogType = GTestLogType::StopSuite;

pub type ThreadError = c_int;
pub const G_THREAD_ERROR_AGAIN: ThreadError = 0;
pub type GThreadError = ThreadError;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTimeType {
    Standard = 0,
    Daylight = 1,
    Universal = 2,
}
pub const G_TIME_TYPE_STANDARD: GTimeType = GTimeType::Standard;
pub const G_TIME_TYPE_DAYLIGHT: GTimeType = GTimeType::Daylight;
pub const G_TIME_TYPE_UNIVERSAL: GTimeType = GTimeType::Universal;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTokenType {
    Eof = 0,
    LeftParen = 40,
    RightParen = 41,
    LeftCurly = 123,
    RightCurly = 125,
    LeftBrace = 91,
    RightBrace = 93,
    EqualSign = 61,
    Comma = 44,
    None = 256,
    Error = 257,
    Char = 258,
    Binary = 259,
    Octal = 260,
    Int = 261,
    Hex = 262,
    Float = 263,
    String = 264,
    Symbol = 265,
    Identifier = 266,
    IdentifierNull = 267,
    CommentSingle = 268,
    CommentMulti = 269,
}
pub const G_TOKEN_EOF: GTokenType = GTokenType::Eof;
pub const G_TOKEN_LEFT_PAREN: GTokenType = GTokenType::LeftParen;
pub const G_TOKEN_RIGHT_PAREN: GTokenType = GTokenType::RightParen;
pub const G_TOKEN_LEFT_CURLY: GTokenType = GTokenType::LeftCurly;
pub const G_TOKEN_RIGHT_CURLY: GTokenType = GTokenType::RightCurly;
pub const G_TOKEN_LEFT_BRACE: GTokenType = GTokenType::LeftBrace;
pub const G_TOKEN_RIGHT_BRACE: GTokenType = GTokenType::RightBrace;
pub const G_TOKEN_EQUAL_SIGN: GTokenType = GTokenType::EqualSign;
pub const G_TOKEN_COMMA: GTokenType = GTokenType::Comma;
pub const G_TOKEN_NONE: GTokenType = GTokenType::None;
pub const G_TOKEN_ERROR: GTokenType = GTokenType::Error;
pub const G_TOKEN_CHAR: GTokenType = GTokenType::Char;
pub const G_TOKEN_BINARY: GTokenType = GTokenType::Binary;
pub const G_TOKEN_OCTAL: GTokenType = GTokenType::Octal;
pub const G_TOKEN_INT: GTokenType = GTokenType::Int;
pub const G_TOKEN_HEX: GTokenType = GTokenType::Hex;
pub const G_TOKEN_FLOAT: GTokenType = GTokenType::Float;
pub const G_TOKEN_STRING: GTokenType = GTokenType::String;
pub const G_TOKEN_SYMBOL: GTokenType = GTokenType::Symbol;
pub const G_TOKEN_IDENTIFIER: GTokenType = GTokenType::Identifier;
pub const G_TOKEN_IDENTIFIER_NULL: GTokenType = GTokenType::IdentifierNull;
pub const G_TOKEN_COMMENT_SINGLE: GTokenType = GTokenType::CommentSingle;
pub const G_TOKEN_COMMENT_MULTI: GTokenType = GTokenType::CommentMulti;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTraverseType {
    InOrder = 0,
    PreOrder = 1,
    PostOrder = 2,
    LevelOrder = 3,
}
pub const G_IN_ORDER: GTraverseType = GTraverseType::InOrder;
pub const G_PRE_ORDER: GTraverseType = GTraverseType::PreOrder;
pub const G_POST_ORDER: GTraverseType = GTraverseType::PostOrder;
pub const G_LEVEL_ORDER: GTraverseType = GTraverseType::LevelOrder;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GUnicodeBreakType {
    Mandatory = 0,
    CarriageReturn = 1,
    LineFeed = 2,
    CombiningMark = 3,
    Surrogate = 4,
    ZeroWidthSpace = 5,
    Inseparable = 6,
    NonBreakingGlue = 7,
    Contingent = 8,
    Space = 9,
    After = 10,
    Before = 11,
    BeforeAndAfter = 12,
    Hyphen = 13,
    NonStarter = 14,
    OpenPunctuation = 15,
    ClosePunctuation = 16,
    Quotation = 17,
    Exclamation = 18,
    Ideographic = 19,
    Numeric = 20,
    InfixSeparator = 21,
    Symbol = 22,
    Alphabetic = 23,
    Prefix = 24,
    Postfix = 25,
    ComplexContext = 26,
    Ambiguous = 27,
    Unknown = 28,
    NextLine = 29,
    WordJoiner = 30,
    HangulLJamo = 31,
    HangulVJamo = 32,
    HangulTJamo = 33,
    HangulLvSyllable = 34,
    HangulLvtSyllable = 35,
    CloseParanthesis = 36,
    ConditionalJapaneseStarter = 37,
    HebrewLetter = 38,
    RegionalIndicator = 39,
}
pub const G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = GUnicodeBreakType::Mandatory;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = GUnicodeBreakType::CarriageReturn;
pub const G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = GUnicodeBreakType::LineFeed;
pub const G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = GUnicodeBreakType::CombiningMark;
pub const G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = GUnicodeBreakType::Surrogate;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = GUnicodeBreakType::ZeroWidthSpace;
pub const G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = GUnicodeBreakType::Inseparable;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = GUnicodeBreakType::NonBreakingGlue;
pub const G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = GUnicodeBreakType::Contingent;
pub const G_UNICODE_BREAK_SPACE: GUnicodeBreakType = GUnicodeBreakType::Space;
pub const G_UNICODE_BREAK_AFTER: GUnicodeBreakType = GUnicodeBreakType::After;
pub const G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = GUnicodeBreakType::Before;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = GUnicodeBreakType::BeforeAndAfter;
pub const G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = GUnicodeBreakType::Hyphen;
pub const G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = GUnicodeBreakType::NonStarter;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = GUnicodeBreakType::OpenPunctuation;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = GUnicodeBreakType::ClosePunctuation;
pub const G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = GUnicodeBreakType::Quotation;
pub const G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = GUnicodeBreakType::Exclamation;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = GUnicodeBreakType::Ideographic;
pub const G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = GUnicodeBreakType::Numeric;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = GUnicodeBreakType::InfixSeparator;
pub const G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = GUnicodeBreakType::Symbol;
pub const G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = GUnicodeBreakType::Alphabetic;
pub const G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = GUnicodeBreakType::Prefix;
pub const G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = GUnicodeBreakType::Postfix;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = GUnicodeBreakType::ComplexContext;
pub const G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = GUnicodeBreakType::Ambiguous;
pub const G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = GUnicodeBreakType::Unknown;
pub const G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = GUnicodeBreakType::NextLine;
pub const G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = GUnicodeBreakType::WordJoiner;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulLJamo;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulVJamo;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulTJamo;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = GUnicodeBreakType::HangulLvSyllable;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = GUnicodeBreakType::HangulLvtSyllable;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = GUnicodeBreakType::CloseParanthesis;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = GUnicodeBreakType::ConditionalJapaneseStarter;
pub const G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = GUnicodeBreakType::HebrewLetter;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = GUnicodeBreakType::RegionalIndicator;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GUnicodeScript {
    InvalidCode = -1,
    Common = 0,
    Inherited = 1,
    Arabic = 2,
    Armenian = 3,
    Bengali = 4,
    Bopomofo = 5,
    Cherokee = 6,
    Coptic = 7,
    Cyrillic = 8,
    Deseret = 9,
    Devanagari = 10,
    Ethiopic = 11,
    Georgian = 12,
    Gothic = 13,
    Greek = 14,
    Gujarati = 15,
    Gurmukhi = 16,
    Han = 17,
    Hangul = 18,
    Hebrew = 19,
    Hiragana = 20,
    Kannada = 21,
    Katakana = 22,
    Khmer = 23,
    Lao = 24,
    Latin = 25,
    Malayalam = 26,
    Mongolian = 27,
    Myanmar = 28,
    Ogham = 29,
    OldItalic = 30,
    Oriya = 31,
    Runic = 32,
    Sinhala = 33,
    Syriac = 34,
    Tamil = 35,
    Telugu = 36,
    Thaana = 37,
    Thai = 38,
    Tibetan = 39,
    CanadianAboriginal = 40,
    Yi = 41,
    Tagalog = 42,
    Hanunoo = 43,
    Buhid = 44,
    Tagbanwa = 45,
    Braille = 46,
    Cypriot = 47,
    Limbu = 48,
    Osmanya = 49,
    Shavian = 50,
    LinearB = 51,
    TaiLe = 52,
    Ugaritic = 53,
    NewTaiLue = 54,
    Buginese = 55,
    Glagolitic = 56,
    Tifinagh = 57,
    SylotiNagri = 58,
    OldPersian = 59,
    Kharoshthi = 60,
    Unknown = 61,
    Balinese = 62,
    Cuneiform = 63,
    Phoenician = 64,
    PhagsPa = 65,
    Nko = 66,
    KayahLi = 67,
    Lepcha = 68,
    Rejang = 69,
    Sundanese = 70,
    Saurashtra = 71,
    Cham = 72,
    OlChiki = 73,
    Vai = 74,
    Carian = 75,
    Lycian = 76,
    Lydian = 77,
    Avestan = 78,
    Bamum = 79,
    EgyptianHieroglyphs = 80,
    ImperialAramaic = 81,
    InscriptionalPahlavi = 82,
    InscriptionalParthian = 83,
    Javanese = 84,
    Kaithi = 85,
    Lisu = 86,
    MeeteiMayek = 87,
    OldSouthArabian = 88,
    OldTurkic = 89,
    Samaritan = 90,
    TaiTham = 91,
    TaiViet = 92,
    Batak = 93,
    Brahmi = 94,
    Mandaic = 95,
    Chakma = 96,
    MeroiticCursive = 97,
    MeroiticHieroglyphs = 98,
    Miao = 99,
    Sharada = 100,
    SoraSompeng = 101,
    Takri = 102,
    BassaVah = 103,
    CaucasianAlbanian = 104,
    Duployan = 105,
    Elbasan = 106,
    Grantha = 107,
    Khojki = 108,
    Khudawadi = 109,
    LinearA = 110,
    Mahajani = 111,
    Manichaean = 112,
    MendeKikakui = 113,
    Modi = 114,
    Mro = 115,
    Nabataean = 116,
    OldNorthArabian = 117,
    OldPermic = 118,
    PahawhHmong = 119,
    Palmyrene = 120,
    PauCinHau = 121,
    PsalterPahlavi = 122,
    Siddham = 123,
    Tirhuta = 124,
    WarangCiti = 125,
    Ahom = 126,
    AnatolianHieroglyphs = 127,
    Hatran = 128,
    Multani = 129,
    OldHungarian = 130,
    Signwriting = 131,
}
pub const G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = GUnicodeScript::InvalidCode;
pub const G_UNICODE_SCRIPT_COMMON: GUnicodeScript = GUnicodeScript::Common;
pub const G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = GUnicodeScript::Inherited;
pub const G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = GUnicodeScript::Arabic;
pub const G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = GUnicodeScript::Armenian;
pub const G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = GUnicodeScript::Bengali;
pub const G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = GUnicodeScript::Bopomofo;
pub const G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = GUnicodeScript::Cherokee;
pub const G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = GUnicodeScript::Coptic;
pub const G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = GUnicodeScript::Cyrillic;
pub const G_UNICODE_SCRIPT_DESERET: GUnicodeScript = GUnicodeScript::Deseret;
pub const G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = GUnicodeScript::Devanagari;
pub const G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = GUnicodeScript::Ethiopic;
pub const G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = GUnicodeScript::Georgian;
pub const G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = GUnicodeScript::Gothic;
pub const G_UNICODE_SCRIPT_GREEK: GUnicodeScript = GUnicodeScript::Greek;
pub const G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = GUnicodeScript::Gujarati;
pub const G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = GUnicodeScript::Gurmukhi;
pub const G_UNICODE_SCRIPT_HAN: GUnicodeScript = GUnicodeScript::Han;
pub const G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = GUnicodeScript::Hangul;
pub const G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = GUnicodeScript::Hebrew;
pub const G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = GUnicodeScript::Hiragana;
pub const G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = GUnicodeScript::Kannada;
pub const G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = GUnicodeScript::Katakana;
pub const G_UNICODE_SCRIPT_KHMER: GUnicodeScript = GUnicodeScript::Khmer;
pub const G_UNICODE_SCRIPT_LAO: GUnicodeScript = GUnicodeScript::Lao;
pub const G_UNICODE_SCRIPT_LATIN: GUnicodeScript = GUnicodeScript::Latin;
pub const G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = GUnicodeScript::Malayalam;
pub const G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = GUnicodeScript::Mongolian;
pub const G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = GUnicodeScript::Myanmar;
pub const G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = GUnicodeScript::Ogham;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = GUnicodeScript::OldItalic;
pub const G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = GUnicodeScript::Oriya;
pub const G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = GUnicodeScript::Runic;
pub const G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = GUnicodeScript::Sinhala;
pub const G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = GUnicodeScript::Syriac;
pub const G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = GUnicodeScript::Tamil;
pub const G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = GUnicodeScript::Telugu;
pub const G_UNICODE_SCRIPT_THAANA: GUnicodeScript = GUnicodeScript::Thaana;
pub const G_UNICODE_SCRIPT_THAI: GUnicodeScript = GUnicodeScript::Thai;
pub const G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = GUnicodeScript::Tibetan;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = GUnicodeScript::CanadianAboriginal;
pub const G_UNICODE_SCRIPT_YI: GUnicodeScript = GUnicodeScript::Yi;
pub const G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = GUnicodeScript::Tagalog;
pub const G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = GUnicodeScript::Hanunoo;
pub const G_UNICODE_SCRIPT_BUHID: GUnicodeScript = GUnicodeScript::Buhid;
pub const G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = GUnicodeScript::Tagbanwa;
pub const G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = GUnicodeScript::Braille;
pub const G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = GUnicodeScript::Cypriot;
pub const G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = GUnicodeScript::Limbu;
pub const G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = GUnicodeScript::Osmanya;
pub const G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = GUnicodeScript::Shavian;
pub const G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = GUnicodeScript::LinearB;
pub const G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = GUnicodeScript::TaiLe;
pub const G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = GUnicodeScript::Ugaritic;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = GUnicodeScript::NewTaiLue;
pub const G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = GUnicodeScript::Buginese;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = GUnicodeScript::Glagolitic;
pub const G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = GUnicodeScript::Tifinagh;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = GUnicodeScript::SylotiNagri;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = GUnicodeScript::OldPersian;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = GUnicodeScript::Kharoshthi;
pub const G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = GUnicodeScript::Unknown;
pub const G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = GUnicodeScript::Balinese;
pub const G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = GUnicodeScript::Cuneiform;
pub const G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = GUnicodeScript::Phoenician;
pub const G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = GUnicodeScript::PhagsPa;
pub const G_UNICODE_SCRIPT_NKO: GUnicodeScript = GUnicodeScript::Nko;
pub const G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = GUnicodeScript::KayahLi;
pub const G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = GUnicodeScript::Lepcha;
pub const G_UNICODE_SCRIPT_REJANG: GUnicodeScript = GUnicodeScript::Rejang;
pub const G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = GUnicodeScript::Sundanese;
pub const G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = GUnicodeScript::Saurashtra;
pub const G_UNICODE_SCRIPT_CHAM: GUnicodeScript = GUnicodeScript::Cham;
pub const G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = GUnicodeScript::OlChiki;
pub const G_UNICODE_SCRIPT_VAI: GUnicodeScript = GUnicodeScript::Vai;
pub const G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = GUnicodeScript::Carian;
pub const G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = GUnicodeScript::Lycian;
pub const G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = GUnicodeScript::Lydian;
pub const G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = GUnicodeScript::Avestan;
pub const G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = GUnicodeScript::Bamum;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::EgyptianHieroglyphs;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = GUnicodeScript::ImperialAramaic;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = GUnicodeScript::InscriptionalPahlavi;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = GUnicodeScript::InscriptionalParthian;
pub const G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = GUnicodeScript::Javanese;
pub const G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = GUnicodeScript::Kaithi;
pub const G_UNICODE_SCRIPT_LISU: GUnicodeScript = GUnicodeScript::Lisu;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = GUnicodeScript::MeeteiMayek;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = GUnicodeScript::OldSouthArabian;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = GUnicodeScript::OldTurkic;
pub const G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = GUnicodeScript::Samaritan;
pub const G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = GUnicodeScript::TaiTham;
pub const G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = GUnicodeScript::TaiViet;
pub const G_UNICODE_SCRIPT_BATAK: GUnicodeScript = GUnicodeScript::Batak;
pub const G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = GUnicodeScript::Brahmi;
pub const G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = GUnicodeScript::Mandaic;
pub const G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = GUnicodeScript::Chakma;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = GUnicodeScript::MeroiticCursive;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::MeroiticHieroglyphs;
pub const G_UNICODE_SCRIPT_MIAO: GUnicodeScript = GUnicodeScript::Miao;
pub const G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = GUnicodeScript::Sharada;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = GUnicodeScript::SoraSompeng;
pub const G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = GUnicodeScript::Takri;
pub const G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = GUnicodeScript::BassaVah;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = GUnicodeScript::CaucasianAlbanian;
pub const G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = GUnicodeScript::Duployan;
pub const G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = GUnicodeScript::Elbasan;
pub const G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = GUnicodeScript::Grantha;
pub const G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = GUnicodeScript::Khojki;
pub const G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = GUnicodeScript::Khudawadi;
pub const G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = GUnicodeScript::LinearA;
pub const G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = GUnicodeScript::Mahajani;
pub const G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = GUnicodeScript::Manichaean;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = GUnicodeScript::MendeKikakui;
pub const G_UNICODE_SCRIPT_MODI: GUnicodeScript = GUnicodeScript::Modi;
pub const G_UNICODE_SCRIPT_MRO: GUnicodeScript = GUnicodeScript::Mro;
pub const G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = GUnicodeScript::Nabataean;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = GUnicodeScript::OldNorthArabian;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = GUnicodeScript::OldPermic;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = GUnicodeScript::PahawhHmong;
pub const G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = GUnicodeScript::Palmyrene;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = GUnicodeScript::PauCinHau;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = GUnicodeScript::PsalterPahlavi;
pub const G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = GUnicodeScript::Siddham;
pub const G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = GUnicodeScript::Tirhuta;
pub const G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = GUnicodeScript::WarangCiti;
pub const G_UNICODE_SCRIPT_AHOM: GUnicodeScript = GUnicodeScript::Ahom;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::AnatolianHieroglyphs;
pub const G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = GUnicodeScript::Hatran;
pub const G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = GUnicodeScript::Multani;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = GUnicodeScript::OldHungarian;
pub const G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = GUnicodeScript::Signwriting;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GUnicodeType {
    Control = 0,
    Format = 1,
    Unassigned = 2,
    PrivateUse = 3,
    Surrogate = 4,
    LowercaseLetter = 5,
    ModifierLetter = 6,
    OtherLetter = 7,
    TitlecaseLetter = 8,
    UppercaseLetter = 9,
    SpacingMark = 10,
    EnclosingMark = 11,
    NonSpacingMark = 12,
    DecimalNumber = 13,
    LetterNumber = 14,
    OtherNumber = 15,
    ConnectPunctuation = 16,
    DashPunctuation = 17,
    ClosePunctuation = 18,
    FinalPunctuation = 19,
    InitialPunctuation = 20,
    OtherPunctuation = 21,
    OpenPunctuation = 22,
    CurrencySymbol = 23,
    ModifierSymbol = 24,
    MathSymbol = 25,
    OtherSymbol = 26,
    LineSeparator = 27,
    ParagraphSeparator = 28,
    SpaceSeparator = 29,
}
pub const G_UNICODE_CONTROL: GUnicodeType = GUnicodeType::Control;
pub const G_UNICODE_FORMAT: GUnicodeType = GUnicodeType::Format;
pub const G_UNICODE_UNASSIGNED: GUnicodeType = GUnicodeType::Unassigned;
pub const G_UNICODE_PRIVATE_USE: GUnicodeType = GUnicodeType::PrivateUse;
pub const G_UNICODE_SURROGATE: GUnicodeType = GUnicodeType::Surrogate;
pub const G_UNICODE_LOWERCASE_LETTER: GUnicodeType = GUnicodeType::LowercaseLetter;
pub const G_UNICODE_MODIFIER_LETTER: GUnicodeType = GUnicodeType::ModifierLetter;
pub const G_UNICODE_OTHER_LETTER: GUnicodeType = GUnicodeType::OtherLetter;
pub const G_UNICODE_TITLECASE_LETTER: GUnicodeType = GUnicodeType::TitlecaseLetter;
pub const G_UNICODE_UPPERCASE_LETTER: GUnicodeType = GUnicodeType::UppercaseLetter;
pub const G_UNICODE_SPACING_MARK: GUnicodeType = GUnicodeType::SpacingMark;
pub const G_UNICODE_ENCLOSING_MARK: GUnicodeType = GUnicodeType::EnclosingMark;
pub const G_UNICODE_NON_SPACING_MARK: GUnicodeType = GUnicodeType::NonSpacingMark;
pub const G_UNICODE_DECIMAL_NUMBER: GUnicodeType = GUnicodeType::DecimalNumber;
pub const G_UNICODE_LETTER_NUMBER: GUnicodeType = GUnicodeType::LetterNumber;
pub const G_UNICODE_OTHER_NUMBER: GUnicodeType = GUnicodeType::OtherNumber;
pub const G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = GUnicodeType::ConnectPunctuation;
pub const G_UNICODE_DASH_PUNCTUATION: GUnicodeType = GUnicodeType::DashPunctuation;
pub const G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = GUnicodeType::ClosePunctuation;
pub const G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = GUnicodeType::FinalPunctuation;
pub const G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = GUnicodeType::InitialPunctuation;
pub const G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = GUnicodeType::OtherPunctuation;
pub const G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = GUnicodeType::OpenPunctuation;
pub const G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = GUnicodeType::CurrencySymbol;
pub const G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = GUnicodeType::ModifierSymbol;
pub const G_UNICODE_MATH_SYMBOL: GUnicodeType = GUnicodeType::MathSymbol;
pub const G_UNICODE_OTHER_SYMBOL: GUnicodeType = GUnicodeType::OtherSymbol;
pub const G_UNICODE_LINE_SEPARATOR: GUnicodeType = GUnicodeType::LineSeparator;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = GUnicodeType::ParagraphSeparator;
pub const G_UNICODE_SPACE_SEPARATOR: GUnicodeType = GUnicodeType::SpaceSeparator;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GUserDirectory {
    DirectoryDesktop = 0,
    DirectoryDocuments = 1,
    DirectoryDownload = 2,
    DirectoryMusic = 3,
    DirectoryPictures = 4,
    DirectoryPublicShare = 5,
    DirectoryTemplates = 6,
    DirectoryVideos = 7,
    NDirectories = 8,
}
pub const G_USER_DIRECTORY_DESKTOP: GUserDirectory = GUserDirectory::DirectoryDesktop;
pub const G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = GUserDirectory::DirectoryDocuments;
pub const G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = GUserDirectory::DirectoryDownload;
pub const G_USER_DIRECTORY_MUSIC: GUserDirectory = GUserDirectory::DirectoryMusic;
pub const G_USER_DIRECTORY_PICTURES: GUserDirectory = GUserDirectory::DirectoryPictures;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = GUserDirectory::DirectoryPublicShare;
pub const G_USER_DIRECTORY_TEMPLATES: GUserDirectory = GUserDirectory::DirectoryTemplates;
pub const G_USER_DIRECTORY_VIDEOS: GUserDirectory = GUserDirectory::DirectoryVideos;
pub const G_USER_N_DIRECTORIES: GUserDirectory = GUserDirectory::NDirectories;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GVariantClass {
    Boolean = 98,
    Byte = 121,
    Int16 = 110,
    Uint16 = 113,
    Int32 = 105,
    Uint32 = 117,
    Int64 = 120,
    Uint64 = 116,
    Handle = 104,
    Double = 100,
    String = 115,
    ObjectPath = 111,
    Signature = 103,
    Variant = 118,
    Maybe = 109,
    Array = 97,
    Tuple = 40,
    DictEntry = 123,
}
pub const G_VARIANT_CLASS_BOOLEAN: GVariantClass = GVariantClass::Boolean;
pub const G_VARIANT_CLASS_BYTE: GVariantClass = GVariantClass::Byte;
pub const G_VARIANT_CLASS_INT16: GVariantClass = GVariantClass::Int16;
pub const G_VARIANT_CLASS_UINT16: GVariantClass = GVariantClass::Uint16;
pub const G_VARIANT_CLASS_INT32: GVariantClass = GVariantClass::Int32;
pub const G_VARIANT_CLASS_UINT32: GVariantClass = GVariantClass::Uint32;
pub const G_VARIANT_CLASS_INT64: GVariantClass = GVariantClass::Int64;
pub const G_VARIANT_CLASS_UINT64: GVariantClass = GVariantClass::Uint64;
pub const G_VARIANT_CLASS_HANDLE: GVariantClass = GVariantClass::Handle;
pub const G_VARIANT_CLASS_DOUBLE: GVariantClass = GVariantClass::Double;
pub const G_VARIANT_CLASS_STRING: GVariantClass = GVariantClass::String;
pub const G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = GVariantClass::ObjectPath;
pub const G_VARIANT_CLASS_SIGNATURE: GVariantClass = GVariantClass::Signature;
pub const G_VARIANT_CLASS_VARIANT: GVariantClass = GVariantClass::Variant;
pub const G_VARIANT_CLASS_MAYBE: GVariantClass = GVariantClass::Maybe;
pub const G_VARIANT_CLASS_ARRAY: GVariantClass = GVariantClass::Array;
pub const G_VARIANT_CLASS_TUPLE: GVariantClass = GVariantClass::Tuple;
pub const G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = GVariantClass::DictEntry;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GVariantParseError {
    Failed = 0,
    BasicTypeExpected = 1,
    CannotInferType = 2,
    DefiniteTypeExpected = 3,
    InputNotAtEnd = 4,
    InvalidCharacter = 5,
    InvalidFormatString = 6,
    InvalidObjectPath = 7,
    InvalidSignature = 8,
    InvalidTypeString = 9,
    NoCommonType = 10,
    NumberOutOfRange = 11,
    NumberTooBig = 12,
    TypeError = 13,
    UnexpectedToken = 14,
    UnknownKeyword = 15,
    UnterminatedStringConstant = 16,
    ValueExpected = 17,
}
pub const G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = GVariantParseError::Failed;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = GVariantParseError::BasicTypeExpected;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = GVariantParseError::CannotInferType;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = GVariantParseError::DefiniteTypeExpected;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = GVariantParseError::InputNotAtEnd;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = GVariantParseError::InvalidCharacter;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = GVariantParseError::InvalidFormatString;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = GVariantParseError::InvalidObjectPath;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = GVariantParseError::InvalidSignature;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = GVariantParseError::InvalidTypeString;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = GVariantParseError::NoCommonType;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = GVariantParseError::NumberOutOfRange;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = GVariantParseError::NumberTooBig;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = GVariantParseError::TypeError;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = GVariantParseError::UnexpectedToken;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = GVariantParseError::UnknownKeyword;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = GVariantParseError::UnterminatedStringConstant;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = GVariantParseError::ValueExpected;

// Constants
pub const G_ANALYZER_ANALYZING: i32 = 1;
pub const G_ASCII_DTOSTR_BUF_SIZE: i32 = 39;
pub const G_BIG_ENDIAN: i32 = 4321;
pub const G_CSET_A_2_Z: &'static str = r##"ABCDEFGHIJKLMNOPQRSTUVWXYZ"##;
pub const G_CSET_DIGITS: &'static str = r##"0123456789"##;
pub const G_CSET_a_2_z: &'static str = r##"abcdefghijklmnopqrstuvwxyz"##;
pub const G_DATALIST_FLAGS_MASK: i32 = 3;
pub const G_DATE_BAD_DAY: i32 = 0;
pub const G_DATE_BAD_JULIAN: i32 = 0;
pub const G_DATE_BAD_YEAR: i32 = 0;
pub const G_DIR_SEPARATOR: i32 = 92;
pub const G_DIR_SEPARATOR_S: &'static str = r##"\"##;
pub const G_E: f64 = 2.718282;
pub const G_GINT16_FORMAT: &'static str = r##"hi"##;
pub const G_GINT16_MODIFIER: &'static str = r##"h"##;
pub const G_GINT32_FORMAT: &'static str = r##"i"##;
pub const G_GINT32_MODIFIER: &'static str = r##""##;
//pub const G_GINT64_FORMAT: &'static str = r##"li"##;
//pub const G_GINT64_MODIFIER: &'static str = r##"l"##;
//pub const G_GINTPTR_FORMAT: &'static str = r##"li"##;
//pub const G_GINTPTR_MODIFIER: &'static str = r##"l"##;
pub const G_GNUC_FUNCTION: &'static str = r##""##;
pub const G_GNUC_PRETTY_FUNCTION: &'static str = r##""##;
//pub const G_GSIZE_FORMAT: &'static str = r##"lu"##;
//pub const G_GSIZE_MODIFIER: &'static str = r##"l"##;
//pub const G_GSSIZE_FORMAT: &'static str = r##"li"##;
//pub const G_GSSIZE_MODIFIER: &'static str = r##"l"##;
pub const G_GUINT16_FORMAT: &'static str = r##"hu"##;
pub const G_GUINT32_FORMAT: &'static str = r##"u"##;
//pub const G_GUINT64_FORMAT: &'static str = r##"lu"##;
//pub const G_GUINTPTR_FORMAT: &'static str = r##"lu"##;
pub const G_HAVE_GINT64: i32 = 1;
pub const G_HAVE_GNUC_VARARGS: i32 = 1;
pub const G_HAVE_GNUC_VISIBILITY: i32 = 1;
pub const G_HAVE_GROWING_STACK: i32 = 0;
pub const G_HAVE_ISO_VARARGS: i32 = 1;
pub const G_HOOK_FLAG_USER_SHIFT: i32 = 4;
pub const G_IEEE754_DOUBLE_BIAS: i32 = 1023;
pub const G_IEEE754_FLOAT_BIAS: i32 = 127;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static str = r##"Desktop Entry"##;
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static str = r##"Actions"##;
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static str = r##"Categories"##;
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static str = r##"Comment"##;
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static str = r##"DBusActivatable"##;
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static str = r##"Exec"##;
pub const G_KEY_FILE_DESKTOP_KEY_FULLNAME: &'static str = r##"X-GNOME-FullName"##;
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static str = r##"GenericName"##;
pub const G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN: &'static str = r##"X-GNOME-Gettext-Domain"##;
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static str = r##"Hidden"##;
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static str = r##"Icon"##;
pub const G_KEY_FILE_DESKTOP_KEY_KEYWORDS: &'static str = r##"Keywords"##;
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static str = r##"MimeType"##;
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static str = r##"Name"##;
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static str = r##"NotShowIn"##;
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static str = r##"NoDisplay"##;
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static str = r##"OnlyShowIn"##;
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static str = r##"Path"##;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static str = r##"StartupNotify"##;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static str = r##"StartupWMClass"##;
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static str = r##"Terminal"##;
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static str = r##"TryExec"##;
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static str = r##"Type"##;
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static str = r##"URL"##;
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static str = r##"Version"##;
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static str = r##"Application"##;
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static str = r##"Directory"##;
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static str = r##"Link"##;
pub const G_LITTLE_ENDIAN: i32 = 1234;
pub const G_LN10: f64 = 2.302585;
pub const G_LN2: f64 = 0.693147;
pub const G_LOG_2_BASE_10: f64 = 0.301030;
//pub const G_LOG_DOMAIN: /*Unimplemented*/Fundamental: Char = 0;
pub const G_LOG_FATAL_MASK: i32 = 0;
pub const G_LOG_LEVEL_USER_SHIFT: i32 = 8;
pub const GLIB_MAJOR_VERSION: i32 = 2;
pub const G_MAXINT16: i16 = 32767;
pub const G_MAXINT32: i32 = 2147483647;
pub const G_MAXINT64: i64 = 9223372036854775807;
pub const G_MAXINT8: i8 = 127;
pub const G_MAXUINT16: u16 = 65535;
pub const G_MAXUINT32: u32 = 4294967295;
pub const G_MAXUINT64: u64 = 18446744073709551615;
pub const G_MAXUINT8: u8 = 255;
pub const GLIB_MICRO_VERSION: i32 = 0;
//pub const G_MININT16: i16 = -32768;
//pub const G_MININT32: i32 = -2147483648;
pub const G_MININT64: i64 = -9223372036854775808;
//pub const G_MININT8: i8 = -128;
pub const GLIB_MINOR_VERSION: i32 = 50;
pub const G_MODULE_SUFFIX: &'static str = r##"so"##;
pub const G_OPTION_REMAINING: &'static str = r##""##;
pub const G_PDP_ENDIAN: i32 = 3412;
pub const G_PI: f64 = 3.141593;
pub const G_PID_FORMAT: &'static str = r##"i"##;
pub const G_PI_2: f64 = 1.570796;
pub const G_PI_4: f64 = 0.785398;
pub const G_POLLFD_FORMAT: &'static str = r##"%d"##;
pub const G_PRIORITY_DEFAULT: i32 = 0;
pub const G_PRIORITY_DEFAULT_IDLE: i32 = 200;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_HIGH_IDLE: i32 = 100;
pub const G_PRIORITY_LOW: i32 = 300;
pub const G_SEARCHPATH_SEPARATOR: i32 = 59;
pub const G_SEARCHPATH_SEPARATOR_S: &'static str = r##";"##;
//pub const GLIB_SIZEOF_LONG: i32 = 8;
//pub const GLIB_SIZEOF_SIZE_T: i32 = 8;
//pub const GLIB_SIZEOF_SSIZE_T: i32 = 8;
//pub const GLIB_SIZEOF_VOID_P: i32 = 8;
pub const G_SOURCE_CONTINUE: bool = true;
pub const G_SOURCE_REMOVE: bool = false;
pub const G_SQRT2: f64 = 1.414214;
pub const G_STR_DELIMITERS: &'static str = r##"_-|> <."##;
pub const GLIB_SYSDEF_AF_INET: i32 = 2;
pub const GLIB_SYSDEF_AF_INET6: i32 = 10;
pub const GLIB_SYSDEF_AF_UNIX: i32 = 1;
pub const GLIB_SYSDEF_MSG_DONTROUTE: i32 = 4;
pub const GLIB_SYSDEF_MSG_OOB: i32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: i32 = 2;
pub const G_TIME_SPAN_DAY: i64 = 86400000000;
pub const G_TIME_SPAN_HOUR: i64 = 3600000000;
pub const G_TIME_SPAN_MILLISECOND: i64 = 1000;
pub const G_TIME_SPAN_MINUTE: i64 = 60000000;
pub const G_TIME_SPAN_SECOND: i64 = 1000000;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: i32 = 18;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static str = r##":/?#[]@"##;
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static str = r##"!$&'()*+,;="##;
pub const G_USEC_PER_SEC: i32 = 1000000;
//pub const G_VA_COPY_AS_ARRAY: i32 = 1;
pub const GLIB_VERSION_MIN_REQUIRED: i32 = 2;
pub const G_WIN32_MSG_HANDLE: i32 = 19981206;

// Flags
bitflags! {
    #[repr(C)]
    flags GAsciiType: c_uint {
        const G_ASCII_ALNUM = 1,
        const G_ASCII_ALPHA = 2,
        const G_ASCII_CNTRL = 4,
        const G_ASCII_DIGIT = 8,
        const G_ASCII_GRAPH = 16,
        const G_ASCII_LOWER = 32,
        const G_ASCII_PRINT = 64,
        const G_ASCII_PUNCT = 128,
        const G_ASCII_SPACE = 256,
        const G_ASCII_UPPER = 512,
        const G_ASCII_XDIGIT = 1024,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileTest: c_uint {
        const G_FILE_TEST_IS_REGULAR = 1,
        const G_FILE_TEST_IS_SYMLINK = 2,
        const G_FILE_TEST_IS_DIR = 4,
        const G_FILE_TEST_IS_EXECUTABLE = 8,
        const G_FILE_TEST_EXISTS = 16,
    }
}

bitflags! {
    #[repr(C)]
    flags GFormatSizeFlags: c_uint {
        const G_FORMAT_SIZE_DEFAULT = 0,
        const G_FORMAT_SIZE_LONG_FORMAT = 1,
        const G_FORMAT_SIZE_IEC_UNITS = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GHookFlagMask: c_uint {
        const G_HOOK_FLAG_ACTIVE = 1,
        const G_HOOK_FLAG_IN_CALL = 2,
        const G_HOOK_FLAG_MASK = 15,
    }
}

bitflags! {
    #[repr(C)]
    flags GIOCondition: c_uint {
        const G_IO_IN = 1,
        const G_IO_OUT = 4,
        const G_IO_PRI = 2,
        const G_IO_ERR = 8,
        const G_IO_HUP = 16,
        const G_IO_NVAL = 32,
    }
}

bitflags! {
    #[repr(C)]
    flags GIOFlags: c_uint {
        const G_IO_FLAG_APPEND = 1,
        const G_IO_FLAG_NONBLOCK = 2,
        const G_IO_FLAG_IS_READABLE = 4,
        const G_IO_FLAG_IS_WRITABLE = 8,
        const G_IO_FLAG_IS_WRITEABLE = 8,
        const G_IO_FLAG_IS_SEEKABLE = 16,
        const G_IO_FLAG_MASK = 31,
        const G_IO_FLAG_GET_MASK = 31,
        const G_IO_FLAG_SET_MASK = 3,
    }
}

bitflags! {
    #[repr(C)]
    flags GKeyFileFlags: c_uint {
        const G_KEY_FILE_NONE = 0,
        const G_KEY_FILE_KEEP_COMMENTS = 1,
        const G_KEY_FILE_KEEP_TRANSLATIONS = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GLogLevelFlags: c_uint {
        const G_LOG_FLAG_RECURSION = 1,
        const G_LOG_FLAG_FATAL = 2,
        const G_LOG_LEVEL_ERROR = 4,
        const G_LOG_LEVEL_CRITICAL = 8,
        const G_LOG_LEVEL_WARNING = 16,
        const G_LOG_LEVEL_MESSAGE = 32,
        const G_LOG_LEVEL_INFO = 64,
        const G_LOG_LEVEL_DEBUG = 128,
        const G_LOG_LEVEL_MASK = 4294967292,
    }
}

bitflags! {
    #[repr(C)]
    flags GMarkupCollectType: c_uint {
        const G_MARKUP_COLLECT_INVALID = 0,
        const G_MARKUP_COLLECT_STRING = 1,
        const G_MARKUP_COLLECT_STRDUP = 2,
        const G_MARKUP_COLLECT_BOOLEAN = 3,
        const G_MARKUP_COLLECT_TRISTATE = 4,
        const G_MARKUP_COLLECT_OPTIONAL = 65536,
    }
}

bitflags! {
    #[repr(C)]
    flags GMarkupParseFlags: c_uint {
        const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
        const G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
        const G_MARKUP_PREFIX_ERROR_POSITION = 4,
        const G_MARKUP_IGNORE_QUALIFIED = 8,
    }
}

bitflags! {
    #[repr(C)]
    flags GOptionFlags: c_uint {
        const G_OPTION_FLAG_NONE = 0,
        const G_OPTION_FLAG_HIDDEN = 1,
        const G_OPTION_FLAG_IN_MAIN = 2,
        const G_OPTION_FLAG_REVERSE = 4,
        const G_OPTION_FLAG_NO_ARG = 8,
        const G_OPTION_FLAG_FILENAME = 16,
        const G_OPTION_FLAG_OPTIONAL_ARG = 32,
        const G_OPTION_FLAG_NOALIAS = 64,
    }
}

bitflags! {
    #[repr(C)]
    flags GRegexCompileFlags: c_uint {
        const G_REGEX_CASELESS = 1,
        const G_REGEX_MULTILINE = 2,
        const G_REGEX_DOTALL = 4,
        const G_REGEX_EXTENDED = 8,
        const G_REGEX_ANCHORED = 16,
        const G_REGEX_DOLLAR_ENDONLY = 32,
        const G_REGEX_UNGREEDY = 512,
        const G_REGEX_RAW = 2048,
        const G_REGEX_NO_AUTO_CAPTURE = 4096,
        const G_REGEX_OPTIMIZE = 8192,
        const G_REGEX_FIRSTLINE = 262144,
        const G_REGEX_DUPNAMES = 524288,
        const G_REGEX_NEWLINE_CR = 1048576,
        const G_REGEX_NEWLINE_LF = 2097152,
        const G_REGEX_NEWLINE_CRLF = 3145728,
        const G_REGEX_NEWLINE_ANYCRLF = 5242880,
        const G_REGEX_BSR_ANYCRLF = 8388608,
        const G_REGEX_JAVASCRIPT_COMPAT = 33554432,
    }
}

bitflags! {
    #[repr(C)]
    flags GRegexMatchFlags: c_uint {
        const G_REGEX_MATCH_ANCHORED = 16,
        const G_REGEX_MATCH_NOTBOL = 128,
        const G_REGEX_MATCH_NOTEOL = 256,
        const G_REGEX_MATCH_NOTEMPTY = 1024,
        const G_REGEX_MATCH_PARTIAL = 32768,
        const G_REGEX_MATCH_NEWLINE_CR = 1048576,
        const G_REGEX_MATCH_NEWLINE_LF = 2097152,
        const G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
        const G_REGEX_MATCH_NEWLINE_ANY = 4194304,
        const G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
        const G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
        const G_REGEX_MATCH_BSR_ANY = 16777216,
        const G_REGEX_MATCH_PARTIAL_SOFT = 32768,
        const G_REGEX_MATCH_PARTIAL_HARD = 134217728,
        const G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456,
    }
}

bitflags! {
    #[repr(C)]
    flags GSpawnFlags: c_uint {
        const G_SPAWN_DEFAULT = 0,
        const G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
        const G_SPAWN_DO_NOT_REAP_CHILD = 2,
        const G_SPAWN_SEARCH_PATH = 4,
        const G_SPAWN_STDOUT_TO_DEV_NULL = 8,
        const G_SPAWN_STDERR_TO_DEV_NULL = 16,
        const G_SPAWN_CHILD_INHERITS_STDIN = 32,
        const G_SPAWN_FILE_AND_ARGV_ZERO = 64,
        const G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
        const G_SPAWN_CLOEXEC_PIPES = 256,
    }
}

bitflags! {
    #[repr(C)]
    flags GTestSubprocessFlags: c_uint {
        const G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
        const G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
        const G_TEST_SUBPROCESS_INHERIT_STDERR = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GTestTrapFlags: c_uint {
        const G_TEST_TRAP_SILENCE_STDOUT = 128,
        const G_TEST_TRAP_SILENCE_STDERR = 256,
        const G_TEST_TRAP_INHERIT_STDIN = 512,
    }
}

bitflags! {
    #[repr(C)]
    flags GTraverseFlags: c_uint {
        const G_TRAVERSE_LEAVES = 1,
        const G_TRAVERSE_NON_LEAVES = 2,
        const G_TRAVERSE_ALL = 3,
        const G_TRAVERSE_MASK = 3,
        const G_TRAVERSE_LEAFS = 1,
        const G_TRAVERSE_NON_LEAFS = 2,
    }
}

// Unions
pub type GDoubleIEEE754 = c_void; // union
pub type GFloatIEEE754 = c_void; // union
pub type GMutex = c_void; // union
pub type GTokenValue = c_void; // union

// Callbacks
pub type GChildWatchFunc = Option<unsafe extern "C" fn(GPid, c_int, gpointer)>;
pub type GCompareDataFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer, gpointer) -> c_int>;
pub type GCompareFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> c_int>;
pub type GCopyFunc = Option<unsafe extern "C" fn(gconstpointer, gpointer) -> gpointer>;
pub type GDataForeachFunc = Option<unsafe extern "C" fn(GQuark, gpointer, gpointer)>;
pub type GDestroyNotify = Option<unsafe extern "C" fn(gpointer)>;
pub type GDuplicateFunc = Option<unsafe extern "C" fn(gpointer, gpointer) -> gpointer>;
pub type GEqualFunc = Option<unsafe extern "C" fn(gconstpointer, gconstpointer) -> gboolean>;
pub type GFreeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GHFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer)>;
pub type GHRFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GHashFunc = Option<unsafe extern "C" fn(gconstpointer) -> c_uint>;
pub type GHookCheckFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GHookCheckMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookCompareFunc = Option<unsafe extern "C" fn(*mut GHook, *mut GHook) -> c_int>;
pub type GHookFinalizeFunc = Option<unsafe extern "C" fn(*mut GHookList, *mut GHook)>;
pub type GHookFindFunc = Option<unsafe extern "C" fn(*mut GHook, gpointer) -> gboolean>;
pub type GHookFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GHookMarshaller = Option<unsafe extern "C" fn(*mut GHook, gpointer)>;
pub type GIOFunc = Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition, gpointer) -> gboolean>;
pub type GLogFunc = Option<unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer)>;
pub type GLogWriterFunc = Option<unsafe extern "C" fn(GLogLevelFlags, *mut GLogField, size_t, gpointer) -> GLogWriterOutput>;
pub type GNodeForeachFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer)>;
pub type GNodeTraverseFunc = Option<unsafe extern "C" fn(*mut GNode, gpointer) -> gboolean>;
pub type GOptionArgFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer, *mut *mut GError) -> gboolean>;
pub type GOptionErrorFunc = Option<unsafe extern "C" fn(*mut GOptionContext, *mut GOptionGroup, gpointer, *mut *mut GError)>;
pub type GOptionParseFunc = Option<unsafe extern "C" fn(*mut GOptionContext, *mut GOptionGroup, gpointer, *mut *mut GError) -> gboolean>;
pub type GPollFunc = Option<unsafe extern "C" fn(*mut GPollFD, c_uint, c_int) -> c_int>;
pub type GPrintFunc = Option<unsafe extern "C" fn(*const c_char)>;
pub type GRegexEvalCallback = Option<unsafe extern "C" fn(*const GMatchInfo, *mut GString, gpointer) -> gboolean>;
pub type GScannerMsgFunc = Option<unsafe extern "C" fn(*mut GScanner, *mut c_char, gboolean)>;
pub type GSequenceIterCompareFunc = Option<unsafe extern "C" fn(*mut GSequenceIter, *mut GSequenceIter, gpointer) -> c_int>;
pub type GSourceDummyMarshal = Option<unsafe extern "C" fn()>;
pub type GSourceFunc = Option<unsafe extern "C" fn(gpointer) -> gboolean>;
pub type GSpawnChildSetupFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GTestDataFunc = Option<unsafe extern "C" fn(gconstpointer)>;
pub type GTestFixtureFunc = Option<unsafe extern "C" fn(gpointer, gconstpointer)>;
pub type GTestFunc = Option<unsafe extern "C" fn()>;
pub type GTestLogFatalFunc = Option<unsafe extern "C" fn(*const c_char, GLogLevelFlags, *const c_char, gpointer) -> gboolean>;
pub type GThreadFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GTranslateFunc = Option<unsafe extern "C" fn(*const c_char, gpointer) -> *const c_char>;
pub type GTraverseFunc = Option<unsafe extern "C" fn(gpointer, gpointer, gpointer) -> gboolean>;
pub type GUnixFDSourceFunc = Option<unsafe extern "C" fn(c_int, GIOCondition, gpointer) -> gboolean>;
pub type GVoidFunc = Option<unsafe extern "C" fn()>;

// Records
#[repr(C)]
pub struct GArray {
    pub data: *mut c_char,
    pub len: c_uint,
}

#[repr(C)]
pub struct GAsyncQueue(c_void);

#[repr(C)]
pub struct GBookmarkFile(c_void);

#[repr(C)]
pub struct GByteArray {
    pub data: *mut u8,
    pub len: c_uint,
}

#[repr(C)]
pub struct GBytes(c_void);

#[repr(C)]
pub struct GChecksum(c_void);

#[repr(C)]
pub struct GCond {
    p: gpointer,
    i: [c_uint; 2],
}

#[repr(C)]
pub struct GData(c_void);

#[repr(C)]
pub struct GDate {
    _truncated_record_marker: c_void,
    //julian_days: guint: 32,
    //julian: guint: 1,
    //dmy: guint: 1,
    //day: guint: 6,
    //month: guint: 4,
    //year: guint: 16,
}

#[repr(C)]
pub struct GDateTime(c_void);

#[repr(C)]
pub struct GDebugKey {
    pub key: *const c_char,
    pub value: c_uint,
}

#[repr(C)]
pub struct GDir(c_void);

#[repr(C)]
pub struct GError {
    pub domain: GQuark,
    pub code: c_int,
    pub message: *mut c_char,
}

#[repr(C)]
pub struct GHashTable(c_void);

#[repr(C)]
pub struct GHashTableIter {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gpointer,
    dummy4: c_int,
    dummy5: gboolean,
    dummy6: gpointer,
}

#[repr(C)]
pub struct GHmac(c_void);

#[repr(C)]
pub struct GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: c_uint,
    pub hook_id: c_ulong,
    pub flags: c_uint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}

#[repr(C)]
pub struct GHookList {
    pub seq_id: c_ulong,
    _truncated_record_marker: c_void,
    //hook_size: guint: 16,
    //is_setup: guint: 1,
    //hooks: GHook*,
    //dummy3: gpointer,
    //finalize_hook: GHookFinalizeFunc,
    //dummy: gpointer,
}

#[repr(C)]
pub struct GIConv(c_void);

#[repr(C)]
pub struct GIOChannel {
    ref_count: c_int,
    funcs: *mut GIOFuncs,
    encoding: *mut c_char,
    read_cd: GIConv,
    write_cd: GIConv,
    line_term: *mut c_char,
    line_term_len: c_uint,
    buf_size: size_t,
    read_buf: *mut GString,
    encoded_read_buf: *mut GString,
    write_buf: *mut GString,
    partial_write_buf: [c_char; 6],
    _truncated_record_marker: c_void,
    //use_buffer: guint: 1,
    //do_encode: guint: 1,
    //close_on_unref: guint: 1,
    //is_readable: guint: 1,
    //is_writeable: guint: 1,
    //is_seekable: guint: 1,
    //reserved1: gpointer,
    //reserved2: gpointer,
}

#[repr(C)]
pub struct GIOFuncs {
    pub io_read: Option<unsafe extern "C" fn(*mut GIOChannel, *const c_char, size_t, *mut size_t, *mut *mut GError) -> GIOStatus>,
    pub io_write: Option<unsafe extern "C" fn(*mut GIOChannel, *const c_char, size_t, *mut size_t, *mut *mut GError) -> GIOStatus>,
    pub io_seek: Option<unsafe extern "C" fn(*mut GIOChannel, i64, GSeekType, *mut *mut GError) -> GIOStatus>,
    pub io_close: Option<unsafe extern "C" fn(*mut GIOChannel, *mut *mut GError) -> GIOStatus>,
    pub io_create_watch: Option<unsafe extern "C" fn(*mut GIOChannel, GIOCondition) -> *mut GSource>,
    pub io_free: Option<unsafe extern "C" fn(*mut GIOChannel)>,
    pub io_set_flags: Option<unsafe extern "C" fn(*mut GIOChannel, GIOFlags, *mut *mut GError) -> GIOStatus>,
    pub io_get_flags: Option<unsafe extern "C" fn(*mut GIOChannel) -> GIOFlags>,
}

#[repr(C)]
pub struct GKeyFile(c_void);

#[repr(C)]
pub struct GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}

#[repr(C)]
pub struct GLogField {
    pub key: *const c_char,
    pub value: gconstpointer,
    pub length: ssize_t,
}

#[repr(C)]
pub struct GMainContext(c_void);

#[repr(C)]
pub struct GMainLoop(c_void);

#[repr(C)]
pub struct GMappedFile(c_void);

#[repr(C)]
pub struct GMarkupParseContext(c_void);

#[repr(C)]
pub struct GMarkupParser {
    pub start_element: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, *mut *const c_char, *mut *const c_char, gpointer, *mut *mut GError)>,
    pub end_element: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, gpointer, *mut *mut GError)>,
    pub text: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, size_t, gpointer, *mut *mut GError)>,
    pub passthrough: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *const c_char, size_t, gpointer, *mut *mut GError)>,
    pub error: Option<unsafe extern "C" fn(*mut GMarkupParseContext, *mut GError, gpointer)>,
}

#[repr(C)]
pub struct GMatchInfo(c_void);

#[repr(C)]
pub struct GMemVTable {
    pub malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
    pub free: Option<unsafe extern "C" fn(gpointer)>,
    pub calloc: Option<unsafe extern "C" fn(size_t, size_t) -> gpointer>,
    pub try_malloc: Option<unsafe extern "C" fn(size_t) -> gpointer>,
    pub try_realloc: Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>,
}

#[repr(C)]
pub struct GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}

#[repr(C)]
pub struct GOnce {
    pub status: Volatile<GOnceStatus>,
    pub retval: Volatile<gpointer>,
}

#[repr(C)]
pub struct GOptionContext(c_void);

#[repr(C)]
pub struct GOptionEntry {
    pub long_name: *const c_char,
    pub short_name: c_char,
    pub flags: c_int,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const c_char,
    pub arg_description: *const c_char,
}

#[repr(C)]
pub struct GOptionGroup(c_void);

#[repr(C)]
pub struct GPatternSpec(c_void);

#[repr(C)]
pub struct GPollFD {
    pub fd: c_int,
    pub events: c_ushort,
    pub revents: c_ushort,
}

#[repr(C)]
pub struct GPrivate {
    p: gpointer,
    notify: GDestroyNotify,
    future: [gpointer; 2],
}

#[repr(C)]
pub struct GPtrArray {
    pub pdata: *mut gpointer,
    pub len: c_uint,
}

#[repr(C)]
pub struct GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: c_uint,
}

#[repr(C)]
pub struct GRWLock {
    p: gpointer,
    i: [c_uint; 2],
}

#[repr(C)]
pub struct GRand(c_void);

#[repr(C)]
pub struct GRecMutex {
    p: gpointer,
    i: [c_uint; 2],
}

#[repr(C)]
pub struct GRegex(c_void);

#[repr(C)]
pub struct GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}

#[repr(C)]
pub struct GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: c_uint,
    pub parse_errors: c_uint,
    pub input_name: *const c_char,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    _truncated_record_marker: c_void,
    //union,
    //line: guint,
    //position: guint,
    //next_token: GTokenType,
    //union,
    //next_line: guint,
    //next_position: guint,
    //symbol_table: GHashTable*,
    //input_fd: gint,
    //text: const gchar*,
    //text_end: const gchar*,
    //buffer: gchar*,
    //scope_id: guint,
    //msg_handler: GScannerMsgFunc,
}

#[repr(C)]
pub struct GScannerConfig {
    pub cset_skip_characters: *mut c_char,
    pub cset_identifier_first: *mut c_char,
    pub cset_identifier_nth: *mut c_char,
    pub cpair_comment_single: *mut c_char,
    _truncated_record_marker: c_void,
    //case_sensitive: guint: 1,
    //skip_comment_multi: guint: 1,
    //skip_comment_single: guint: 1,
    //scan_comment_multi: guint: 1,
    //scan_identifier: guint: 1,
    //scan_identifier_1char: guint: 1,
    //scan_identifier_NULL: guint: 1,
    //scan_symbols: guint: 1,
    //scan_binary: guint: 1,
    //scan_octal: guint: 1,
    //scan_float: guint: 1,
    //scan_hex: guint: 1,
    //scan_hex_dollar: guint: 1,
    //scan_string_sq: guint: 1,
    //scan_string_dq: guint: 1,
    //numbers_2_int: guint: 1,
    //int_2_float: guint: 1,
    //identifier_2_string: guint: 1,
    //char_2_token: guint: 1,
    //symbol_2_token: guint: 1,
    //scope_0_fallback: guint: 1,
    //store_int64: guint: 1,
    //padding_dummy: guint,
}

#[repr(C)]
pub struct GSequence(c_void);

#[repr(C)]
pub struct GSequenceIter(c_void);

#[repr(C)]
pub struct GSource {
    callback_data: gpointer,
    callback_funcs: *mut GSourceCallbackFuncs,
    source_funcs: *const GSourceFuncs,
    ref_count: c_uint,
    context: *mut GMainContext,
    priority: c_int,
    flags: c_uint,
    source_id: c_uint,
    poll_fds: *mut GSList,
    prev: *mut GSource,
    next: *mut GSource,
    name: *mut c_char,
    priv_: *mut GSourcePrivate,
}

#[repr(C)]
pub struct GSourceCallbackFuncs {
    pub ref_: Option<unsafe extern "C" fn(gpointer)>,
    pub unref: Option<unsafe extern "C" fn(gpointer)>,
    pub get: Option<unsafe extern "C" fn(gpointer, *mut GSource, *mut GSourceFunc, *mut gpointer)>,
}

#[repr(C)]
pub struct GSourceFuncs {
    pub prepare: Option<unsafe extern "C" fn(*mut GSource, *mut c_int) -> gboolean>,
    pub check: Option<unsafe extern "C" fn(*mut GSource) -> gboolean>,
    pub dispatch: Option<unsafe extern "C" fn(*mut GSource, GSourceFunc, gpointer) -> gboolean>,
    pub finalize: Option<unsafe extern "C" fn(*mut GSource)>,
    closure_callback: GSourceFunc,
    closure_marshal: GSourceDummyMarshal,
}

#[repr(C)]
pub struct GSourcePrivate(c_void);

#[repr(C)]
pub struct GStatBuf(c_void);

#[repr(C)]
pub struct GString {
    pub str: *mut c_char,
    pub len: size_t,
    pub allocated_len: size_t,
}

#[repr(C)]
pub struct GStringChunk(c_void);

#[repr(C)]
pub struct GTestCase(c_void);

#[repr(C)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}

#[repr(C)]
pub struct GTestLogBuffer {
    data: *mut GString,
    msgs: *mut GSList,
}

#[repr(C)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: c_uint,
    pub strings: *mut *mut c_char,
    pub n_nums: c_uint,
    pub nums: *mut c_long,
}

#[repr(C)]
pub struct GTestSuite(c_void);

#[repr(C)]
pub struct GThread(c_void);

#[repr(C)]
pub struct GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}

#[repr(C)]
pub struct GTimeVal {
    pub tv_sec: c_long,
    pub tv_usec: c_long,
}

#[repr(C)]
pub struct GTimeZone(c_void);

#[repr(C)]
pub struct GTimer(c_void);

#[repr(C)]
pub struct GTrashStack {
    pub next: *mut GTrashStack,
}

#[repr(C)]
pub struct GTree(c_void);

#[repr(C)]
pub struct GVariant(c_void);

#[repr(C)]
pub struct GVariantBuilder {
    _truncated_record_marker: c_void,
    //union,
}

#[repr(C)]
pub struct GVariantDict {
    _truncated_record_marker: c_void,
    //union,
}

#[repr(C)]
pub struct GVariantIter {
    x: [size_t; 16],
}

#[repr(C)]
pub struct GVariantType(c_void);

extern "C" {

    //=========================================================================
    // GMutex
    //=========================================================================
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);

    //=========================================================================
    // GArray
    //=========================================================================
    pub fn g_array_get_type() -> GType;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut c_char;
    pub fn g_array_get_element_size(array: *mut GArray) -> c_uint;
    pub fn g_array_insert_vals(array: *mut GArray, index_: c_uint, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: c_uint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: c_uint) -> *mut GArray;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: c_uint) -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: c_uint, length: c_uint) -> *mut GArray;
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
    pub fn g_array_set_size(array: *mut GArray, length: c_uint) -> *mut GArray;
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: c_uint, reserved_size: c_uint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(array: *mut GArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_array_unref(array: *mut GArray);

    //=========================================================================
    // GAsyncQueue
    //=========================================================================
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> c_int;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    #[cfg(feature = "v2_46")]
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    #[cfg(feature = "v2_46")]
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    #[cfg(feature = "v2_46")]
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    #[cfg(feature = "v2_46")]
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;

    //=========================================================================
    // GBookmarkFile
    //=========================================================================
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *const c_char);
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char);
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_get_app_info(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *mut *mut c_char, count: *mut c_uint, stamp: *mut c_long, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_applications(bookmark: *mut GBookmarkFile, uri: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_groups(bookmark: *mut GBookmarkFile, uri: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_icon(bookmark: *mut GBookmarkFile, uri: *const c_char, href: *mut *mut c_char, mime_type: *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> c_int;
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> c_long;
    pub fn g_bookmark_file_has_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_has_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const c_char) -> gboolean;
    pub fn g_bookmark_file_load_from_data(bookmark: *mut GBookmarkFile, data: *const c_char, length: size_t, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(bookmark: *mut GBookmarkFile, file: *mut c_char, full_path: *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile, filename: *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_move_item(bookmark: *mut GBookmarkFile, old_uri: *const c_char, new_uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_application(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_group(bookmark: *mut GBookmarkFile, uri: *const c_char, group: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile, uri: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile, uri: *const c_char, added: c_long);
    pub fn g_bookmark_file_set_app_info(bookmark: *mut GBookmarkFile, uri: *const c_char, name: *const c_char, exec: *const c_char, count: c_int, stamp: c_long, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile, uri: *const c_char, description: *const c_char);
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile, uri: *const c_char, groups: *mut *const c_char, length: size_t);
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile, uri: *const c_char, href: *const c_char, mime_type: *const c_char);
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile, uri: *const c_char, is_private: gboolean);
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile, uri: *const c_char, mime_type: *const c_char);
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile, uri: *const c_char, modified: c_long);
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile, uri: *const c_char, title: *const c_char);
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile, uri: *const c_char, visited: c_long);
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile, length: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile, filename: *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;

    //=========================================================================
    // GByteArray
    //=========================================================================
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_byte_array_append(array: *mut GByteArray, data: *const u8, len: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut u8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut u8, len: size_t) -> *mut GByteArray;
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: *const u8, len: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: c_uint, length: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: c_uint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_byte_array_unref(array: *mut GByteArray);

    //=========================================================================
    // GBytes
    //=========================================================================
    pub fn g_bytes_get_type() -> GType;
    pub fn g_bytes_new(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: size_t) -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: size_t, free_func: GDestroyNotify, user_data: gpointer) -> *mut GBytes;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> c_int;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut size_t) -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> size_t;
    pub fn g_bytes_hash(bytes: gconstpointer) -> c_uint;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: size_t, length: size_t) -> *mut GBytes;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut size_t) -> gpointer;

    //=========================================================================
    // GChecksum
    //=========================================================================
    pub fn g_checksum_get_type() -> GType;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_get_digest(checksum: *mut GChecksum, buffer: *mut u8, digest_len: *mut size_t);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const c_char;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *mut u8, length: ssize_t);
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> ssize_t;

    //=========================================================================
    // GCond
    //=========================================================================
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: i64) -> gboolean;

    //=========================================================================
    // GDate
    //=========================================================================
    pub fn g_date_get_type() -> GType;
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
    pub fn g_date_new_julian(julian_day: u32) -> *mut GDate;
    pub fn g_date_add_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_add_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_add_years(date: *mut GDate, n_years: c_uint);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
    pub fn g_date_clear(date: *mut GDate, n_dates: c_uint);
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> c_int;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> c_int;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_day_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_julian(date: *const GDate) -> u32;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> c_uint;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: u32);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_parse(date: *mut GDate, str: *const c_char);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_time_t(date: *mut GDate, timet: c_long);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: c_uint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: c_uint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: c_uint);
    //pub fn g_date_to_struct_tm(date: *const GDate, tm: /*Unimplemented*/*mut tm);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> u8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_strftime(s: *mut c_char, slen: size_t, format: *const c_char, date: *const GDate) -> size_t;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
    pub fn g_date_valid_julian(julian_date: u32) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;

    //=========================================================================
    // GDateTime
    //=========================================================================
    pub fn g_date_time_get_type() -> GType;
    pub fn g_date_time_new(tz: *mut GTimeZone, year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_local(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_utc(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_full(datetime: *mut GDateTime, years: c_int, months: c_int, days: c_int, hours: c_int, minutes: c_int, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: c_double) -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: c_int) -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: c_int) -> *mut GDateTime;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const c_char) -> *mut c_char;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> c_double;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const c_char;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> c_int;
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: *mut c_int, month: *mut c_int, day: *mut c_int);
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> i64;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> c_int;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
    pub fn g_date_time_hash(datetime: gconstpointer) -> c_uint;

    //=========================================================================
    // GDir
    //=========================================================================
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_dir_read_name(dir: *mut GDir) -> *mut c_char;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_dir_make_tmp(tmpl: *mut c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_dir_open(path: *const c_char, flags: c_uint, error: *mut *mut GError) -> *mut GDir;

    //=========================================================================
    // GError
    //=========================================================================
    pub fn g_error_get_type() -> GType;
    pub fn g_error_new(domain: GQuark, code: c_int, format: *const c_char, ...) -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: c_int, message: *const c_char) -> *mut GError;
    //pub fn g_error_new_valist(domain: GQuark, code: c_int, format: *const c_char, args: /*Unimplemented*/va_list) -> *mut GError;
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: c_int) -> gboolean;

    //=========================================================================
    // GHashTable
    //=========================================================================
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc, user_data: gpointer) -> gpointer;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> c_uint;
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> c_uint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    #[cfg(feature = "v2_40")]
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable, length: *mut c_uint) -> *mut gpointer;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
    pub fn g_hash_table_lookup_extended(hash_table: *mut GHashTable, lookup_key: gconstpointer, orig_key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
    pub fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) -> *mut GHashTable;
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> c_uint;
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);

    //=========================================================================
    // GHashTableIter
    //=========================================================================
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter, key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);

    //=========================================================================
    // GHmac
    //=========================================================================
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut u8, digest_len: *mut size_t);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const c_char;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *mut u8, length: ssize_t);
    pub fn g_hmac_new(digest_type: GChecksumType, key: *mut u8, key_len: size_t) -> *mut GHmac;

    //=========================================================================
    // GHook
    //=========================================================================
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> c_int;
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: c_ulong) -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer) -> *mut GHook;
    pub fn g_hook_find_func_data(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer, data: gpointer) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: c_ulong) -> *mut GHook;
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook, func: GHookCompareFunc);
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);

    //=========================================================================
    // GHookList
    //=========================================================================
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: c_uint);
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_marshal(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer);
    pub fn g_hook_list_marshal_check(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer);

    //=========================================================================
    // GIConv
    //=========================================================================
    pub fn g_iconv_close(converter: GIConv) -> c_int;
    pub fn g_iconv_open(to_codeset: *const c_char, from_codeset: *const c_char) -> GIConv;

    //=========================================================================
    // GIOChannel
    //=========================================================================
    pub fn g_io_channel_get_type() -> GType;
    pub fn g_io_channel_new_file(filename: *mut c_char, mode: *const c_char, error: *mut *mut GError) -> *mut GIOChannel;
    pub fn g_io_channel_unix_new(fd: c_int) -> *mut GIOChannel;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> size_t;
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const c_char;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut c_int) -> *const c_char;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut c_char, count: size_t, bytes_read: *mut size_t) -> GIOError;
    pub fn g_io_channel_read_chars(channel: *mut GIOChannel, buf: *mut u8, count: size_t, bytes_read: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line(channel: *mut GIOChannel, str_return: *mut *mut c_char, length: *mut size_t, terminator_pos: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line_string(channel: *mut GIOChannel, buffer: *mut GString, terminator_pos: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_to_end(channel: *mut GIOChannel, str_return: *mut *mut u8, length: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel, thechar: *mut u32, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: i64, type_: GSeekType) -> GIOError;
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel, offset: i64, type_: GSeekType, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: size_t);
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel, encoding: *const c_char, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel, line_term: *const c_char, length: c_int);
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> c_int;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const c_char, count: size_t, bytes_written: *mut size_t) -> GIOError;
    pub fn g_io_channel_write_chars(channel: *mut GIOChannel, buf: *mut u8, count: ssize_t, bytes_written: *mut size_t, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel, thechar: u32, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_error_from_errno(en: c_int) -> GIOChannelError;
    pub fn g_io_channel_error_quark() -> GQuark;

    //=========================================================================
    // GKeyFile
    //=========================================================================
    pub fn g_key_file_get_type() -> GType;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_get_boolean(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_boolean_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut gboolean;
    pub fn g_key_file_get_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_double(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> c_double;
    pub fn g_key_file_get_double_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut c_double;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> i64;
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> c_int;
    pub fn g_key_file_get_integer_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut c_int;
    pub fn g_key_file_get_keys(key_file: *mut GKeyFile, group_name: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_locale_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_locale_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut c_char;
    pub fn g_key_file_get_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_get_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, length: *mut size_t, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> u64;
    pub fn g_key_file_get_value(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const c_char) -> gboolean;
    pub fn g_key_file_has_key(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_key_file_load_from_bytes(key_file: *mut GKeyFile, bytes: *mut GBytes, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data(key_file: *mut GKeyFile, data: *const c_char, length: size_t, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(key_file: *mut GKeyFile, file: *mut c_char, full_path: *mut *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_dirs(key_file: *mut GKeyFile, file: *mut c_char, search_dirs: *mut *mut c_char, full_path: *mut *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_file(key_file: *mut GKeyFile, file: *mut c_char, flags: GKeyFileFlags, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_remove_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile, group_name: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile, filename: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: gboolean);
    pub fn g_key_file_set_boolean_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: gboolean, length: size_t);
    pub fn g_key_file_set_comment(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, comment: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_double(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: c_double);
    pub fn g_key_file_set_double_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: c_double, length: size_t);
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: i64);
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: c_int);
    pub fn g_key_file_set_integer_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: c_int, length: size_t);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: c_char);
    pub fn g_key_file_set_locale_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, string: *const c_char);
    pub fn g_key_file_set_locale_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, locale: *const c_char, list: *mut c_char, length: size_t);
    pub fn g_key_file_set_string(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, string: *const c_char);
    pub fn g_key_file_set_string_list(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, list: *mut c_char, length: size_t);
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: u64);
    pub fn g_key_file_set_value(key_file: *mut GKeyFile, group_name: *const c_char, key: *const c_char, value: *const c_char);
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_error_quark() -> GQuark;

    //=========================================================================
    // GList
    //=========================================================================
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    #[cfg(feature = "v2_34")]
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> c_int;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: c_int) -> *mut GList;
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> c_uint;
    pub fn g_list_nth(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: c_uint) -> gpointer;
    pub fn g_list_nth_prev(list: *mut GList, n: c_uint) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> c_int;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
    pub fn g_list_sort_with_data(list: *mut GList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GList;

    //=========================================================================
    // GMainContext
    //=========================================================================
    pub fn g_main_context_get_type() -> GType;
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: c_int);
    pub fn g_main_context_check(context: *mut GMainContext, max_priority: c_int, fds: *mut GPollFD, n_fds: c_int) -> c_int;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_find_source_by_funcs_user_data(context: *mut GMainContext, funcs: *mut GSourceFuncs, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext, source_id: c_uint) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
    pub fn g_main_context_invoke_full(context: *mut GMainContext, priority: c_int, function: GSourceFunc, data: gpointer, notify: GDestroyNotify);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut c_int) -> gboolean;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_query(context: *mut GMainContext, max_priority: c_int, timeout_: *mut c_int, fds: *mut GPollFD, n_fds: c_int) -> c_int;
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond, mutex: *mut GMutex) -> gboolean;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;

    //=========================================================================
    // GMainLoop
    //=========================================================================
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);

    //=========================================================================
    // GMappedFile
    //=========================================================================
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_mapped_file_new(filename: *mut c_char, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(fd: c_int, writable: gboolean, error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    #[cfg(feature = "v2_34")]
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut c_char;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> size_t;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);

    //=========================================================================
    // GMarkupParseContext
    //=========================================================================
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_markup_parse_context_new(parser: *const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext, error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const c_char;
    pub fn g_markup_parse_context_get_element_stack(context: *mut GMarkupParseContext) -> *const GSList;
    pub fn g_markup_parse_context_get_position(context: *mut GMarkupParseContext, line_number: *mut c_int, char_number: *mut c_int);
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_parse(context: *mut GMarkupParseContext, text: *const c_char, text_len: ssize_t, error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext, parser: *const GMarkupParser, user_data: gpointer);
    #[cfg(feature = "v2_36")]
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext) -> *mut GMarkupParseContext;
    #[cfg(feature = "v2_36")]
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);

    //=========================================================================
    // GMatchInfo
    //=========================================================================
    pub fn g_match_info_get_type() -> GType;
    pub fn g_match_info_expand_references(match_info: *const GMatchInfo, string_to_expand: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: c_int) -> *mut c_char;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut c_char;
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo, name: *const c_char) -> *mut c_char;
    pub fn g_match_info_fetch_named_pos(match_info: *const GMatchInfo, name: *const c_char, start_pos: *mut c_int, end_pos: *mut c_int) -> gboolean;
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo, match_num: c_int, start_pos: *mut c_int, end_pos: *mut c_int) -> gboolean;
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> c_int;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const c_char;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);

    //=========================================================================
    // GNode
    //=========================================================================
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> c_int;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> c_int;
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer);
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
    pub fn g_node_depth(node: *mut GNode) -> c_uint;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_find(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: c_int, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_max_height(root: *mut GNode) -> c_uint;
    pub fn g_node_n_children(node: *mut GNode) -> c_uint;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> c_uint;
    pub fn g_node_nth_child(node: *mut GNode, n: c_uint) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_traverse(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: c_int, func: GNodeTraverseFunc, data: gpointer);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_new(data: gpointer) -> *mut GNode;

    //=========================================================================
    // GOnce
    //=========================================================================
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
    pub fn g_once_init_enter(location: *mut c_void) -> gboolean;
    pub fn g_once_init_leave(location: *mut c_void, result: size_t);

    //=========================================================================
    // GOptionContext
    //=========================================================================
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext, entries: *const GOptionEntry, translation_domain: *const c_char);
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_get_help(context: *mut GOptionContext, main_help: gboolean, group: *mut GOptionGroup) -> *mut c_char;
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
    #[cfg(feature = "v2_44")]
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const c_char;
    pub fn g_option_context_parse(context: *mut GOptionContext, argc: *mut c_int, argv: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_option_context_parse_strv(context: *mut GOptionContext, arguments: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_set_description(context: *mut GOptionContext, description: *const c_char);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
    pub fn g_option_context_set_ignore_unknown_options(context: *mut GOptionContext, ignore_unknown: gboolean);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    #[cfg(feature = "v2_44")]
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const c_char);
    pub fn g_option_context_set_translate_func(context: *mut GOptionContext, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify);
    pub fn g_option_context_set_translation_domain(context: *mut GOptionContext, domain: *const c_char);
    pub fn g_option_context_new(parameter_string: *const c_char) -> *mut GOptionContext;

    //=========================================================================
    // GOptionGroup
    //=========================================================================
    pub fn g_option_group_get_type() -> GType;
    pub fn g_option_group_new(name: *const c_char, description: *const c_char, help_description: *const c_char, user_data: gpointer, destroy: GDestroyNotify) -> *mut GOptionGroup;
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    #[cfg(feature = "v2_44")]
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc);
    pub fn g_option_group_set_translate_func(group: *mut GOptionGroup, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify);
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const c_char);
    #[cfg(feature = "v2_44")]
    pub fn g_option_group_unref(group: *mut GOptionGroup);

    //=========================================================================
    // GPatternSpec
    //=========================================================================
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_new(pattern: *const c_char) -> *mut GPatternSpec;

    //=========================================================================
    // GPollFD
    //=========================================================================
    pub fn g_pollfd_get_type() -> GType;

    //=========================================================================
    // GPrivate
    //=========================================================================
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);

    //=========================================================================
    // GPtrArray
    //=========================================================================
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
    #[cfg(feature = "v2_40")]
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: c_int, data: gpointer);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(reserved_size: c_uint, element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: c_uint) -> gpointer;
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: c_uint, length: c_uint) -> *mut GPtrArray;
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: c_int);
    pub fn g_ptr_array_sized_new(reserved_size: c_uint) -> *mut GPtrArray;
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_ptr_array_unref(array: *mut GPtrArray);

    //=========================================================================
    // GQueue
    //=========================================================================
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_get_length(queue: *mut GQueue) -> c_uint;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> c_int;
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> c_int;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: c_uint) -> gpointer;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: c_uint) -> *mut GList;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: c_int);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: c_int, link_: *mut GList);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> c_uint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_new() -> *mut GQueue;

    //=========================================================================
    // GRWLock
    //=========================================================================
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);

    //=========================================================================
    // GRand
    //=========================================================================
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_double(rand_: *mut GRand) -> c_double;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: c_double, end: c_double) -> c_double;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_int(rand_: *mut GRand) -> u32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: i32, end: i32) -> i32;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: u32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const u32, seed_length: c_uint);
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_new_with_seed(seed: u32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const u32, seed_length: c_uint) -> *mut GRand;

    //=========================================================================
    // GRecMutex
    //=========================================================================
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);

    //=========================================================================
    // GRegex
    //=========================================================================
    pub fn g_regex_get_type() -> GType;
    pub fn g_regex_new(pattern: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut GRegex;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
    #[cfg(feature = "v2_34")]
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> c_int;
    #[cfg(feature = "v2_38")]
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> c_int;
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const c_char;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const c_char) -> c_int;
    pub fn g_regex_match(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_match_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, match_info: *mut *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_replace(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, replacement: *const c_char, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_replace_eval(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_replace_literal(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, replacement: *const c_char, match_options: GRegexMatchFlags, error: *mut *mut GError) -> *mut c_char;
    pub fn g_regex_split(regex: *const GRegex, string: *const c_char, match_options: GRegexMatchFlags) -> *mut *mut c_char;
    pub fn g_regex_split_full(regex: *const GRegex, string: *mut c_char, string_len: ssize_t, start_position: c_int, match_options: GRegexMatchFlags, max_tokens: c_int, error: *mut *mut GError) -> *mut *mut c_char;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_check_replacement(replacement: *const c_char, has_references: *mut gboolean, error: *mut *mut GError) -> gboolean;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_escape_nul(string: *const c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_escape_string(string: *mut c_char, length: c_int) -> *mut c_char;
    pub fn g_regex_match_simple(pattern: *const c_char, string: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> gboolean;
    pub fn g_regex_split_simple(pattern: *const c_char, string: *const c_char, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> *mut *mut c_char;

    //=========================================================================
    // GSList
    //=========================================================================
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    #[cfg(feature = "v2_34")]
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> c_int;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: c_int) -> *mut GSList;
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> c_uint;
    pub fn g_slist_nth(list: *mut GSList, n: c_uint) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: c_uint) -> gpointer;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> c_int;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_sort_with_data(list: *mut GSList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;

    //=========================================================================
    // GScanner
    //=========================================================================
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> c_uint;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: c_int);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const c_char, text_len: c_uint);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const c_char) -> gpointer;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char, value: gpointer);
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner, scope_id: c_uint, func: GHFunc, user_data: gpointer);
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char) -> gpointer;
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner, scope_id: c_uint, symbol: *const c_char);
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: c_uint) -> c_uint;
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_unexp_token(scanner: *mut GScanner, expected_token: GTokenType, identifier_spec: *const c_char, symbol_spec: *const c_char, symbol_name: *const c_char, message: *const c_char, is_error: c_int);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const c_char, ...);
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;

    //=========================================================================
    // GSequence
    //=========================================================================
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_get_length(seq: *mut GSequence) -> c_int;
    pub fn g_sequence_insert_sorted(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    #[cfg(feature = "v2_48")]
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_iter(seq: *mut GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter, end: *mut GSequenceIter, func: GFunc, user_data: gpointer);
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_move_range(dest: *mut GSequenceIter, begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter, end: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);

    //=========================================================================
    // GSequenceIter
    //=========================================================================
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> c_int;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: c_int) -> *mut GSequenceIter;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;

    //=========================================================================
    // GSource
    //=========================================================================
    pub fn g_source_get_type() -> GType;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: c_uint) -> *mut GSource;
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    #[cfg(feature = "v2_36")]
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: c_int, events: GIOCondition) -> gpointer;
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> c_uint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
    pub fn g_source_get_id(source: *mut GSource) -> c_uint;
    pub fn g_source_get_name(source: *mut GSource) -> *const c_char;
    pub fn g_source_get_priority(source: *mut GSource) -> c_int;
    pub fn g_source_get_ready_time(source: *mut GSource) -> i64;
    pub fn g_source_get_time(source: *mut GSource) -> i64;
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
    #[cfg(feature = "v2_36")]
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    #[cfg(feature = "v2_36")]
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify);
    pub fn g_source_set_callback_indirect(source: *mut GSource, callback_data: gpointer, callback_funcs: *mut GSourceCallbackFuncs);
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_set_name(source: *mut GSource, name: *const c_char);
    pub fn g_source_set_priority(source: *mut GSource, priority: c_int);
    #[cfg(feature = "v2_36")]
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: i64);
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_remove(tag: c_uint) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs, user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_set_name_by_id(tag: c_uint, name: *const c_char);

    //=========================================================================
    // GString
    //=========================================================================
    pub fn g_gstring_get_type() -> GType;
    pub fn g_string_append(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_append_len(string: *mut GString, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_append_printf(string: *mut GString, format: *const c_char, ...);
    pub fn g_string_append_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_append_uri_escaped(string: *mut GString, unescaped: *const c_char, reserved_chars_allowed: *const c_char, allow_utf8: gboolean) -> *mut GString;
    //pub fn g_string_append_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_assign(string: *mut GString, rval: *const c_char) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_erase(string: *mut GString, pos: ssize_t, len: ssize_t) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_hash(str: *const GString) -> c_uint;
    pub fn g_string_insert(string: *mut GString, pos: ssize_t, val: *const c_char) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: ssize_t, c: c_char) -> *mut GString;
    pub fn g_string_insert_len(string: *mut GString, pos: ssize_t, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: ssize_t, wc: u32) -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: size_t, val: *const c_char) -> *mut GString;
    pub fn g_string_overwrite_len(string: *mut GString, pos: size_t, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const c_char) -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: c_char) -> *mut GString;
    pub fn g_string_prepend_len(string: *mut GString, val: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: u32) -> *mut GString;
    pub fn g_string_printf(string: *mut GString, format: *const c_char, ...);
    pub fn g_string_set_size(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: size_t) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    //pub fn g_string_vprintf(string: *mut GString, format: *const c_char, args: /*Unimplemented*/va_list);

    //=========================================================================
    // GStringChunk
    //=========================================================================
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const c_char) -> *mut c_char;
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk, string: *const c_char) -> *mut c_char;
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk, string: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_string_chunk_new(size: size_t) -> *mut GStringChunk;

    //=========================================================================
    // GTestLogBuffer
    //=========================================================================
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer, n_bytes: c_uint, bytes: *const u8);
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;

    //=========================================================================
    // GTestLogMsg
    //=========================================================================
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);

    //=========================================================================
    // GTestSuite
    //=========================================================================
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);

    //=========================================================================
    // GThread
    //=========================================================================
    pub fn g_thread_get_type() -> GType;
    pub fn g_thread_new(name: *const c_char, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_try_new(name: *const c_char, func: GThreadFunc, data: gpointer, error: *mut *mut GError) -> *mut GThread;
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_yield();

    //=========================================================================
    // GThreadPool
    //=========================================================================
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> c_int;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> c_uint;
    #[cfg(feature = "v2_46")]
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer, error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool, max_threads: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> c_uint;
    pub fn g_thread_pool_get_max_idle_time() -> c_uint;
    pub fn g_thread_pool_get_max_unused_threads() -> c_int;
    pub fn g_thread_pool_get_num_unused_threads() -> c_uint;
    pub fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: c_int, exclusive: gboolean, error: *mut *mut GError) -> *mut GThreadPool;
    pub fn g_thread_pool_set_max_idle_time(interval: c_uint);
    pub fn g_thread_pool_set_max_unused_threads(max_threads: c_int);
    pub fn g_thread_pool_stop_unused_threads();

    //=========================================================================
    // GTimeVal
    //=========================================================================
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: c_long);
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut c_char;
    pub fn g_time_val_from_iso8601(iso_date: *const c_char, time_: *mut GTimeVal) -> gboolean;

    //=========================================================================
    // GTimeZone
    //=========================================================================
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_time_zone_new(identifier: *const c_char) -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, type_: GTimeType, time_: *mut i64) -> c_int;
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: i64) -> c_int;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: c_int) -> *const c_char;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: c_int) -> i32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: c_int) -> gboolean;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);

    //=========================================================================
    // GTimer
    //=========================================================================
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut c_ulong) -> c_double;
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_new() -> *mut GTimer;

    //=========================================================================
    // GTrashStack
    //=========================================================================
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> c_uint;
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);

    //=========================================================================
    // GTree
    //=========================================================================
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
    pub fn g_tree_height(tree: *mut GTree) -> c_int;
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer, orig_key: *mut gpointer, value: *mut gpointer) -> gboolean;
    pub fn g_tree_nnodes(tree: *mut GTree) -> c_int;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc, user_data: gconstpointer) -> gpointer;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer);
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) -> *mut GTree;
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) -> *mut GTree;

    //=========================================================================
    // GVariant
    //=========================================================================
    pub fn g_variant_new(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_array(child_type: *const GVariantType, children: *mut *mut GVariant, n_children: size_t) -> *mut GVariant;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: c_uchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *mut u8) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_double(value: c_double) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(element_type: *const GVariantType, elements: gconstpointer, n_elements: size_t, element_size: size_t) -> *mut GVariant;
    #[cfg(feature = "v2_36")]
    pub fn g_variant_new_from_bytes(type_: *const GVariantType, bytes: *mut GBytes, trusted: gboolean) -> *mut GVariant;
    pub fn g_variant_new_from_data(type_: *const GVariantType, data: gconstpointer, size: size_t, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) -> *mut GVariant;
    pub fn g_variant_new_handle(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int16(value: i16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: i64) -> *mut GVariant;
    pub fn g_variant_new_maybe(child_type: *const GVariantType, child: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const c_char, ...) -> *mut GVariant;
    //pub fn g_variant_new_parsed_va(format: *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    #[cfg(feature = "v2_38")]
    pub fn g_variant_new_printf(format_string: *const c_char, ...) -> *mut GVariant;
    pub fn g_variant_new_signature(signature: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const c_char) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *mut *mut c_char, length: ssize_t) -> *mut GVariant;
    #[cfg(feature = "v2_38")]
    pub fn g_variant_new_take_string(string: *mut c_char) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *mut *mut GVariant, n_children: size_t) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: u16) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: u32) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: u64) -> *mut GVariant;
    //pub fn g_variant_new_va(format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list) -> *mut GVariant;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    #[cfg(feature = "v2_34")]
    pub fn g_variant_check_format_string(value: *mut GVariant, format_string: *const c_char, copy_only: gboolean) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> c_int;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut size_t) -> *mut u8;
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut size_t) -> *mut c_char;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
    pub fn g_variant_get(value: *mut GVariant, format_string: *const c_char, ...);
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> c_uchar;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *mut u8;
    pub fn g_variant_get_bytestring_array(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_child(value: *mut GVariant, index_: size_t, format_string: *const c_char, ...);
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: size_t) -> *mut GVariant;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_get_double(value: *mut GVariant) -> c_double;
    pub fn g_variant_get_fixed_array(value: *mut GVariant, n_elements: *mut size_t, element_size: size_t) -> gconstpointer;
    pub fn g_variant_get_handle(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int16(value: *mut GVariant) -> i16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> i64;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_size(value: *mut GVariant) -> size_t;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut size_t) -> *const c_char;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut size_t) -> *mut *mut c_char;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const c_char;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> u16;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> u32;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> u64;
    //pub fn g_variant_get_va(value: *mut GVariant, format_string: *const c_char, endptr: *mut *const c_char, app: /*Unimplemented*/*mut va_list);
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_hash(value: gconstpointer) -> c_uint;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const c_char, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_lookup_value(dictionary: *mut GVariant, key: *const c_char, expected_type: *const GVariantType) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> size_t;
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut c_char;
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString, type_annotate: gboolean) -> *mut GString;
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_is_object_path(string: *const c_char) -> gboolean;
    pub fn g_variant_is_signature(string: *const c_char) -> gboolean;
    pub fn g_variant_parse(type_: *const GVariantType, text: *const c_char, limit: *const c_char, endptr: *mut *const c_char, error: *mut *mut GError) -> *mut GVariant;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_parse_error_print_context(error: *mut GError, source_str: *const c_char) -> *mut c_char;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_parser_get_error_quark() -> GQuark;

    //=========================================================================
    // GVariantBuilder
    //=========================================================================
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const c_char, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const c_char, ...);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);

    //=========================================================================
    // GVariantDict
    //=========================================================================
    pub fn g_variant_dict_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const c_char, format_string: *const c_char, ...);
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict, key: *const c_char, value: *mut GVariant);
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const c_char, format_string: *const c_char, ...) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict, key: *const c_char, expected_type: *const GVariantType) -> *mut GVariant;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const c_char) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);

    //=========================================================================
    // GVariantIter
    //=========================================================================
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> size_t;
    pub fn g_variant_iter_loop(iter: *mut GVariantIter, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> size_t;
    pub fn g_variant_iter_next(iter: *mut GVariantIter, format_string: *const c_char, ...) -> gboolean;
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;

    //=========================================================================
    // GVariantType
    //=========================================================================
    pub fn g_variant_type_get_gtype() -> GType;
    pub fn g_variant_type_new(type_string: *const c_char) -> *mut GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType, value: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(items: *mut *mut GVariantType, length: c_int) -> *mut GVariantType;
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut c_char;
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_free(type_: *mut GVariantType);
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_hash(type_: gconstpointer) -> c_uint;
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_subtype_of(type_: *const GVariantType, supertype: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> size_t;
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const c_char;
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_checked_(arg0: *const c_char) -> *const GVariantType;
    pub fn g_variant_type_string_is_valid(type_string: *const c_char) -> gboolean;
    pub fn g_variant_type_string_scan(string: *const c_char, limit: *const c_char, endptr: *mut *const c_char) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_access(filename: *mut c_char, mode: c_int) -> c_int;
    pub fn g_ascii_digit_value(c: c_char) -> c_int;
    pub fn g_ascii_dtostr(buffer: *mut c_char, buf_len: c_int, d: c_double) -> *mut c_char;
    pub fn g_ascii_formatd(buffer: *mut c_char, buf_len: c_int, format: *const c_char, d: c_double) -> *mut c_char;
    pub fn g_ascii_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_ascii_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_ascii_strncasecmp(s1: *const c_char, s2: *const c_char, n: size_t) -> c_int;
    pub fn g_ascii_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_ascii_strtoll(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> i64;
    pub fn g_ascii_strtoull(nptr: *const c_char, endptr: *mut *mut c_char, base: c_uint) -> u64;
    pub fn g_ascii_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_ascii_tolower(c: c_char) -> c_char;
    pub fn g_ascii_toupper(c: c_char) -> c_char;
    pub fn g_ascii_xdigit_value(c: c_char) -> c_int;
    pub fn g_assert_warning(log_domain: *const c_char, file: *const c_char, line: c_int, pretty_function: *const c_char, expression: *const c_char);
    pub fn g_assertion_message(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, message: *const c_char);
    //pub fn g_assertion_message_cmpnum(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, arg1: /*Unimplemented*/long double, cmp: *const c_char, arg2: /*Unimplemented*/long double, numtype: c_char);
    pub fn g_assertion_message_cmpstr(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, arg1: *const c_char, cmp: *const c_char, arg2: *const c_char);
    pub fn g_assertion_message_error(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char, error: *const GError, error_domain: GQuark, error_code: c_int);
    pub fn g_assertion_message_expr(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, expr: *const c_char);
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_atomic_int_add(atomic: *mut Volatile<c_int>, val: c_int) -> c_int;
    pub fn g_atomic_int_and(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_int_compare_and_exchange(atomic: *mut Volatile<c_int>, oldval: c_int, newval: c_int) -> gboolean;
    pub fn g_atomic_int_dec_and_test(atomic: *mut Volatile<c_int>) -> gboolean;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut Volatile<c_int>, val: c_int) -> c_int;
    pub fn g_atomic_int_get(atomic: *const c_int) -> c_int;
    pub fn g_atomic_int_inc(atomic: *mut Volatile<c_int>);
    pub fn g_atomic_int_or(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_int_set(atomic: *mut Volatile<c_int>, newval: c_int);
    pub fn g_atomic_int_xor(atomic: *mut Volatile<c_uint>, val: c_uint) -> c_uint;
    pub fn g_atomic_pointer_add(atomic: *mut c_void, val: ssize_t) -> ssize_t;
    pub fn g_atomic_pointer_and(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_atomic_pointer_compare_and_exchange(atomic: *mut c_void, oldval: gpointer, newval: gpointer) -> gboolean;
    pub fn g_atomic_pointer_get(atomic: *mut c_void) -> gpointer;
    pub fn g_atomic_pointer_or(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_atomic_pointer_set(atomic: *mut c_void, newval: gpointer);
    pub fn g_atomic_pointer_xor(atomic: *mut c_void, val: size_t) -> size_t;
    pub fn g_base64_decode(text: *const c_char, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_inplace(text: *mut u8, out_len: *mut size_t) -> *mut u8;
    pub fn g_base64_decode_step(in_: *mut u8, len: size_t, out: *mut u8, state: *mut c_int, save: *mut c_uint) -> size_t;
    pub fn g_base64_encode(data: *mut u8, len: size_t) -> *mut c_char;
    pub fn g_base64_encode_close(break_lines: gboolean, out: *mut u8, state: *mut c_int, save: *mut c_int) -> size_t;
    pub fn g_base64_encode_step(in_: *mut u8, len: size_t, break_lines: gboolean, out: *mut u8, state: *mut c_int, save: *mut c_int) -> size_t;
    pub fn g_basename(file_name: *mut c_char) -> *mut c_char;
    pub fn g_bit_lock(address: *mut Volatile<c_int>, lock_bit: c_int);
    pub fn g_bit_nth_lsf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_nth_msf(mask: c_ulong, nth_bit: c_int) -> c_int;
    pub fn g_bit_storage(number: c_ulong) -> c_uint;
    pub fn g_bit_trylock(address: *mut Volatile<c_int>, lock_bit: c_int) -> gboolean;
    pub fn g_bit_unlock(address: *mut Volatile<c_int>, lock_bit: c_int);
    pub fn g_build_filename(first_element: *mut c_char, ...) -> *mut c_char;
    pub fn g_build_filenamev(args: *mut *mut c_char) -> *mut c_char;
    pub fn g_build_path(separator: *mut c_char, first_element: *mut c_char, ...) -> *mut c_char;
    pub fn g_build_pathv(separator: *const c_char, args: *mut *mut c_char) -> *mut c_char;
    pub fn g_chdir(path: *mut c_char) -> c_int;
    pub fn glib_check_version(required_major: c_uint, required_minor: c_uint, required_micro: c_uint) -> *const c_char;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> c_uint;
    pub fn g_child_watch_add_full(priority: c_int, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_clear_error(error: *mut *mut GError);
    #[cfg(feature = "v2_34")]
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    #[cfg(feature = "v2_36")]
    pub fn g_close(fd: c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: *mut GBytes) -> *mut c_char;
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: *mut u8, length: size_t) -> *mut c_char;
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: *const c_char, length: ssize_t) -> *mut c_char;
    #[cfg(feature = "v2_50")]
    pub fn g_compute_hmac_for_bytes(digest_type: GChecksumType, key: *mut GBytes, data: *mut GBytes) -> *mut c_char;
    pub fn g_compute_hmac_for_data(digest_type: GChecksumType, key: *mut u8, key_len: size_t, data: *mut u8, length: size_t) -> *mut c_char;
    pub fn g_compute_hmac_for_string(digest_type: GChecksumType, key: *mut u8, key_len: size_t, str: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn g_convert(str: *const c_char, len: ssize_t, to_codeset: *const c_char, from_codeset: *const c_char, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_convert_with_fallback(str: *const c_char, len: ssize_t, to_codeset: *const c_char, from_codeset: *const c_char, fallback: *const c_char, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_convert_with_iconv(str: *const c_char, len: ssize_t, converter: GIConv, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_foreach(datalist: *mut *mut GData, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const c_char) -> gpointer;
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> c_uint;
    #[cfg(feature = "v2_34")]
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) -> gpointer;
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    #[cfg(feature = "v2_34")]
    pub fn g_datalist_id_replace_data(datalist: *mut *mut GData, key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: *mut GDestroyNotify) -> gboolean;
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: c_uint);
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
    pub fn g_dcgettext(domain: *const c_char, msgid: *const c_char, category: c_int) -> *const c_char;
    pub fn g_dgettext(domain: *const c_char, msgid: *const c_char) -> *const c_char;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_direct_hash(v: gconstpointer) -> c_uint;
    pub fn g_dngettext(domain: *const c_char, msgid: *const c_char, msgid_plural: *const c_char, n: c_ulong) -> *const c_char;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> c_uint;
    pub fn g_dpgettext(domain: *const c_char, msgctxtid: *const c_char, msgidoffset: size_t) -> *const c_char;
    pub fn g_dpgettext2(domain: *const c_char, context: *const c_char, msgid: *const c_char) -> *const c_char;
    pub fn g_environ_getenv(envp: *mut *mut c_char, variable: *const c_char) -> *const c_char;
    pub fn g_environ_setenv(envp: *mut *mut c_char, variable: *const c_char, value: *const c_char, overwrite: gboolean) -> *mut *mut c_char;
    pub fn g_environ_unsetenv(envp: *mut *mut c_char, variable: *const c_char) -> *mut *mut c_char;
    pub fn g_file_error_from_errno(err_no: c_int) -> GFileError;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_get_contents(filename: *mut c_char, contents: *mut *mut u8, length: *mut size_t, error: *mut *mut GError) -> gboolean;
    pub fn g_file_open_tmp(tmpl: *mut c_char, name_used: *mut *mut c_char, error: *mut *mut GError) -> c_int;
    pub fn g_file_read_link(filename: *mut c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_file_set_contents(filename: *mut c_char, contents: *mut u8, length: ssize_t, error: *mut *mut GError) -> gboolean;
    pub fn g_file_test(filename: *mut c_char, test: GFileTest) -> gboolean;
    pub fn g_filename_display_basename(filename: *mut c_char) -> *mut c_char;
    pub fn g_filename_display_name(filename: *mut c_char) -> *mut c_char;
    pub fn g_filename_from_uri(uri: *const c_char, hostname: *mut *mut c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_filename_from_utf8(utf8string: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut u8;
    pub fn g_filename_to_uri(filename: *mut c_char, hostname: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_filename_to_utf8(opsysstring: *mut c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_find_program_in_path(program: *mut c_char) -> *mut c_char;
    pub fn g_format_size(size: u64) -> *mut c_char;
    pub fn g_format_size_for_display(size: i64) -> *mut c_char;
    pub fn g_format_size_full(size: u64, flags: GFormatSizeFlags) -> *mut c_char;
    pub fn g_fprintf(file: *mut FILE, format: *mut c_char, ...) -> c_int;
    pub fn g_free(mem: gpointer);
    pub fn g_get_application_name() -> *const c_char;
    pub fn g_get_charset(charset: *mut *const c_char) -> gboolean;
    pub fn g_get_codeset() -> *mut c_char;
    pub fn g_get_current_dir() -> *mut c_char;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_environ() -> *mut *mut c_char;
    pub fn g_get_filename_charsets(charsets: *mut *mut *const c_char) -> gboolean;
    pub fn g_get_home_dir() -> *mut c_char;
    pub fn g_get_host_name() -> *const c_char;
    pub fn g_get_language_names() -> *mut *mut c_char;
    pub fn g_get_locale_variants(locale: *const c_char) -> *mut *mut c_char;
    pub fn g_get_monotonic_time() -> i64;
    #[cfg(feature = "v2_36")]
    pub fn g_get_num_processors() -> c_uint;
    pub fn g_get_prgname() -> *const c_char;
    pub fn g_get_real_name() -> *mut c_char;
    pub fn g_get_real_time() -> i64;
    pub fn g_get_system_config_dirs() -> *mut *mut c_char;
    pub fn g_get_system_data_dirs() -> *mut *mut c_char;
    pub fn g_get_tmp_dir() -> *mut c_char;
    pub fn g_get_user_cache_dir() -> *mut c_char;
    pub fn g_get_user_config_dir() -> *mut c_char;
    pub fn g_get_user_data_dir() -> *mut c_char;
    pub fn g_get_user_name() -> *mut c_char;
    pub fn g_get_user_runtime_dir() -> *mut c_char;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *mut c_char;
    pub fn g_getenv(variable: *const c_char) -> *const c_char;
    pub fn g_hostname_is_ascii_encoded(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_is_non_ascii(hostname: *const c_char) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const c_char) -> *mut c_char;
    pub fn g_hostname_to_unicode(hostname: *const c_char) -> *mut c_char;
    pub fn g_iconv(converter: GIConv, inbuf: *mut *mut c_char, inbytes_left: *mut size_t, outbuf: *mut *mut c_char, outbytes_left: *mut size_t) -> size_t;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_idle_add_full(priority: c_int, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> c_uint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> c_uint;
    pub fn g_intern_static_string(string: *const c_char) -> *const c_char;
    pub fn g_intern_string(string: *const c_char) -> *const c_char;
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) -> c_uint;
    pub fn g_io_add_watch_full(channel: *mut GIOChannel, priority: c_int, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
    pub fn g_listenv() -> *mut *mut c_char;
    pub fn g_locale_from_utf8(utf8string: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_locale_to_utf8(opsysstring: *const c_char, len: ssize_t, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut GError) -> *mut c_char;
    pub fn g_log(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, ...);
    pub fn g_log_default_handler(log_domain: *const c_char, log_level: GLogLevelFlags, message: *const c_char, unused_data: gpointer);
    pub fn g_log_remove_handler(log_domain: *const c_char, handler_id: c_uint);
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
    pub fn g_log_set_fatal_mask(log_domain: *const c_char, fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_handler(log_domain: *const c_char, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) -> c_uint;
    #[cfg(feature = "v2_46")]
    pub fn g_log_set_handler_full(log_domain: *const c_char, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) -> c_uint;
    #[cfg(feature = "v2_50")]
    pub fn g_log_set_writer_func(func: GLogWriterFunc, user_data: gpointer, user_data_free: GDestroyNotify);
    #[cfg(feature = "v2_50")]
    pub fn g_log_structured(log_domain: *const c_char, log_level: GLogLevelFlags, ...);
    #[cfg(feature = "v2_50")]
    pub fn g_log_structured_array(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t);
    #[cfg(feature = "v2_50")]
    pub fn g_log_variant(log_domain: *const c_char, log_level: GLogLevelFlags, fields: *mut GVariant);
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_default(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_format_fields(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, use_color: gboolean) -> *mut c_char;
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_is_journald(output_fd: c_int) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_journald(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_standard_streams(log_level: GLogLevelFlags, fields: *mut GLogField, n_fields: size_t, user_data: gpointer) -> GLogWriterOutput;
    #[cfg(feature = "v2_50")]
    pub fn g_log_writer_supports_color(output_fd: c_int) -> gboolean;
    //pub fn g_logv(log_domain: *const c_char, log_level: GLogLevelFlags, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_depth() -> c_int;
    pub fn g_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_markup_collect_attributes(element_name: *const c_char, attribute_names: *mut *const c_char, attribute_values: *mut *const c_char, error: *mut *mut GError, first_type: GMarkupCollectType, first_attr: *const c_char, ...) -> gboolean;
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_escape_text(text: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn g_markup_printf_escaped(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_markup_vprintf_escaped(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_memdup(mem: gconstpointer, byte_size: c_uint) -> gpointer;
    pub fn g_mkdir_with_parents(pathname: *mut c_char, mode: c_int) -> c_int;
    pub fn g_mkdtemp(tmpl: *mut c_char) -> *mut c_char;
    pub fn g_mkdtemp_full(tmpl: *mut c_char, mode: c_int) -> *mut c_char;
    pub fn g_mkstemp(tmpl: *mut c_char) -> c_int;
    pub fn g_mkstemp_full(tmpl: *mut c_char, flags: c_int, mode: c_int) -> c_int;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_on_error_query(prg_name: *const c_char);
    pub fn g_on_error_stack_trace(prg_name: *const c_char);
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_parse_debug_string(string: *const c_char, keys: *mut GDebugKey, nkeys: c_uint) -> c_uint;
    pub fn g_path_get_basename(file_name: *mut c_char) -> *mut c_char;
    pub fn g_path_get_dirname(file_name: *mut c_char) -> *mut c_char;
    pub fn g_path_is_absolute(file_name: *mut c_char) -> gboolean;
    pub fn g_path_skip_root(file_name: *mut c_char) -> *mut c_char;
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: c_uint, string: *const c_char, string_reversed: *const c_char) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const c_char, string: *const c_char) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const c_char) -> gboolean;
    pub fn g_pointer_bit_lock(address: *mut c_void, lock_bit: c_int);
    pub fn g_pointer_bit_trylock(address: *mut c_void, lock_bit: c_int) -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut c_void, lock_bit: c_int);
    pub fn g_poll(fds: *mut GPollFD, nfds: c_uint, timeout: c_int) -> c_int;
    pub fn g_prefix_error(err: *mut *mut GError, format: *const c_char, ...);
    pub fn g_print(format: *const c_char, ...);
    pub fn g_printerr(format: *const c_char, ...);
    pub fn g_printf(format: *mut c_char, ...) -> c_int;
    //pub fn g_printf_string_upper_bound(format: *const c_char, args: /*Unimplemented*/va_list) -> size_t;
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError, src: *mut GError, format: *const c_char, ...);
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: c_int, size: size_t, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_quark_from_static_string(string: *const c_char) -> GQuark;
    pub fn g_quark_from_string(string: *const c_char) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const c_char;
    pub fn g_quark_try_string(string: *const c_char) -> GQuark;
    pub fn g_random_double() -> c_double;
    pub fn g_random_double_range(begin: c_double, end: c_double) -> c_double;
    pub fn g_random_int() -> u32;
    pub fn g_random_int_range(begin: i32, end: i32) -> i32;
    pub fn g_random_set_seed(seed: u32);
    pub fn g_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_return_if_fail_warning(log_domain: *const c_char, pretty_function: *const c_char, expression: *const c_char);
    pub fn g_rmdir(filename: *mut c_char) -> c_int;
    pub fn g_set_application_name(application_name: *const c_char);
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: c_int, format: *const c_char, ...);
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark, code: c_int, message: *const c_char);
    pub fn g_set_prgname(prgname: *const c_char);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_setenv(variable: *const c_char, value: *const c_char, overwrite: gboolean) -> gboolean;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_parse_argv(command_line: *const c_char, argcp: *mut c_int, argvp: *mut *mut *mut c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_shell_quote(unquoted_string: *const c_char) -> *mut c_char;
    pub fn g_shell_unquote(quoted_string: *const c_char, error: *mut *mut GError) -> *mut c_char;
    pub fn g_slice_alloc(block_size: size_t) -> gpointer;
    pub fn g_slice_alloc0(block_size: size_t) -> gpointer;
    pub fn g_slice_copy(block_size: size_t, mem_block: gconstpointer) -> gpointer;
    pub fn g_slice_free1(block_size: size_t, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(block_size: size_t, mem_chain: gpointer, next_offset: size_t);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> i64;
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: i64, n_values: *mut c_uint) -> *mut i64;
    pub fn g_slice_set_config(ckey: GSliceConfig, value: i64);
    pub fn g_snprintf(string: *mut c_char, n: c_ulong, format: *mut c_char, ...) -> c_int;
    pub fn g_spaced_primes_closest(num: c_uint) -> c_uint;
    pub fn g_spawn_async(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_async_with_pipes(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: *mut GPid, standard_input: *mut c_int, standard_output: *mut c_int, standard_error: *mut c_int, error: *mut *mut GError) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_spawn_check_exit_status(exit_status: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub fn g_spawn_command_line_async(command_line: *const c_char, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_command_line_sync(command_line: *const c_char, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_sync(working_directory: *mut c_char, argv: *mut *mut c_char, envp: *mut *mut c_char, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: *mut *mut u8, standard_error: *mut *mut u8, exit_status: *mut c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_sprintf(string: *mut c_char, format: *mut c_char, ...) -> c_int;
    pub fn g_stpcpy(dest: *mut c_char, src: *const c_char) -> *mut c_char;
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_has_prefix(str: *const c_char, prefix: *const c_char) -> gboolean;
    pub fn g_str_has_suffix(str: *const c_char, suffix: *const c_char) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> c_uint;
    #[cfg(feature = "v2_40")]
    pub fn g_str_is_ascii(str: *const c_char) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_str_match_string(search_term: *const c_char, potential_hit: *const c_char, accept_alternates: gboolean) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_str_to_ascii(str: *const c_char, from_locale: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_str_tokenize_and_fold(string: *const c_char, translit_locale: *const c_char, ascii_alternates: *mut *mut *mut c_char) -> *mut *mut c_char;
    pub fn g_strcanon(string: *mut c_char, valid_chars: *const c_char, substitutor: c_char) -> *mut c_char;
    pub fn g_strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
    pub fn g_strchomp(string: *mut c_char) -> *mut c_char;
    pub fn g_strchug(string: *mut c_char) -> *mut c_char;
    pub fn g_strcmp0(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_strcompress(source: *const c_char) -> *mut c_char;
    pub fn g_strconcat(string1: *const c_char, ...) -> *mut c_char;
    pub fn g_strdelimit(string: *mut c_char, delimiters: *const c_char, new_delimiter: c_char) -> *mut c_char;
    pub fn g_strdown(string: *mut c_char) -> *mut c_char;
    pub fn g_strdup(str: *const c_char) -> *mut c_char;
    pub fn g_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //pub fn g_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn g_strdupv(str_array: *mut *mut c_char) -> *mut *mut c_char;
    pub fn g_strerror(errnum: c_int) -> *const c_char;
    pub fn g_strescape(source: *const c_char, exceptions: *const c_char) -> *mut c_char;
    pub fn g_strfreev(str_array: *mut *mut c_char);
    pub fn g_string_new(init: *const c_char) -> *mut GString;
    pub fn g_string_new_len(init: *const c_char, len: ssize_t) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: size_t) -> *mut GString;
    pub fn g_strip_context(msgid: *const c_char, msgval: *const c_char) -> *const c_char;
    pub fn g_strjoin(separator: *const c_char, ...) -> *mut c_char;
    pub fn g_strjoinv(separator: *const c_char, str_array: *mut *mut c_char) -> *mut c_char;
    pub fn g_strlcat(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strlcpy(dest: *mut c_char, src: *const c_char, dest_size: size_t) -> size_t;
    pub fn g_strncasecmp(s1: *const c_char, s2: *const c_char, n: c_uint) -> c_int;
    pub fn g_strndup(str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_strnfill(length: size_t, fill_char: c_char) -> *mut c_char;
    pub fn g_strreverse(string: *mut c_char) -> *mut c_char;
    pub fn g_strrstr(haystack: *const c_char, needle: *const c_char) -> *mut c_char;
    pub fn g_strrstr_len(haystack: *const c_char, haystack_len: ssize_t, needle: *const c_char) -> *mut c_char;
    pub fn g_strsignal(signum: c_int) -> *const c_char;
    pub fn g_strsplit(string: *const c_char, delimiter: *const c_char, max_tokens: c_int) -> *mut *mut c_char;
    pub fn g_strsplit_set(string: *const c_char, delimiters: *const c_char, max_tokens: c_int) -> *mut *mut c_char;
    pub fn g_strstr_len(haystack: *const c_char, haystack_len: ssize_t, needle: *const c_char) -> *mut c_char;
    pub fn g_strtod(nptr: *const c_char, endptr: *mut *mut c_char) -> c_double;
    pub fn g_strup(string: *mut c_char) -> *mut c_char;
    #[cfg(feature = "v2_44")]
    pub fn g_strv_contains(strv: *const *const c_char, str: *const c_char) -> gboolean;
    pub fn g_strv_get_type() -> GType;
    pub fn g_strv_length(str_array: *mut *mut c_char) -> c_uint;
    pub fn g_test_add_data_func(testpath: *const c_char, test_data: gconstpointer, test_func: GTestDataFunc);
    #[cfg(feature = "v2_34")]
    pub fn g_test_add_data_func_full(testpath: *const c_char, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify);
    pub fn g_test_add_func(testpath: *const c_char, test_func: GTestFunc);
    pub fn g_test_add_vtable(testpath: *const c_char, data_size: size_t, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc);
    pub fn g_test_assert_expected_messages_internal(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char);
    pub fn g_test_bug(bug_uri_snippet: *const c_char);
    pub fn g_test_bug_base(uri_pattern: *const c_char);
    #[cfg(feature = "v2_38")]
    pub fn g_test_build_filename(file_type: GTestFileType, first_path: *const c_char, ...) -> *mut c_char;
    pub fn g_test_create_case(test_name: *const c_char, data_size: size_t, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const c_char) -> *mut GTestSuite;
    #[cfg(feature = "v2_34")]
    pub fn g_test_expect_message(log_domain: *const c_char, log_level: GLogLevelFlags, pattern: *const c_char);
    pub fn g_test_fail();
    #[cfg(feature = "v2_38")]
    pub fn g_test_failed() -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_test_get_dir(file_type: GTestFileType) -> *mut c_char;
    #[cfg(feature = "v2_38")]
    pub fn g_test_get_filename(file_type: GTestFileType, first_path: *const c_char, ...) -> *const c_char;
    pub fn g_test_get_root() -> *mut GTestSuite;
    #[cfg(feature = "v2_38")]
    pub fn g_test_incomplete(msg: *const c_char);
    pub fn g_test_init(argc: *mut c_int, argv: *mut *mut *mut c_char, ...);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const c_char;
    pub fn g_test_maximized_result(maximized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_message(format: *const c_char, ...);
    pub fn g_test_minimized_result(minimized_quantity: c_double, format: *const c_char, ...);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_rand_double() -> c_double;
    pub fn g_test_rand_double_range(range_start: c_double, range_end: c_double) -> c_double;
    pub fn g_test_rand_int() -> i32;
    pub fn g_test_rand_int_range(begin: i32, end: i32) -> i32;
    pub fn g_test_run() -> c_int;
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> c_int;
    #[cfg(feature = "v2_38")]
    pub fn g_test_set_nonfatal_assertions();
    #[cfg(feature = "v2_38")]
    pub fn g_test_skip(msg: *const c_char);
    #[cfg(feature = "v2_38")]
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_timer_elapsed() -> c_double;
    pub fn g_test_timer_last() -> c_double;
    pub fn g_test_timer_start();
    pub fn g_test_trap_assertions(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, assertion_flags: u64, pattern: *const c_char);
    pub fn g_test_trap_fork(usec_timeout: u64, test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_test_trap_subprocess(test_path: *const c_char, usec_timeout: u64, test_flags: GTestSubprocessFlags);
    pub fn g_timeout_add(interval: c_uint, function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_timeout_add_full(priority: c_int, interval: c_uint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_timeout_add_seconds(interval: c_uint, function: GSourceFunc, data: gpointer) -> c_uint;
    pub fn g_timeout_add_seconds_full(priority: c_int, interval: c_uint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_timeout_source_new(interval: c_uint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: c_uint) -> *mut GSource;
    pub fn g_try_malloc(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0(n_bytes: size_t) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_malloc_n(n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: size_t) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: size_t, n_block_bytes: size_t) -> gpointer;
    pub fn g_ucs4_to_utf16(str: *const u32, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u16;
    pub fn g_ucs4_to_utf8(str: *const u32, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut c_char;
    pub fn g_unichar_break_type(c: u32) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: u32) -> c_int;
    pub fn g_unichar_compose(a: u32, b: u32, ch: *mut u32) -> gboolean;
    pub fn g_unichar_decompose(ch: u32, a: *mut u32, b: *mut u32) -> gboolean;
    pub fn g_unichar_digit_value(c: u32) -> c_int;
    pub fn g_unichar_fully_decompose(ch: u32, compat: gboolean, result: *mut u32, result_len: size_t) -> size_t;
    pub fn g_unichar_get_mirror_char(ch: u32, mirrored_ch: *mut u32) -> gboolean;
    pub fn g_unichar_get_script(ch: u32) -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: u32) -> gboolean;
    pub fn g_unichar_isalpha(c: u32) -> gboolean;
    pub fn g_unichar_iscntrl(c: u32) -> gboolean;
    pub fn g_unichar_isdefined(c: u32) -> gboolean;
    pub fn g_unichar_isdigit(c: u32) -> gboolean;
    pub fn g_unichar_isgraph(c: u32) -> gboolean;
    pub fn g_unichar_islower(c: u32) -> gboolean;
    pub fn g_unichar_ismark(c: u32) -> gboolean;
    pub fn g_unichar_isprint(c: u32) -> gboolean;
    pub fn g_unichar_ispunct(c: u32) -> gboolean;
    pub fn g_unichar_isspace(c: u32) -> gboolean;
    pub fn g_unichar_istitle(c: u32) -> gboolean;
    pub fn g_unichar_isupper(c: u32) -> gboolean;
    pub fn g_unichar_iswide(c: u32) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: u32) -> gboolean;
    pub fn g_unichar_isxdigit(c: u32) -> gboolean;
    pub fn g_unichar_iszerowidth(c: u32) -> gboolean;
    pub fn g_unichar_to_utf8(c: u32, outbuf: *mut c_char) -> c_int;
    pub fn g_unichar_tolower(c: u32) -> u32;
    pub fn g_unichar_totitle(c: u32) -> u32;
    pub fn g_unichar_toupper(c: u32) -> u32;
    pub fn g_unichar_type(c: u32) -> GUnicodeType;
    pub fn g_unichar_validate(ch: u32) -> gboolean;
    pub fn g_unichar_xdigit_value(c: u32) -> c_int;
    pub fn g_unicode_canonical_decomposition(ch: u32, result_len: *mut size_t) -> *mut u32;
    pub fn g_unicode_canonical_ordering(string: *mut u32, len: size_t);
    pub fn g_unicode_script_from_iso15924(iso15924: u32) -> GUnicodeScript;
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> u32;
    pub fn g_unix_error_quark() -> GQuark;
    #[cfg(feature = "v2_36")]
    pub fn g_unix_fd_add(fd: c_int, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer) -> c_uint;
    #[cfg(feature = "v2_36")]
    pub fn g_unix_fd_add_full(priority: c_int, fd: c_int, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    #[cfg(feature = "v2_36")]
    pub fn g_unix_fd_source_new(fd: c_int, condition: GIOCondition) -> *mut GSource;
    pub fn g_unix_open_pipe(fds: *mut c_int, flags: c_int, error: *mut *mut GError) -> gboolean;
    pub fn g_unix_set_fd_nonblocking(fd: c_int, nonblock: gboolean, error: *mut *mut GError) -> gboolean;
    pub fn g_unix_signal_add(signum: c_int, handler: GSourceFunc, user_data: gpointer) -> c_uint;
    pub fn g_unix_signal_add_full(priority: c_int, signum: c_int, handler: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> c_uint;
    pub fn g_unix_signal_source_new(signum: c_int) -> *mut GSource;
    pub fn g_unlink(filename: *mut c_char) -> c_int;
    pub fn g_unsetenv(variable: *const c_char);
    pub fn g_uri_escape_string(unescaped: *const c_char, reserved_chars_allowed: *const c_char, allow_utf8: gboolean) -> *mut c_char;
    pub fn g_uri_list_extract_uris(uri_list: *const c_char) -> *mut *mut c_char;
    pub fn g_uri_parse_scheme(uri: *const c_char) -> *mut c_char;
    pub fn g_uri_unescape_segment(escaped_string: *const c_char, escaped_string_end: *const c_char, illegal_characters: *const c_char) -> *mut c_char;
    pub fn g_uri_unescape_string(escaped_string: *const c_char, illegal_characters: *const c_char) -> *mut c_char;
    pub fn g_usleep(microseconds: c_ulong);
    pub fn g_utf16_to_ucs4(str: *const u16, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u32;
    pub fn g_utf16_to_utf8(str: *const u16, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut c_char;
    pub fn g_utf8_casefold(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate(str1: *const c_char, str2: *const c_char) -> c_int;
    pub fn g_utf8_collate_key(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_collate_key_for_filename(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_find_next_char(p: *const c_char, end: *const c_char) -> *mut c_char;
    pub fn g_utf8_find_prev_char(str: *const c_char, p: *const c_char) -> *mut c_char;
    pub fn g_utf8_get_char(p: *const c_char) -> u32;
    pub fn g_utf8_get_char_validated(p: *const c_char, max_len: ssize_t) -> u32;
    pub fn g_utf8_normalize(str: *const c_char, len: ssize_t, mode: GNormalizeMode) -> *mut c_char;
    pub fn g_utf8_offset_to_pointer(str: *const c_char, offset: c_long) -> *mut c_char;
    pub fn g_utf8_pointer_to_offset(str: *const c_char, pos: *const c_char) -> c_long;
    pub fn g_utf8_prev_char(p: *const c_char) -> *mut c_char;
    pub fn g_utf8_strchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strdown(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strlen(p: *const c_char, max: ssize_t) -> c_long;
    pub fn g_utf8_strncpy(dest: *mut c_char, src: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_utf8_strrchr(p: *const c_char, len: ssize_t, c: u32) -> *mut c_char;
    pub fn g_utf8_strreverse(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_strup(str: *const c_char, len: ssize_t) -> *mut c_char;
    pub fn g_utf8_substring(str: *const c_char, start_pos: c_long, end_pos: c_long) -> *mut c_char;
    pub fn g_utf8_to_ucs4(str: *const c_char, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u32;
    pub fn g_utf8_to_ucs4_fast(str: *const c_char, len: c_long, items_written: *mut c_long) -> *mut u32;
    pub fn g_utf8_to_utf16(str: *const c_char, len: c_long, items_read: *mut c_long, items_written: *mut c_long, error: *mut *mut GError) -> *mut u16;
    pub fn g_utf8_validate(str: *mut u8, max_len: ssize_t, end: *mut *const c_char) -> gboolean;
    pub fn g_variant_get_gtype() -> GType;
    //pub fn g_vasprintf(string: *mut *mut c_char, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vfprintf(file: *mut FILE, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vprintf(format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsnprintf(string: *mut c_char, n: c_ulong, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    //pub fn g_vsprintf(string: *mut c_char, format: *mut c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn g_warn_message(domain: *const c_char, file: *const c_char, line: c_int, func: *const c_char, warnexpr: *const c_char);

}
