// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkCoordType")]
pub enum CoordType {
    #[doc(alias = "ATK_XY_SCREEN")]
    Screen,
    #[doc(alias = "ATK_XY_WINDOW")]
    Window,
    #[doc(alias = "ATK_XY_PARENT")]
    Parent,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CoordType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CoordType::{}",
            match *self {
                CoordType::Screen => "Screen",
                CoordType::Window => "Window",
                CoordType::Parent => "Parent",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CoordType {
    type GlibType = ffi::AtkCoordType;

    fn to_glib(&self) -> ffi::AtkCoordType {
        match *self {
            CoordType::Screen => ffi::ATK_XY_SCREEN,
            CoordType::Window => ffi::ATK_XY_WINDOW,
            CoordType::Parent => ffi::ATK_XY_PARENT,
            CoordType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkCoordType> for CoordType {
    unsafe fn from_glib(value: ffi::AtkCoordType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CoordType::Screen,
            1 => CoordType::Window,
            2 => CoordType::Parent,
            value => CoordType::__Unknown(value),
        }
    }
}

impl StaticType for CoordType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_coord_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CoordType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CoordType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CoordType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkLayer")]
pub enum Layer {
    #[doc(alias = "ATK_LAYER_INVALID")]
    Invalid,
    #[doc(alias = "ATK_LAYER_BACKGROUND")]
    Background,
    #[doc(alias = "ATK_LAYER_CANVAS")]
    Canvas,
    #[doc(alias = "ATK_LAYER_WIDGET")]
    Widget,
    #[doc(alias = "ATK_LAYER_MDI")]
    Mdi,
    #[doc(alias = "ATK_LAYER_POPUP")]
    Popup,
    #[doc(alias = "ATK_LAYER_OVERLAY")]
    Overlay,
    #[doc(alias = "ATK_LAYER_WINDOW")]
    Window,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Layer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Layer::{}",
            match *self {
                Layer::Invalid => "Invalid",
                Layer::Background => "Background",
                Layer::Canvas => "Canvas",
                Layer::Widget => "Widget",
                Layer::Mdi => "Mdi",
                Layer::Popup => "Popup",
                Layer::Overlay => "Overlay",
                Layer::Window => "Window",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Layer {
    type GlibType = ffi::AtkLayer;

    fn to_glib(&self) -> ffi::AtkLayer {
        match *self {
            Layer::Invalid => ffi::ATK_LAYER_INVALID,
            Layer::Background => ffi::ATK_LAYER_BACKGROUND,
            Layer::Canvas => ffi::ATK_LAYER_CANVAS,
            Layer::Widget => ffi::ATK_LAYER_WIDGET,
            Layer::Mdi => ffi::ATK_LAYER_MDI,
            Layer::Popup => ffi::ATK_LAYER_POPUP,
            Layer::Overlay => ffi::ATK_LAYER_OVERLAY,
            Layer::Window => ffi::ATK_LAYER_WINDOW,
            Layer::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkLayer> for Layer {
    unsafe fn from_glib(value: ffi::AtkLayer) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Layer::Invalid,
            1 => Layer::Background,
            2 => Layer::Canvas,
            3 => Layer::Widget,
            4 => Layer::Mdi,
            5 => Layer::Popup,
            6 => Layer::Overlay,
            7 => Layer::Window,
            value => Layer::__Unknown(value),
        }
    }
}

impl StaticType for Layer {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_layer_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Layer {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Layer {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Layer {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkRelationType")]
pub enum RelationType {
    #[doc(alias = "ATK_RELATION_NULL")]
    Null,
    #[doc(alias = "ATK_RELATION_CONTROLLED_BY")]
    ControlledBy,
    #[doc(alias = "ATK_RELATION_CONTROLLER_FOR")]
    ControllerFor,
    #[doc(alias = "ATK_RELATION_LABEL_FOR")]
    LabelFor,
    #[doc(alias = "ATK_RELATION_LABELLED_BY")]
    LabelledBy,
    #[doc(alias = "ATK_RELATION_MEMBER_OF")]
    MemberOf,
    #[doc(alias = "ATK_RELATION_NODE_CHILD_OF")]
    NodeChildOf,
    #[doc(alias = "ATK_RELATION_FLOWS_TO")]
    FlowsTo,
    #[doc(alias = "ATK_RELATION_FLOWS_FROM")]
    FlowsFrom,
    #[doc(alias = "ATK_RELATION_SUBWINDOW_OF")]
    SubwindowOf,
    #[doc(alias = "ATK_RELATION_EMBEDS")]
    Embeds,
    #[doc(alias = "ATK_RELATION_EMBEDDED_BY")]
    EmbeddedBy,
    #[doc(alias = "ATK_RELATION_POPUP_FOR")]
    PopupFor,
    #[doc(alias = "ATK_RELATION_PARENT_WINDOW_OF")]
    ParentWindowOf,
    #[doc(alias = "ATK_RELATION_DESCRIBED_BY")]
    DescribedBy,
    #[doc(alias = "ATK_RELATION_DESCRIPTION_FOR")]
    DescriptionFor,
    #[doc(alias = "ATK_RELATION_NODE_PARENT_OF")]
    NodeParentOf,
    #[doc(alias = "ATK_RELATION_DETAILS")]
    Details,
    #[doc(alias = "ATK_RELATION_DETAILS_FOR")]
    DetailsFor,
    #[doc(alias = "ATK_RELATION_ERROR_MESSAGE")]
    ErrorMessage,
    #[doc(alias = "ATK_RELATION_ERROR_FOR")]
    ErrorFor,
    #[doc(alias = "ATK_RELATION_LAST_DEFINED")]
    LastDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl RelationType {
    #[doc(alias = "atk_relation_type_for_name")]
    pub fn for_name(name: &str) -> RelationType {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::atk_relation_type_for_name(name.to_glib_none().0)) }
    }

    #[doc(alias = "atk_relation_type_get_name")]
    pub fn get_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_relation_type_get_name(self.to_glib())) }
    }
}

impl fmt::Display for RelationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RelationType::{}",
            match *self {
                RelationType::Null => "Null",
                RelationType::ControlledBy => "ControlledBy",
                RelationType::ControllerFor => "ControllerFor",
                RelationType::LabelFor => "LabelFor",
                RelationType::LabelledBy => "LabelledBy",
                RelationType::MemberOf => "MemberOf",
                RelationType::NodeChildOf => "NodeChildOf",
                RelationType::FlowsTo => "FlowsTo",
                RelationType::FlowsFrom => "FlowsFrom",
                RelationType::SubwindowOf => "SubwindowOf",
                RelationType::Embeds => "Embeds",
                RelationType::EmbeddedBy => "EmbeddedBy",
                RelationType::PopupFor => "PopupFor",
                RelationType::ParentWindowOf => "ParentWindowOf",
                RelationType::DescribedBy => "DescribedBy",
                RelationType::DescriptionFor => "DescriptionFor",
                RelationType::NodeParentOf => "NodeParentOf",
                RelationType::Details => "Details",
                RelationType::DetailsFor => "DetailsFor",
                RelationType::ErrorMessage => "ErrorMessage",
                RelationType::ErrorFor => "ErrorFor",
                RelationType::LastDefined => "LastDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RelationType {
    type GlibType = ffi::AtkRelationType;

    fn to_glib(&self) -> ffi::AtkRelationType {
        match *self {
            RelationType::Null => ffi::ATK_RELATION_NULL,
            RelationType::ControlledBy => ffi::ATK_RELATION_CONTROLLED_BY,
            RelationType::ControllerFor => ffi::ATK_RELATION_CONTROLLER_FOR,
            RelationType::LabelFor => ffi::ATK_RELATION_LABEL_FOR,
            RelationType::LabelledBy => ffi::ATK_RELATION_LABELLED_BY,
            RelationType::MemberOf => ffi::ATK_RELATION_MEMBER_OF,
            RelationType::NodeChildOf => ffi::ATK_RELATION_NODE_CHILD_OF,
            RelationType::FlowsTo => ffi::ATK_RELATION_FLOWS_TO,
            RelationType::FlowsFrom => ffi::ATK_RELATION_FLOWS_FROM,
            RelationType::SubwindowOf => ffi::ATK_RELATION_SUBWINDOW_OF,
            RelationType::Embeds => ffi::ATK_RELATION_EMBEDS,
            RelationType::EmbeddedBy => ffi::ATK_RELATION_EMBEDDED_BY,
            RelationType::PopupFor => ffi::ATK_RELATION_POPUP_FOR,
            RelationType::ParentWindowOf => ffi::ATK_RELATION_PARENT_WINDOW_OF,
            RelationType::DescribedBy => ffi::ATK_RELATION_DESCRIBED_BY,
            RelationType::DescriptionFor => ffi::ATK_RELATION_DESCRIPTION_FOR,
            RelationType::NodeParentOf => ffi::ATK_RELATION_NODE_PARENT_OF,
            RelationType::Details => ffi::ATK_RELATION_DETAILS,
            RelationType::DetailsFor => ffi::ATK_RELATION_DETAILS_FOR,
            RelationType::ErrorMessage => ffi::ATK_RELATION_ERROR_MESSAGE,
            RelationType::ErrorFor => ffi::ATK_RELATION_ERROR_FOR,
            RelationType::LastDefined => ffi::ATK_RELATION_LAST_DEFINED,
            RelationType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkRelationType> for RelationType {
    unsafe fn from_glib(value: ffi::AtkRelationType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RelationType::Null,
            1 => RelationType::ControlledBy,
            2 => RelationType::ControllerFor,
            3 => RelationType::LabelFor,
            4 => RelationType::LabelledBy,
            5 => RelationType::MemberOf,
            6 => RelationType::NodeChildOf,
            7 => RelationType::FlowsTo,
            8 => RelationType::FlowsFrom,
            9 => RelationType::SubwindowOf,
            10 => RelationType::Embeds,
            11 => RelationType::EmbeddedBy,
            12 => RelationType::PopupFor,
            13 => RelationType::ParentWindowOf,
            14 => RelationType::DescribedBy,
            15 => RelationType::DescriptionFor,
            16 => RelationType::NodeParentOf,
            17 => RelationType::Details,
            18 => RelationType::DetailsFor,
            19 => RelationType::ErrorMessage,
            20 => RelationType::ErrorFor,
            21 => RelationType::LastDefined,
            value => RelationType::__Unknown(value),
        }
    }
}

impl StaticType for RelationType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_relation_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RelationType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RelationType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RelationType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkRole")]
pub enum Role {
    #[doc(alias = "ATK_ROLE_INVALID")]
    Invalid,
    #[doc(alias = "ATK_ROLE_ACCEL_LABEL")]
    AcceleratorLabel,
    #[doc(alias = "ATK_ROLE_ALERT")]
    Alert,
    #[doc(alias = "ATK_ROLE_ANIMATION")]
    Animation,
    #[doc(alias = "ATK_ROLE_ARROW")]
    Arrow,
    #[doc(alias = "ATK_ROLE_CALENDAR")]
    Calendar,
    #[doc(alias = "ATK_ROLE_CANVAS")]
    Canvas,
    #[doc(alias = "ATK_ROLE_CHECK_BOX")]
    CheckBox,
    #[doc(alias = "ATK_ROLE_CHECK_MENU_ITEM")]
    CheckMenuItem,
    #[doc(alias = "ATK_ROLE_COLOR_CHOOSER")]
    ColorChooser,
    #[doc(alias = "ATK_ROLE_COLUMN_HEADER")]
    ColumnHeader,
    #[doc(alias = "ATK_ROLE_COMBO_BOX")]
    ComboBox,
    #[doc(alias = "ATK_ROLE_DATE_EDITOR")]
    DateEditor,
    #[doc(alias = "ATK_ROLE_DESKTOP_ICON")]
    DesktopIcon,
    #[doc(alias = "ATK_ROLE_DESKTOP_FRAME")]
    DesktopFrame,
    #[doc(alias = "ATK_ROLE_DIAL")]
    Dial,
    #[doc(alias = "ATK_ROLE_DIALOG")]
    Dialog,
    #[doc(alias = "ATK_ROLE_DIRECTORY_PANE")]
    DirectoryPane,
    #[doc(alias = "ATK_ROLE_DRAWING_AREA")]
    DrawingArea,
    #[doc(alias = "ATK_ROLE_FILE_CHOOSER")]
    FileChooser,
    #[doc(alias = "ATK_ROLE_FILLER")]
    Filler,
    #[doc(alias = "ATK_ROLE_FONT_CHOOSER")]
    FontChooser,
    #[doc(alias = "ATK_ROLE_FRAME")]
    Frame,
    #[doc(alias = "ATK_ROLE_GLASS_PANE")]
    GlassPane,
    #[doc(alias = "ATK_ROLE_HTML_CONTAINER")]
    HtmlContainer,
    #[doc(alias = "ATK_ROLE_ICON")]
    Icon,
    #[doc(alias = "ATK_ROLE_IMAGE")]
    Image,
    #[doc(alias = "ATK_ROLE_INTERNAL_FRAME")]
    InternalFrame,
    #[doc(alias = "ATK_ROLE_LABEL")]
    Label,
    #[doc(alias = "ATK_ROLE_LAYERED_PANE")]
    LayeredPane,
    #[doc(alias = "ATK_ROLE_LIST")]
    List,
    #[doc(alias = "ATK_ROLE_LIST_ITEM")]
    ListItem,
    #[doc(alias = "ATK_ROLE_MENU")]
    Menu,
    #[doc(alias = "ATK_ROLE_MENU_BAR")]
    MenuBar,
    #[doc(alias = "ATK_ROLE_MENU_ITEM")]
    MenuItem,
    #[doc(alias = "ATK_ROLE_OPTION_PANE")]
    OptionPane,
    #[doc(alias = "ATK_ROLE_PAGE_TAB")]
    PageTab,
    #[doc(alias = "ATK_ROLE_PAGE_TAB_LIST")]
    PageTabList,
    #[doc(alias = "ATK_ROLE_PANEL")]
    Panel,
    #[doc(alias = "ATK_ROLE_PASSWORD_TEXT")]
    PasswordText,
    #[doc(alias = "ATK_ROLE_POPUP_MENU")]
    PopupMenu,
    #[doc(alias = "ATK_ROLE_PROGRESS_BAR")]
    ProgressBar,
    #[doc(alias = "ATK_ROLE_PUSH_BUTTON")]
    PushButton,
    #[doc(alias = "ATK_ROLE_RADIO_BUTTON")]
    RadioButton,
    #[doc(alias = "ATK_ROLE_RADIO_MENU_ITEM")]
    RadioMenuItem,
    #[doc(alias = "ATK_ROLE_ROOT_PANE")]
    RootPane,
    #[doc(alias = "ATK_ROLE_ROW_HEADER")]
    RowHeader,
    #[doc(alias = "ATK_ROLE_SCROLL_BAR")]
    ScrollBar,
    #[doc(alias = "ATK_ROLE_SCROLL_PANE")]
    ScrollPane,
    #[doc(alias = "ATK_ROLE_SEPARATOR")]
    Separator,
    #[doc(alias = "ATK_ROLE_SLIDER")]
    Slider,
    #[doc(alias = "ATK_ROLE_SPLIT_PANE")]
    SplitPane,
    #[doc(alias = "ATK_ROLE_SPIN_BUTTON")]
    SpinButton,
    #[doc(alias = "ATK_ROLE_STATUSBAR")]
    Statusbar,
    #[doc(alias = "ATK_ROLE_TABLE")]
    Table,
    #[doc(alias = "ATK_ROLE_TABLE_CELL")]
    TableCell,
    #[doc(alias = "ATK_ROLE_TABLE_COLUMN_HEADER")]
    TableColumnHeader,
    #[doc(alias = "ATK_ROLE_TABLE_ROW_HEADER")]
    TableRowHeader,
    #[doc(alias = "ATK_ROLE_TEAR_OFF_MENU_ITEM")]
    TearOffMenuItem,
    #[doc(alias = "ATK_ROLE_TERMINAL")]
    Terminal,
    #[doc(alias = "ATK_ROLE_TEXT")]
    Text,
    #[doc(alias = "ATK_ROLE_TOGGLE_BUTTON")]
    ToggleButton,
    #[doc(alias = "ATK_ROLE_TOOL_BAR")]
    ToolBar,
    #[doc(alias = "ATK_ROLE_TOOL_TIP")]
    ToolTip,
    #[doc(alias = "ATK_ROLE_TREE")]
    Tree,
    #[doc(alias = "ATK_ROLE_TREE_TABLE")]
    TreeTable,
    #[doc(alias = "ATK_ROLE_UNKNOWN")]
    Unknown,
    #[doc(alias = "ATK_ROLE_VIEWPORT")]
    Viewport,
    #[doc(alias = "ATK_ROLE_WINDOW")]
    Window,
    #[doc(alias = "ATK_ROLE_HEADER")]
    Header,
    #[doc(alias = "ATK_ROLE_FOOTER")]
    Footer,
    #[doc(alias = "ATK_ROLE_PARAGRAPH")]
    Paragraph,
    #[doc(alias = "ATK_ROLE_RULER")]
    Ruler,
    #[doc(alias = "ATK_ROLE_APPLICATION")]
    Application,
    #[doc(alias = "ATK_ROLE_AUTOCOMPLETE")]
    Autocomplete,
    #[doc(alias = "ATK_ROLE_EDITBAR")]
    EditBar,
    #[doc(alias = "ATK_ROLE_EMBEDDED")]
    Embedded,
    #[doc(alias = "ATK_ROLE_ENTRY")]
    Entry,
    #[doc(alias = "ATK_ROLE_CHART")]
    Chart,
    #[doc(alias = "ATK_ROLE_CAPTION")]
    Caption,
    #[doc(alias = "ATK_ROLE_DOCUMENT_FRAME")]
    DocumentFrame,
    #[doc(alias = "ATK_ROLE_HEADING")]
    Heading,
    #[doc(alias = "ATK_ROLE_PAGE")]
    Page,
    #[doc(alias = "ATK_ROLE_SECTION")]
    Section,
    #[doc(alias = "ATK_ROLE_REDUNDANT_OBJECT")]
    RedundantObject,
    #[doc(alias = "ATK_ROLE_FORM")]
    Form,
    #[doc(alias = "ATK_ROLE_LINK")]
    Link,
    #[doc(alias = "ATK_ROLE_INPUT_METHOD_WINDOW")]
    InputMethodWindow,
    #[doc(alias = "ATK_ROLE_TABLE_ROW")]
    TableRow,
    #[doc(alias = "ATK_ROLE_TREE_ITEM")]
    TreeItem,
    #[doc(alias = "ATK_ROLE_DOCUMENT_SPREADSHEET")]
    DocumentSpreadsheet,
    #[doc(alias = "ATK_ROLE_DOCUMENT_PRESENTATION")]
    DocumentPresentation,
    #[doc(alias = "ATK_ROLE_DOCUMENT_TEXT")]
    DocumentText,
    #[doc(alias = "ATK_ROLE_DOCUMENT_WEB")]
    DocumentWeb,
    #[doc(alias = "ATK_ROLE_DOCUMENT_EMAIL")]
    DocumentEmail,
    #[doc(alias = "ATK_ROLE_COMMENT")]
    Comment,
    #[doc(alias = "ATK_ROLE_LIST_BOX")]
    ListBox,
    #[doc(alias = "ATK_ROLE_GROUPING")]
    Grouping,
    #[doc(alias = "ATK_ROLE_IMAGE_MAP")]
    ImageMap,
    #[doc(alias = "ATK_ROLE_NOTIFICATION")]
    Notification,
    #[doc(alias = "ATK_ROLE_INFO_BAR")]
    InfoBar,
    #[doc(alias = "ATK_ROLE_LEVEL_BAR")]
    LevelBar,
    #[doc(alias = "ATK_ROLE_TITLE_BAR")]
    TitleBar,
    #[doc(alias = "ATK_ROLE_BLOCK_QUOTE")]
    BlockQuote,
    #[doc(alias = "ATK_ROLE_AUDIO")]
    Audio,
    #[doc(alias = "ATK_ROLE_VIDEO")]
    Video,
    #[doc(alias = "ATK_ROLE_DEFINITION")]
    Definition,
    #[doc(alias = "ATK_ROLE_ARTICLE")]
    Article,
    #[doc(alias = "ATK_ROLE_LANDMARK")]
    Landmark,
    #[doc(alias = "ATK_ROLE_LOG")]
    Log,
    #[doc(alias = "ATK_ROLE_MARQUEE")]
    Marquee,
    #[doc(alias = "ATK_ROLE_MATH")]
    Math,
    #[doc(alias = "ATK_ROLE_RATING")]
    Rating,
    #[doc(alias = "ATK_ROLE_TIMER")]
    Timer,
    #[doc(alias = "ATK_ROLE_DESCRIPTION_LIST")]
    DescriptionList,
    #[doc(alias = "ATK_ROLE_DESCRIPTION_TERM")]
    DescriptionTerm,
    #[doc(alias = "ATK_ROLE_DESCRIPTION_VALUE")]
    DescriptionValue,
    #[doc(alias = "ATK_ROLE_STATIC")]
    Static,
    #[doc(alias = "ATK_ROLE_MATH_FRACTION")]
    MathFraction,
    #[doc(alias = "ATK_ROLE_MATH_ROOT")]
    MathRoot,
    #[doc(alias = "ATK_ROLE_SUBSCRIPT")]
    Subscript,
    #[doc(alias = "ATK_ROLE_SUPERSCRIPT")]
    Superscript,
    #[doc(alias = "ATK_ROLE_FOOTNOTE")]
    Footnote,
    #[doc(alias = "ATK_ROLE_CONTENT_DELETION")]
    ContentDeletion,
    #[doc(alias = "ATK_ROLE_CONTENT_INSERTION")]
    ContentInsertion,
    #[doc(alias = "ATK_ROLE_MARK")]
    Mark,
    #[doc(alias = "ATK_ROLE_SUGGESTION")]
    Suggestion,
    #[doc(alias = "ATK_ROLE_LAST_DEFINED")]
    LastDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl Role {
    #[doc(alias = "atk_role_for_name")]
    pub fn for_name(name: &str) -> Role {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::atk_role_for_name(name.to_glib_none().0)) }
    }

    #[doc(alias = "atk_role_get_localized_name")]
    pub fn get_localized_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_role_get_localized_name(self.to_glib())) }
    }

    #[doc(alias = "atk_role_get_name")]
    pub fn get_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_role_get_name(self.to_glib())) }
    }
}

impl fmt::Display for Role {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Role::{}",
            match *self {
                Role::Invalid => "Invalid",
                Role::AcceleratorLabel => "AcceleratorLabel",
                Role::Alert => "Alert",
                Role::Animation => "Animation",
                Role::Arrow => "Arrow",
                Role::Calendar => "Calendar",
                Role::Canvas => "Canvas",
                Role::CheckBox => "CheckBox",
                Role::CheckMenuItem => "CheckMenuItem",
                Role::ColorChooser => "ColorChooser",
                Role::ColumnHeader => "ColumnHeader",
                Role::ComboBox => "ComboBox",
                Role::DateEditor => "DateEditor",
                Role::DesktopIcon => "DesktopIcon",
                Role::DesktopFrame => "DesktopFrame",
                Role::Dial => "Dial",
                Role::Dialog => "Dialog",
                Role::DirectoryPane => "DirectoryPane",
                Role::DrawingArea => "DrawingArea",
                Role::FileChooser => "FileChooser",
                Role::Filler => "Filler",
                Role::FontChooser => "FontChooser",
                Role::Frame => "Frame",
                Role::GlassPane => "GlassPane",
                Role::HtmlContainer => "HtmlContainer",
                Role::Icon => "Icon",
                Role::Image => "Image",
                Role::InternalFrame => "InternalFrame",
                Role::Label => "Label",
                Role::LayeredPane => "LayeredPane",
                Role::List => "List",
                Role::ListItem => "ListItem",
                Role::Menu => "Menu",
                Role::MenuBar => "MenuBar",
                Role::MenuItem => "MenuItem",
                Role::OptionPane => "OptionPane",
                Role::PageTab => "PageTab",
                Role::PageTabList => "PageTabList",
                Role::Panel => "Panel",
                Role::PasswordText => "PasswordText",
                Role::PopupMenu => "PopupMenu",
                Role::ProgressBar => "ProgressBar",
                Role::PushButton => "PushButton",
                Role::RadioButton => "RadioButton",
                Role::RadioMenuItem => "RadioMenuItem",
                Role::RootPane => "RootPane",
                Role::RowHeader => "RowHeader",
                Role::ScrollBar => "ScrollBar",
                Role::ScrollPane => "ScrollPane",
                Role::Separator => "Separator",
                Role::Slider => "Slider",
                Role::SplitPane => "SplitPane",
                Role::SpinButton => "SpinButton",
                Role::Statusbar => "Statusbar",
                Role::Table => "Table",
                Role::TableCell => "TableCell",
                Role::TableColumnHeader => "TableColumnHeader",
                Role::TableRowHeader => "TableRowHeader",
                Role::TearOffMenuItem => "TearOffMenuItem",
                Role::Terminal => "Terminal",
                Role::Text => "Text",
                Role::ToggleButton => "ToggleButton",
                Role::ToolBar => "ToolBar",
                Role::ToolTip => "ToolTip",
                Role::Tree => "Tree",
                Role::TreeTable => "TreeTable",
                Role::Unknown => "Unknown",
                Role::Viewport => "Viewport",
                Role::Window => "Window",
                Role::Header => "Header",
                Role::Footer => "Footer",
                Role::Paragraph => "Paragraph",
                Role::Ruler => "Ruler",
                Role::Application => "Application",
                Role::Autocomplete => "Autocomplete",
                Role::EditBar => "EditBar",
                Role::Embedded => "Embedded",
                Role::Entry => "Entry",
                Role::Chart => "Chart",
                Role::Caption => "Caption",
                Role::DocumentFrame => "DocumentFrame",
                Role::Heading => "Heading",
                Role::Page => "Page",
                Role::Section => "Section",
                Role::RedundantObject => "RedundantObject",
                Role::Form => "Form",
                Role::Link => "Link",
                Role::InputMethodWindow => "InputMethodWindow",
                Role::TableRow => "TableRow",
                Role::TreeItem => "TreeItem",
                Role::DocumentSpreadsheet => "DocumentSpreadsheet",
                Role::DocumentPresentation => "DocumentPresentation",
                Role::DocumentText => "DocumentText",
                Role::DocumentWeb => "DocumentWeb",
                Role::DocumentEmail => "DocumentEmail",
                Role::Comment => "Comment",
                Role::ListBox => "ListBox",
                Role::Grouping => "Grouping",
                Role::ImageMap => "ImageMap",
                Role::Notification => "Notification",
                Role::InfoBar => "InfoBar",
                Role::LevelBar => "LevelBar",
                Role::TitleBar => "TitleBar",
                Role::BlockQuote => "BlockQuote",
                Role::Audio => "Audio",
                Role::Video => "Video",
                Role::Definition => "Definition",
                Role::Article => "Article",
                Role::Landmark => "Landmark",
                Role::Log => "Log",
                Role::Marquee => "Marquee",
                Role::Math => "Math",
                Role::Rating => "Rating",
                Role::Timer => "Timer",
                Role::DescriptionList => "DescriptionList",
                Role::DescriptionTerm => "DescriptionTerm",
                Role::DescriptionValue => "DescriptionValue",
                Role::Static => "Static",
                Role::MathFraction => "MathFraction",
                Role::MathRoot => "MathRoot",
                Role::Subscript => "Subscript",
                Role::Superscript => "Superscript",
                Role::Footnote => "Footnote",
                Role::ContentDeletion => "ContentDeletion",
                Role::ContentInsertion => "ContentInsertion",
                Role::Mark => "Mark",
                Role::Suggestion => "Suggestion",
                Role::LastDefined => "LastDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Role {
    type GlibType = ffi::AtkRole;

    fn to_glib(&self) -> ffi::AtkRole {
        match *self {
            Role::Invalid => ffi::ATK_ROLE_INVALID,
            Role::AcceleratorLabel => ffi::ATK_ROLE_ACCEL_LABEL,
            Role::Alert => ffi::ATK_ROLE_ALERT,
            Role::Animation => ffi::ATK_ROLE_ANIMATION,
            Role::Arrow => ffi::ATK_ROLE_ARROW,
            Role::Calendar => ffi::ATK_ROLE_CALENDAR,
            Role::Canvas => ffi::ATK_ROLE_CANVAS,
            Role::CheckBox => ffi::ATK_ROLE_CHECK_BOX,
            Role::CheckMenuItem => ffi::ATK_ROLE_CHECK_MENU_ITEM,
            Role::ColorChooser => ffi::ATK_ROLE_COLOR_CHOOSER,
            Role::ColumnHeader => ffi::ATK_ROLE_COLUMN_HEADER,
            Role::ComboBox => ffi::ATK_ROLE_COMBO_BOX,
            Role::DateEditor => ffi::ATK_ROLE_DATE_EDITOR,
            Role::DesktopIcon => ffi::ATK_ROLE_DESKTOP_ICON,
            Role::DesktopFrame => ffi::ATK_ROLE_DESKTOP_FRAME,
            Role::Dial => ffi::ATK_ROLE_DIAL,
            Role::Dialog => ffi::ATK_ROLE_DIALOG,
            Role::DirectoryPane => ffi::ATK_ROLE_DIRECTORY_PANE,
            Role::DrawingArea => ffi::ATK_ROLE_DRAWING_AREA,
            Role::FileChooser => ffi::ATK_ROLE_FILE_CHOOSER,
            Role::Filler => ffi::ATK_ROLE_FILLER,
            Role::FontChooser => ffi::ATK_ROLE_FONT_CHOOSER,
            Role::Frame => ffi::ATK_ROLE_FRAME,
            Role::GlassPane => ffi::ATK_ROLE_GLASS_PANE,
            Role::HtmlContainer => ffi::ATK_ROLE_HTML_CONTAINER,
            Role::Icon => ffi::ATK_ROLE_ICON,
            Role::Image => ffi::ATK_ROLE_IMAGE,
            Role::InternalFrame => ffi::ATK_ROLE_INTERNAL_FRAME,
            Role::Label => ffi::ATK_ROLE_LABEL,
            Role::LayeredPane => ffi::ATK_ROLE_LAYERED_PANE,
            Role::List => ffi::ATK_ROLE_LIST,
            Role::ListItem => ffi::ATK_ROLE_LIST_ITEM,
            Role::Menu => ffi::ATK_ROLE_MENU,
            Role::MenuBar => ffi::ATK_ROLE_MENU_BAR,
            Role::MenuItem => ffi::ATK_ROLE_MENU_ITEM,
            Role::OptionPane => ffi::ATK_ROLE_OPTION_PANE,
            Role::PageTab => ffi::ATK_ROLE_PAGE_TAB,
            Role::PageTabList => ffi::ATK_ROLE_PAGE_TAB_LIST,
            Role::Panel => ffi::ATK_ROLE_PANEL,
            Role::PasswordText => ffi::ATK_ROLE_PASSWORD_TEXT,
            Role::PopupMenu => ffi::ATK_ROLE_POPUP_MENU,
            Role::ProgressBar => ffi::ATK_ROLE_PROGRESS_BAR,
            Role::PushButton => ffi::ATK_ROLE_PUSH_BUTTON,
            Role::RadioButton => ffi::ATK_ROLE_RADIO_BUTTON,
            Role::RadioMenuItem => ffi::ATK_ROLE_RADIO_MENU_ITEM,
            Role::RootPane => ffi::ATK_ROLE_ROOT_PANE,
            Role::RowHeader => ffi::ATK_ROLE_ROW_HEADER,
            Role::ScrollBar => ffi::ATK_ROLE_SCROLL_BAR,
            Role::ScrollPane => ffi::ATK_ROLE_SCROLL_PANE,
            Role::Separator => ffi::ATK_ROLE_SEPARATOR,
            Role::Slider => ffi::ATK_ROLE_SLIDER,
            Role::SplitPane => ffi::ATK_ROLE_SPLIT_PANE,
            Role::SpinButton => ffi::ATK_ROLE_SPIN_BUTTON,
            Role::Statusbar => ffi::ATK_ROLE_STATUSBAR,
            Role::Table => ffi::ATK_ROLE_TABLE,
            Role::TableCell => ffi::ATK_ROLE_TABLE_CELL,
            Role::TableColumnHeader => ffi::ATK_ROLE_TABLE_COLUMN_HEADER,
            Role::TableRowHeader => ffi::ATK_ROLE_TABLE_ROW_HEADER,
            Role::TearOffMenuItem => ffi::ATK_ROLE_TEAR_OFF_MENU_ITEM,
            Role::Terminal => ffi::ATK_ROLE_TERMINAL,
            Role::Text => ffi::ATK_ROLE_TEXT,
            Role::ToggleButton => ffi::ATK_ROLE_TOGGLE_BUTTON,
            Role::ToolBar => ffi::ATK_ROLE_TOOL_BAR,
            Role::ToolTip => ffi::ATK_ROLE_TOOL_TIP,
            Role::Tree => ffi::ATK_ROLE_TREE,
            Role::TreeTable => ffi::ATK_ROLE_TREE_TABLE,
            Role::Unknown => ffi::ATK_ROLE_UNKNOWN,
            Role::Viewport => ffi::ATK_ROLE_VIEWPORT,
            Role::Window => ffi::ATK_ROLE_WINDOW,
            Role::Header => ffi::ATK_ROLE_HEADER,
            Role::Footer => ffi::ATK_ROLE_FOOTER,
            Role::Paragraph => ffi::ATK_ROLE_PARAGRAPH,
            Role::Ruler => ffi::ATK_ROLE_RULER,
            Role::Application => ffi::ATK_ROLE_APPLICATION,
            Role::Autocomplete => ffi::ATK_ROLE_AUTOCOMPLETE,
            Role::EditBar => ffi::ATK_ROLE_EDITBAR,
            Role::Embedded => ffi::ATK_ROLE_EMBEDDED,
            Role::Entry => ffi::ATK_ROLE_ENTRY,
            Role::Chart => ffi::ATK_ROLE_CHART,
            Role::Caption => ffi::ATK_ROLE_CAPTION,
            Role::DocumentFrame => ffi::ATK_ROLE_DOCUMENT_FRAME,
            Role::Heading => ffi::ATK_ROLE_HEADING,
            Role::Page => ffi::ATK_ROLE_PAGE,
            Role::Section => ffi::ATK_ROLE_SECTION,
            Role::RedundantObject => ffi::ATK_ROLE_REDUNDANT_OBJECT,
            Role::Form => ffi::ATK_ROLE_FORM,
            Role::Link => ffi::ATK_ROLE_LINK,
            Role::InputMethodWindow => ffi::ATK_ROLE_INPUT_METHOD_WINDOW,
            Role::TableRow => ffi::ATK_ROLE_TABLE_ROW,
            Role::TreeItem => ffi::ATK_ROLE_TREE_ITEM,
            Role::DocumentSpreadsheet => ffi::ATK_ROLE_DOCUMENT_SPREADSHEET,
            Role::DocumentPresentation => ffi::ATK_ROLE_DOCUMENT_PRESENTATION,
            Role::DocumentText => ffi::ATK_ROLE_DOCUMENT_TEXT,
            Role::DocumentWeb => ffi::ATK_ROLE_DOCUMENT_WEB,
            Role::DocumentEmail => ffi::ATK_ROLE_DOCUMENT_EMAIL,
            Role::Comment => ffi::ATK_ROLE_COMMENT,
            Role::ListBox => ffi::ATK_ROLE_LIST_BOX,
            Role::Grouping => ffi::ATK_ROLE_GROUPING,
            Role::ImageMap => ffi::ATK_ROLE_IMAGE_MAP,
            Role::Notification => ffi::ATK_ROLE_NOTIFICATION,
            Role::InfoBar => ffi::ATK_ROLE_INFO_BAR,
            Role::LevelBar => ffi::ATK_ROLE_LEVEL_BAR,
            Role::TitleBar => ffi::ATK_ROLE_TITLE_BAR,
            Role::BlockQuote => ffi::ATK_ROLE_BLOCK_QUOTE,
            Role::Audio => ffi::ATK_ROLE_AUDIO,
            Role::Video => ffi::ATK_ROLE_VIDEO,
            Role::Definition => ffi::ATK_ROLE_DEFINITION,
            Role::Article => ffi::ATK_ROLE_ARTICLE,
            Role::Landmark => ffi::ATK_ROLE_LANDMARK,
            Role::Log => ffi::ATK_ROLE_LOG,
            Role::Marquee => ffi::ATK_ROLE_MARQUEE,
            Role::Math => ffi::ATK_ROLE_MATH,
            Role::Rating => ffi::ATK_ROLE_RATING,
            Role::Timer => ffi::ATK_ROLE_TIMER,
            Role::DescriptionList => ffi::ATK_ROLE_DESCRIPTION_LIST,
            Role::DescriptionTerm => ffi::ATK_ROLE_DESCRIPTION_TERM,
            Role::DescriptionValue => ffi::ATK_ROLE_DESCRIPTION_VALUE,
            Role::Static => ffi::ATK_ROLE_STATIC,
            Role::MathFraction => ffi::ATK_ROLE_MATH_FRACTION,
            Role::MathRoot => ffi::ATK_ROLE_MATH_ROOT,
            Role::Subscript => ffi::ATK_ROLE_SUBSCRIPT,
            Role::Superscript => ffi::ATK_ROLE_SUPERSCRIPT,
            Role::Footnote => ffi::ATK_ROLE_FOOTNOTE,
            Role::ContentDeletion => ffi::ATK_ROLE_CONTENT_DELETION,
            Role::ContentInsertion => ffi::ATK_ROLE_CONTENT_INSERTION,
            Role::Mark => ffi::ATK_ROLE_MARK,
            Role::Suggestion => ffi::ATK_ROLE_SUGGESTION,
            Role::LastDefined => ffi::ATK_ROLE_LAST_DEFINED,
            Role::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkRole> for Role {
    unsafe fn from_glib(value: ffi::AtkRole) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Role::Invalid,
            1 => Role::AcceleratorLabel,
            2 => Role::Alert,
            3 => Role::Animation,
            4 => Role::Arrow,
            5 => Role::Calendar,
            6 => Role::Canvas,
            7 => Role::CheckBox,
            8 => Role::CheckMenuItem,
            9 => Role::ColorChooser,
            10 => Role::ColumnHeader,
            11 => Role::ComboBox,
            12 => Role::DateEditor,
            13 => Role::DesktopIcon,
            14 => Role::DesktopFrame,
            15 => Role::Dial,
            16 => Role::Dialog,
            17 => Role::DirectoryPane,
            18 => Role::DrawingArea,
            19 => Role::FileChooser,
            20 => Role::Filler,
            21 => Role::FontChooser,
            22 => Role::Frame,
            23 => Role::GlassPane,
            24 => Role::HtmlContainer,
            25 => Role::Icon,
            26 => Role::Image,
            27 => Role::InternalFrame,
            28 => Role::Label,
            29 => Role::LayeredPane,
            30 => Role::List,
            31 => Role::ListItem,
            32 => Role::Menu,
            33 => Role::MenuBar,
            34 => Role::MenuItem,
            35 => Role::OptionPane,
            36 => Role::PageTab,
            37 => Role::PageTabList,
            38 => Role::Panel,
            39 => Role::PasswordText,
            40 => Role::PopupMenu,
            41 => Role::ProgressBar,
            42 => Role::PushButton,
            43 => Role::RadioButton,
            44 => Role::RadioMenuItem,
            45 => Role::RootPane,
            46 => Role::RowHeader,
            47 => Role::ScrollBar,
            48 => Role::ScrollPane,
            49 => Role::Separator,
            50 => Role::Slider,
            51 => Role::SplitPane,
            52 => Role::SpinButton,
            53 => Role::Statusbar,
            54 => Role::Table,
            55 => Role::TableCell,
            56 => Role::TableColumnHeader,
            57 => Role::TableRowHeader,
            58 => Role::TearOffMenuItem,
            59 => Role::Terminal,
            60 => Role::Text,
            61 => Role::ToggleButton,
            62 => Role::ToolBar,
            63 => Role::ToolTip,
            64 => Role::Tree,
            65 => Role::TreeTable,
            66 => Role::Unknown,
            67 => Role::Viewport,
            68 => Role::Window,
            69 => Role::Header,
            70 => Role::Footer,
            71 => Role::Paragraph,
            72 => Role::Ruler,
            73 => Role::Application,
            74 => Role::Autocomplete,
            75 => Role::EditBar,
            76 => Role::Embedded,
            77 => Role::Entry,
            78 => Role::Chart,
            79 => Role::Caption,
            80 => Role::DocumentFrame,
            81 => Role::Heading,
            82 => Role::Page,
            83 => Role::Section,
            84 => Role::RedundantObject,
            85 => Role::Form,
            86 => Role::Link,
            87 => Role::InputMethodWindow,
            88 => Role::TableRow,
            89 => Role::TreeItem,
            90 => Role::DocumentSpreadsheet,
            91 => Role::DocumentPresentation,
            92 => Role::DocumentText,
            93 => Role::DocumentWeb,
            94 => Role::DocumentEmail,
            95 => Role::Comment,
            96 => Role::ListBox,
            97 => Role::Grouping,
            98 => Role::ImageMap,
            99 => Role::Notification,
            100 => Role::InfoBar,
            101 => Role::LevelBar,
            102 => Role::TitleBar,
            103 => Role::BlockQuote,
            104 => Role::Audio,
            105 => Role::Video,
            106 => Role::Definition,
            107 => Role::Article,
            108 => Role::Landmark,
            109 => Role::Log,
            110 => Role::Marquee,
            111 => Role::Math,
            112 => Role::Rating,
            113 => Role::Timer,
            114 => Role::DescriptionList,
            115 => Role::DescriptionTerm,
            116 => Role::DescriptionValue,
            117 => Role::Static,
            118 => Role::MathFraction,
            119 => Role::MathRoot,
            120 => Role::Subscript,
            121 => Role::Superscript,
            122 => Role::Footnote,
            123 => Role::ContentDeletion,
            124 => Role::ContentInsertion,
            125 => Role::Mark,
            126 => Role::Suggestion,
            127 => Role::LastDefined,
            value => Role::__Unknown(value),
        }
    }
}

impl StaticType for Role {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_role_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Role {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Role {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Role {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkScrollType")]
pub enum ScrollType {
    #[doc(alias = "ATK_SCROLL_TOP_LEFT")]
    TopLeft,
    #[doc(alias = "ATK_SCROLL_BOTTOM_RIGHT")]
    BottomRight,
    #[doc(alias = "ATK_SCROLL_TOP_EDGE")]
    TopEdge,
    #[doc(alias = "ATK_SCROLL_BOTTOM_EDGE")]
    BottomEdge,
    #[doc(alias = "ATK_SCROLL_LEFT_EDGE")]
    LeftEdge,
    #[doc(alias = "ATK_SCROLL_RIGHT_EDGE")]
    RightEdge,
    #[doc(alias = "ATK_SCROLL_ANYWHERE")]
    Anywhere,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl fmt::Display for ScrollType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ScrollType::{}",
            match *self {
                ScrollType::TopLeft => "TopLeft",
                ScrollType::BottomRight => "BottomRight",
                ScrollType::TopEdge => "TopEdge",
                ScrollType::BottomEdge => "BottomEdge",
                ScrollType::LeftEdge => "LeftEdge",
                ScrollType::RightEdge => "RightEdge",
                ScrollType::Anywhere => "Anywhere",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl ToGlib for ScrollType {
    type GlibType = ffi::AtkScrollType;

    fn to_glib(&self) -> ffi::AtkScrollType {
        match *self {
            ScrollType::TopLeft => ffi::ATK_SCROLL_TOP_LEFT,
            ScrollType::BottomRight => ffi::ATK_SCROLL_BOTTOM_RIGHT,
            ScrollType::TopEdge => ffi::ATK_SCROLL_TOP_EDGE,
            ScrollType::BottomEdge => ffi::ATK_SCROLL_BOTTOM_EDGE,
            ScrollType::LeftEdge => ffi::ATK_SCROLL_LEFT_EDGE,
            ScrollType::RightEdge => ffi::ATK_SCROLL_RIGHT_EDGE,
            ScrollType::Anywhere => ffi::ATK_SCROLL_ANYWHERE,
            ScrollType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl FromGlib<ffi::AtkScrollType> for ScrollType {
    unsafe fn from_glib(value: ffi::AtkScrollType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScrollType::TopLeft,
            1 => ScrollType::BottomRight,
            2 => ScrollType::TopEdge,
            3 => ScrollType::BottomEdge,
            4 => ScrollType::LeftEdge,
            5 => ScrollType::RightEdge,
            6 => ScrollType::Anywhere,
            value => ScrollType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl StaticType for ScrollType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_scroll_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl<'a> FromValueOptional<'a> for ScrollType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl<'a> FromValue<'a> for ScrollType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl SetValue for ScrollType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkStateType")]
pub enum StateType {
    #[doc(alias = "ATK_STATE_INVALID")]
    Invalid,
    #[doc(alias = "ATK_STATE_ACTIVE")]
    Active,
    #[doc(alias = "ATK_STATE_ARMED")]
    Armed,
    #[doc(alias = "ATK_STATE_BUSY")]
    Busy,
    #[doc(alias = "ATK_STATE_CHECKED")]
    Checked,
    #[doc(alias = "ATK_STATE_DEFUNCT")]
    Defunct,
    #[doc(alias = "ATK_STATE_EDITABLE")]
    Editable,
    #[doc(alias = "ATK_STATE_ENABLED")]
    Enabled,
    #[doc(alias = "ATK_STATE_EXPANDABLE")]
    Expandable,
    #[doc(alias = "ATK_STATE_EXPANDED")]
    Expanded,
    #[doc(alias = "ATK_STATE_FOCUSABLE")]
    Focusable,
    #[doc(alias = "ATK_STATE_FOCUSED")]
    Focused,
    #[doc(alias = "ATK_STATE_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "ATK_STATE_ICONIFIED")]
    Iconified,
    #[doc(alias = "ATK_STATE_MODAL")]
    Modal,
    #[doc(alias = "ATK_STATE_MULTI_LINE")]
    MultiLine,
    #[doc(alias = "ATK_STATE_MULTISELECTABLE")]
    Multiselectable,
    #[doc(alias = "ATK_STATE_OPAQUE")]
    Opaque,
    #[doc(alias = "ATK_STATE_PRESSED")]
    Pressed,
    #[doc(alias = "ATK_STATE_RESIZABLE")]
    Resizable,
    #[doc(alias = "ATK_STATE_SELECTABLE")]
    Selectable,
    #[doc(alias = "ATK_STATE_SELECTED")]
    Selected,
    #[doc(alias = "ATK_STATE_SENSITIVE")]
    Sensitive,
    #[doc(alias = "ATK_STATE_SHOWING")]
    Showing,
    #[doc(alias = "ATK_STATE_SINGLE_LINE")]
    SingleLine,
    #[doc(alias = "ATK_STATE_STALE")]
    Stale,
    #[doc(alias = "ATK_STATE_TRANSIENT")]
    Transient,
    #[doc(alias = "ATK_STATE_VERTICAL")]
    Vertical,
    #[doc(alias = "ATK_STATE_VISIBLE")]
    Visible,
    #[doc(alias = "ATK_STATE_MANAGES_DESCENDANTS")]
    ManagesDescendants,
    #[doc(alias = "ATK_STATE_INDETERMINATE")]
    Indeterminate,
    #[doc(alias = "ATK_STATE_TRUNCATED")]
    Truncated,
    #[doc(alias = "ATK_STATE_REQUIRED")]
    Required,
    #[doc(alias = "ATK_STATE_INVALID_ENTRY")]
    InvalidEntry,
    #[doc(alias = "ATK_STATE_SUPPORTS_AUTOCOMPLETION")]
    SupportsAutocompletion,
    #[doc(alias = "ATK_STATE_SELECTABLE_TEXT")]
    SelectableText,
    #[doc(alias = "ATK_STATE_DEFAULT")]
    Default,
    #[doc(alias = "ATK_STATE_ANIMATED")]
    Animated,
    #[doc(alias = "ATK_STATE_VISITED")]
    Visited,
    #[doc(alias = "ATK_STATE_CHECKABLE")]
    Checkable,
    #[doc(alias = "ATK_STATE_HAS_POPUP")]
    HasPopup,
    #[doc(alias = "ATK_STATE_HAS_TOOLTIP")]
    HasTooltip,
    #[doc(alias = "ATK_STATE_READ_ONLY")]
    ReadOnly,
    #[doc(alias = "ATK_STATE_LAST_DEFINED")]
    LastDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl StateType {
    #[doc(alias = "atk_state_type_for_name")]
    pub fn for_name(name: &str) -> StateType {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::atk_state_type_for_name(name.to_glib_none().0)) }
    }

    #[doc(alias = "atk_state_type_get_name")]
    pub fn get_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_state_type_get_name(self.to_glib())) }
    }
}

impl fmt::Display for StateType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StateType::{}",
            match *self {
                StateType::Invalid => "Invalid",
                StateType::Active => "Active",
                StateType::Armed => "Armed",
                StateType::Busy => "Busy",
                StateType::Checked => "Checked",
                StateType::Defunct => "Defunct",
                StateType::Editable => "Editable",
                StateType::Enabled => "Enabled",
                StateType::Expandable => "Expandable",
                StateType::Expanded => "Expanded",
                StateType::Focusable => "Focusable",
                StateType::Focused => "Focused",
                StateType::Horizontal => "Horizontal",
                StateType::Iconified => "Iconified",
                StateType::Modal => "Modal",
                StateType::MultiLine => "MultiLine",
                StateType::Multiselectable => "Multiselectable",
                StateType::Opaque => "Opaque",
                StateType::Pressed => "Pressed",
                StateType::Resizable => "Resizable",
                StateType::Selectable => "Selectable",
                StateType::Selected => "Selected",
                StateType::Sensitive => "Sensitive",
                StateType::Showing => "Showing",
                StateType::SingleLine => "SingleLine",
                StateType::Stale => "Stale",
                StateType::Transient => "Transient",
                StateType::Vertical => "Vertical",
                StateType::Visible => "Visible",
                StateType::ManagesDescendants => "ManagesDescendants",
                StateType::Indeterminate => "Indeterminate",
                StateType::Truncated => "Truncated",
                StateType::Required => "Required",
                StateType::InvalidEntry => "InvalidEntry",
                StateType::SupportsAutocompletion => "SupportsAutocompletion",
                StateType::SelectableText => "SelectableText",
                StateType::Default => "Default",
                StateType::Animated => "Animated",
                StateType::Visited => "Visited",
                StateType::Checkable => "Checkable",
                StateType::HasPopup => "HasPopup",
                StateType::HasTooltip => "HasTooltip",
                StateType::ReadOnly => "ReadOnly",
                StateType::LastDefined => "LastDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StateType {
    type GlibType = ffi::AtkStateType;

    fn to_glib(&self) -> ffi::AtkStateType {
        match *self {
            StateType::Invalid => ffi::ATK_STATE_INVALID,
            StateType::Active => ffi::ATK_STATE_ACTIVE,
            StateType::Armed => ffi::ATK_STATE_ARMED,
            StateType::Busy => ffi::ATK_STATE_BUSY,
            StateType::Checked => ffi::ATK_STATE_CHECKED,
            StateType::Defunct => ffi::ATK_STATE_DEFUNCT,
            StateType::Editable => ffi::ATK_STATE_EDITABLE,
            StateType::Enabled => ffi::ATK_STATE_ENABLED,
            StateType::Expandable => ffi::ATK_STATE_EXPANDABLE,
            StateType::Expanded => ffi::ATK_STATE_EXPANDED,
            StateType::Focusable => ffi::ATK_STATE_FOCUSABLE,
            StateType::Focused => ffi::ATK_STATE_FOCUSED,
            StateType::Horizontal => ffi::ATK_STATE_HORIZONTAL,
            StateType::Iconified => ffi::ATK_STATE_ICONIFIED,
            StateType::Modal => ffi::ATK_STATE_MODAL,
            StateType::MultiLine => ffi::ATK_STATE_MULTI_LINE,
            StateType::Multiselectable => ffi::ATK_STATE_MULTISELECTABLE,
            StateType::Opaque => ffi::ATK_STATE_OPAQUE,
            StateType::Pressed => ffi::ATK_STATE_PRESSED,
            StateType::Resizable => ffi::ATK_STATE_RESIZABLE,
            StateType::Selectable => ffi::ATK_STATE_SELECTABLE,
            StateType::Selected => ffi::ATK_STATE_SELECTED,
            StateType::Sensitive => ffi::ATK_STATE_SENSITIVE,
            StateType::Showing => ffi::ATK_STATE_SHOWING,
            StateType::SingleLine => ffi::ATK_STATE_SINGLE_LINE,
            StateType::Stale => ffi::ATK_STATE_STALE,
            StateType::Transient => ffi::ATK_STATE_TRANSIENT,
            StateType::Vertical => ffi::ATK_STATE_VERTICAL,
            StateType::Visible => ffi::ATK_STATE_VISIBLE,
            StateType::ManagesDescendants => ffi::ATK_STATE_MANAGES_DESCENDANTS,
            StateType::Indeterminate => ffi::ATK_STATE_INDETERMINATE,
            StateType::Truncated => ffi::ATK_STATE_TRUNCATED,
            StateType::Required => ffi::ATK_STATE_REQUIRED,
            StateType::InvalidEntry => ffi::ATK_STATE_INVALID_ENTRY,
            StateType::SupportsAutocompletion => ffi::ATK_STATE_SUPPORTS_AUTOCOMPLETION,
            StateType::SelectableText => ffi::ATK_STATE_SELECTABLE_TEXT,
            StateType::Default => ffi::ATK_STATE_DEFAULT,
            StateType::Animated => ffi::ATK_STATE_ANIMATED,
            StateType::Visited => ffi::ATK_STATE_VISITED,
            StateType::Checkable => ffi::ATK_STATE_CHECKABLE,
            StateType::HasPopup => ffi::ATK_STATE_HAS_POPUP,
            StateType::HasTooltip => ffi::ATK_STATE_HAS_TOOLTIP,
            StateType::ReadOnly => ffi::ATK_STATE_READ_ONLY,
            StateType::LastDefined => ffi::ATK_STATE_LAST_DEFINED,
            StateType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkStateType> for StateType {
    unsafe fn from_glib(value: ffi::AtkStateType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StateType::Invalid,
            1 => StateType::Active,
            2 => StateType::Armed,
            3 => StateType::Busy,
            4 => StateType::Checked,
            5 => StateType::Defunct,
            6 => StateType::Editable,
            7 => StateType::Enabled,
            8 => StateType::Expandable,
            9 => StateType::Expanded,
            10 => StateType::Focusable,
            11 => StateType::Focused,
            12 => StateType::Horizontal,
            13 => StateType::Iconified,
            14 => StateType::Modal,
            15 => StateType::MultiLine,
            16 => StateType::Multiselectable,
            17 => StateType::Opaque,
            18 => StateType::Pressed,
            19 => StateType::Resizable,
            20 => StateType::Selectable,
            21 => StateType::Selected,
            22 => StateType::Sensitive,
            23 => StateType::Showing,
            24 => StateType::SingleLine,
            25 => StateType::Stale,
            26 => StateType::Transient,
            27 => StateType::Vertical,
            28 => StateType::Visible,
            29 => StateType::ManagesDescendants,
            30 => StateType::Indeterminate,
            31 => StateType::Truncated,
            32 => StateType::Required,
            33 => StateType::InvalidEntry,
            34 => StateType::SupportsAutocompletion,
            35 => StateType::SelectableText,
            36 => StateType::Default,
            37 => StateType::Animated,
            38 => StateType::Visited,
            39 => StateType::Checkable,
            40 => StateType::HasPopup,
            41 => StateType::HasTooltip,
            42 => StateType::ReadOnly,
            43 => StateType::LastDefined,
            value => StateType::__Unknown(value),
        }
    }
}

impl StaticType for StateType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_state_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StateType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StateType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StateType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkTextAttribute")]
pub enum TextAttribute {
    #[doc(alias = "ATK_TEXT_ATTR_INVALID")]
    Invalid,
    #[doc(alias = "ATK_TEXT_ATTR_LEFT_MARGIN")]
    LeftMargin,
    #[doc(alias = "ATK_TEXT_ATTR_RIGHT_MARGIN")]
    RightMargin,
    #[doc(alias = "ATK_TEXT_ATTR_INDENT")]
    Indent,
    #[doc(alias = "ATK_TEXT_ATTR_INVISIBLE")]
    Invisible,
    #[doc(alias = "ATK_TEXT_ATTR_EDITABLE")]
    Editable,
    #[doc(alias = "ATK_TEXT_ATTR_PIXELS_ABOVE_LINES")]
    PixelsAboveLines,
    #[doc(alias = "ATK_TEXT_ATTR_PIXELS_BELOW_LINES")]
    PixelsBelowLines,
    #[doc(alias = "ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP")]
    PixelsInsideWrap,
    #[doc(alias = "ATK_TEXT_ATTR_BG_FULL_HEIGHT")]
    BgFullHeight,
    #[doc(alias = "ATK_TEXT_ATTR_RISE")]
    Rise,
    #[doc(alias = "ATK_TEXT_ATTR_UNDERLINE")]
    Underline,
    #[doc(alias = "ATK_TEXT_ATTR_STRIKETHROUGH")]
    Strikethrough,
    #[doc(alias = "ATK_TEXT_ATTR_SIZE")]
    Size,
    #[doc(alias = "ATK_TEXT_ATTR_SCALE")]
    Scale,
    #[doc(alias = "ATK_TEXT_ATTR_WEIGHT")]
    Weight,
    #[doc(alias = "ATK_TEXT_ATTR_LANGUAGE")]
    Language,
    #[doc(alias = "ATK_TEXT_ATTR_FAMILY_NAME")]
    FamilyName,
    #[doc(alias = "ATK_TEXT_ATTR_BG_COLOR")]
    BgColor,
    #[doc(alias = "ATK_TEXT_ATTR_FG_COLOR")]
    FgColor,
    #[doc(alias = "ATK_TEXT_ATTR_BG_STIPPLE")]
    BgStipple,
    #[doc(alias = "ATK_TEXT_ATTR_FG_STIPPLE")]
    FgStipple,
    #[doc(alias = "ATK_TEXT_ATTR_WRAP_MODE")]
    WrapMode,
    #[doc(alias = "ATK_TEXT_ATTR_DIRECTION")]
    Direction,
    #[doc(alias = "ATK_TEXT_ATTR_JUSTIFICATION")]
    Justification,
    #[doc(alias = "ATK_TEXT_ATTR_STRETCH")]
    Stretch,
    #[doc(alias = "ATK_TEXT_ATTR_VARIANT")]
    Variant,
    #[doc(alias = "ATK_TEXT_ATTR_STYLE")]
    Style,
    #[doc(alias = "ATK_TEXT_ATTR_TEXT_POSITION")]
    TextPosition,
    #[doc(alias = "ATK_TEXT_ATTR_LAST_DEFINED")]
    LastDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl TextAttribute {
    #[doc(alias = "atk_text_attribute_for_name")]
    pub fn for_name(name: &str) -> TextAttribute {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::atk_text_attribute_for_name(name.to_glib_none().0)) }
    }

    #[doc(alias = "atk_text_attribute_get_name")]
    pub fn get_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_text_attribute_get_name(self.to_glib())) }
    }

    #[doc(alias = "atk_text_attribute_get_value")]
    pub fn get_value(self, index_: i32) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_text_attribute_get_value(self.to_glib(), index_)) }
    }
}

impl fmt::Display for TextAttribute {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextAttribute::{}",
            match *self {
                TextAttribute::Invalid => "Invalid",
                TextAttribute::LeftMargin => "LeftMargin",
                TextAttribute::RightMargin => "RightMargin",
                TextAttribute::Indent => "Indent",
                TextAttribute::Invisible => "Invisible",
                TextAttribute::Editable => "Editable",
                TextAttribute::PixelsAboveLines => "PixelsAboveLines",
                TextAttribute::PixelsBelowLines => "PixelsBelowLines",
                TextAttribute::PixelsInsideWrap => "PixelsInsideWrap",
                TextAttribute::BgFullHeight => "BgFullHeight",
                TextAttribute::Rise => "Rise",
                TextAttribute::Underline => "Underline",
                TextAttribute::Strikethrough => "Strikethrough",
                TextAttribute::Size => "Size",
                TextAttribute::Scale => "Scale",
                TextAttribute::Weight => "Weight",
                TextAttribute::Language => "Language",
                TextAttribute::FamilyName => "FamilyName",
                TextAttribute::BgColor => "BgColor",
                TextAttribute::FgColor => "FgColor",
                TextAttribute::BgStipple => "BgStipple",
                TextAttribute::FgStipple => "FgStipple",
                TextAttribute::WrapMode => "WrapMode",
                TextAttribute::Direction => "Direction",
                TextAttribute::Justification => "Justification",
                TextAttribute::Stretch => "Stretch",
                TextAttribute::Variant => "Variant",
                TextAttribute::Style => "Style",
                TextAttribute::TextPosition => "TextPosition",
                TextAttribute::LastDefined => "LastDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextAttribute {
    type GlibType = ffi::AtkTextAttribute;

    fn to_glib(&self) -> ffi::AtkTextAttribute {
        match *self {
            TextAttribute::Invalid => ffi::ATK_TEXT_ATTR_INVALID,
            TextAttribute::LeftMargin => ffi::ATK_TEXT_ATTR_LEFT_MARGIN,
            TextAttribute::RightMargin => ffi::ATK_TEXT_ATTR_RIGHT_MARGIN,
            TextAttribute::Indent => ffi::ATK_TEXT_ATTR_INDENT,
            TextAttribute::Invisible => ffi::ATK_TEXT_ATTR_INVISIBLE,
            TextAttribute::Editable => ffi::ATK_TEXT_ATTR_EDITABLE,
            TextAttribute::PixelsAboveLines => ffi::ATK_TEXT_ATTR_PIXELS_ABOVE_LINES,
            TextAttribute::PixelsBelowLines => ffi::ATK_TEXT_ATTR_PIXELS_BELOW_LINES,
            TextAttribute::PixelsInsideWrap => ffi::ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP,
            TextAttribute::BgFullHeight => ffi::ATK_TEXT_ATTR_BG_FULL_HEIGHT,
            TextAttribute::Rise => ffi::ATK_TEXT_ATTR_RISE,
            TextAttribute::Underline => ffi::ATK_TEXT_ATTR_UNDERLINE,
            TextAttribute::Strikethrough => ffi::ATK_TEXT_ATTR_STRIKETHROUGH,
            TextAttribute::Size => ffi::ATK_TEXT_ATTR_SIZE,
            TextAttribute::Scale => ffi::ATK_TEXT_ATTR_SCALE,
            TextAttribute::Weight => ffi::ATK_TEXT_ATTR_WEIGHT,
            TextAttribute::Language => ffi::ATK_TEXT_ATTR_LANGUAGE,
            TextAttribute::FamilyName => ffi::ATK_TEXT_ATTR_FAMILY_NAME,
            TextAttribute::BgColor => ffi::ATK_TEXT_ATTR_BG_COLOR,
            TextAttribute::FgColor => ffi::ATK_TEXT_ATTR_FG_COLOR,
            TextAttribute::BgStipple => ffi::ATK_TEXT_ATTR_BG_STIPPLE,
            TextAttribute::FgStipple => ffi::ATK_TEXT_ATTR_FG_STIPPLE,
            TextAttribute::WrapMode => ffi::ATK_TEXT_ATTR_WRAP_MODE,
            TextAttribute::Direction => ffi::ATK_TEXT_ATTR_DIRECTION,
            TextAttribute::Justification => ffi::ATK_TEXT_ATTR_JUSTIFICATION,
            TextAttribute::Stretch => ffi::ATK_TEXT_ATTR_STRETCH,
            TextAttribute::Variant => ffi::ATK_TEXT_ATTR_VARIANT,
            TextAttribute::Style => ffi::ATK_TEXT_ATTR_STYLE,
            TextAttribute::TextPosition => ffi::ATK_TEXT_ATTR_TEXT_POSITION,
            TextAttribute::LastDefined => ffi::ATK_TEXT_ATTR_LAST_DEFINED,
            TextAttribute::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkTextAttribute> for TextAttribute {
    unsafe fn from_glib(value: ffi::AtkTextAttribute) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextAttribute::Invalid,
            1 => TextAttribute::LeftMargin,
            2 => TextAttribute::RightMargin,
            3 => TextAttribute::Indent,
            4 => TextAttribute::Invisible,
            5 => TextAttribute::Editable,
            6 => TextAttribute::PixelsAboveLines,
            7 => TextAttribute::PixelsBelowLines,
            8 => TextAttribute::PixelsInsideWrap,
            9 => TextAttribute::BgFullHeight,
            10 => TextAttribute::Rise,
            11 => TextAttribute::Underline,
            12 => TextAttribute::Strikethrough,
            13 => TextAttribute::Size,
            14 => TextAttribute::Scale,
            15 => TextAttribute::Weight,
            16 => TextAttribute::Language,
            17 => TextAttribute::FamilyName,
            18 => TextAttribute::BgColor,
            19 => TextAttribute::FgColor,
            20 => TextAttribute::BgStipple,
            21 => TextAttribute::FgStipple,
            22 => TextAttribute::WrapMode,
            23 => TextAttribute::Direction,
            24 => TextAttribute::Justification,
            25 => TextAttribute::Stretch,
            26 => TextAttribute::Variant,
            27 => TextAttribute::Style,
            28 => TextAttribute::TextPosition,
            29 => TextAttribute::LastDefined,
            value => TextAttribute::__Unknown(value),
        }
    }
}

impl StaticType for TextAttribute {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_text_attribute_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextAttribute {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextAttribute {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextAttribute {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkTextBoundary")]
pub enum TextBoundary {
    #[doc(alias = "ATK_TEXT_BOUNDARY_CHAR")]
    Char,
    #[doc(alias = "ATK_TEXT_BOUNDARY_WORD_START")]
    WordStart,
    #[doc(alias = "ATK_TEXT_BOUNDARY_WORD_END")]
    WordEnd,
    #[doc(alias = "ATK_TEXT_BOUNDARY_SENTENCE_START")]
    SentenceStart,
    #[doc(alias = "ATK_TEXT_BOUNDARY_SENTENCE_END")]
    SentenceEnd,
    #[doc(alias = "ATK_TEXT_BOUNDARY_LINE_START")]
    LineStart,
    #[doc(alias = "ATK_TEXT_BOUNDARY_LINE_END")]
    LineEnd,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextBoundary {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextBoundary::{}",
            match *self {
                TextBoundary::Char => "Char",
                TextBoundary::WordStart => "WordStart",
                TextBoundary::WordEnd => "WordEnd",
                TextBoundary::SentenceStart => "SentenceStart",
                TextBoundary::SentenceEnd => "SentenceEnd",
                TextBoundary::LineStart => "LineStart",
                TextBoundary::LineEnd => "LineEnd",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextBoundary {
    type GlibType = ffi::AtkTextBoundary;

    fn to_glib(&self) -> ffi::AtkTextBoundary {
        match *self {
            TextBoundary::Char => ffi::ATK_TEXT_BOUNDARY_CHAR,
            TextBoundary::WordStart => ffi::ATK_TEXT_BOUNDARY_WORD_START,
            TextBoundary::WordEnd => ffi::ATK_TEXT_BOUNDARY_WORD_END,
            TextBoundary::SentenceStart => ffi::ATK_TEXT_BOUNDARY_SENTENCE_START,
            TextBoundary::SentenceEnd => ffi::ATK_TEXT_BOUNDARY_SENTENCE_END,
            TextBoundary::LineStart => ffi::ATK_TEXT_BOUNDARY_LINE_START,
            TextBoundary::LineEnd => ffi::ATK_TEXT_BOUNDARY_LINE_END,
            TextBoundary::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkTextBoundary> for TextBoundary {
    unsafe fn from_glib(value: ffi::AtkTextBoundary) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextBoundary::Char,
            1 => TextBoundary::WordStart,
            2 => TextBoundary::WordEnd,
            3 => TextBoundary::SentenceStart,
            4 => TextBoundary::SentenceEnd,
            5 => TextBoundary::LineStart,
            6 => TextBoundary::LineEnd,
            value => TextBoundary::__Unknown(value),
        }
    }
}

impl StaticType for TextBoundary {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_text_boundary_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextBoundary {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextBoundary {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextBoundary {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkTextClipType")]
pub enum TextClipType {
    #[doc(alias = "ATK_TEXT_CLIP_NONE")]
    None,
    #[doc(alias = "ATK_TEXT_CLIP_MIN")]
    Min,
    #[doc(alias = "ATK_TEXT_CLIP_MAX")]
    Max,
    #[doc(alias = "ATK_TEXT_CLIP_BOTH")]
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextClipType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextClipType::{}",
            match *self {
                TextClipType::None => "None",
                TextClipType::Min => "Min",
                TextClipType::Max => "Max",
                TextClipType::Both => "Both",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextClipType {
    type GlibType = ffi::AtkTextClipType;

    fn to_glib(&self) -> ffi::AtkTextClipType {
        match *self {
            TextClipType::None => ffi::ATK_TEXT_CLIP_NONE,
            TextClipType::Min => ffi::ATK_TEXT_CLIP_MIN,
            TextClipType::Max => ffi::ATK_TEXT_CLIP_MAX,
            TextClipType::Both => ffi::ATK_TEXT_CLIP_BOTH,
            TextClipType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkTextClipType> for TextClipType {
    unsafe fn from_glib(value: ffi::AtkTextClipType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextClipType::None,
            1 => TextClipType::Min,
            2 => TextClipType::Max,
            3 => TextClipType::Both,
            value => TextClipType::__Unknown(value),
        }
    }
}

impl StaticType for TextClipType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_text_clip_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextClipType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextClipType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextClipType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkTextGranularity")]
pub enum TextGranularity {
    #[doc(alias = "ATK_TEXT_GRANULARITY_CHAR")]
    Char,
    #[doc(alias = "ATK_TEXT_GRANULARITY_WORD")]
    Word,
    #[doc(alias = "ATK_TEXT_GRANULARITY_SENTENCE")]
    Sentence,
    #[doc(alias = "ATK_TEXT_GRANULARITY_LINE")]
    Line,
    #[doc(alias = "ATK_TEXT_GRANULARITY_PARAGRAPH")]
    Paragraph,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextGranularity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextGranularity::{}",
            match *self {
                TextGranularity::Char => "Char",
                TextGranularity::Word => "Word",
                TextGranularity::Sentence => "Sentence",
                TextGranularity::Line => "Line",
                TextGranularity::Paragraph => "Paragraph",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextGranularity {
    type GlibType = ffi::AtkTextGranularity;

    fn to_glib(&self) -> ffi::AtkTextGranularity {
        match *self {
            TextGranularity::Char => ffi::ATK_TEXT_GRANULARITY_CHAR,
            TextGranularity::Word => ffi::ATK_TEXT_GRANULARITY_WORD,
            TextGranularity::Sentence => ffi::ATK_TEXT_GRANULARITY_SENTENCE,
            TextGranularity::Line => ffi::ATK_TEXT_GRANULARITY_LINE,
            TextGranularity::Paragraph => ffi::ATK_TEXT_GRANULARITY_PARAGRAPH,
            TextGranularity::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkTextGranularity> for TextGranularity {
    unsafe fn from_glib(value: ffi::AtkTextGranularity) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextGranularity::Char,
            1 => TextGranularity::Word,
            2 => TextGranularity::Sentence,
            3 => TextGranularity::Line,
            4 => TextGranularity::Paragraph,
            value => TextGranularity::__Unknown(value),
        }
    }
}

impl StaticType for TextGranularity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_text_granularity_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextGranularity {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextGranularity {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextGranularity {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AtkValueType")]
pub enum ValueType {
    #[doc(alias = "ATK_VALUE_VERY_WEAK")]
    VeryWeak,
    #[doc(alias = "ATK_VALUE_WEAK")]
    Weak,
    #[doc(alias = "ATK_VALUE_ACCEPTABLE")]
    Acceptable,
    #[doc(alias = "ATK_VALUE_STRONG")]
    Strong,
    #[doc(alias = "ATK_VALUE_VERY_STRONG")]
    VeryStrong,
    #[doc(alias = "ATK_VALUE_VERY_LOW")]
    VeryLow,
    #[doc(alias = "ATK_VALUE_LOW")]
    Low,
    #[doc(alias = "ATK_VALUE_MEDIUM")]
    Medium,
    #[doc(alias = "ATK_VALUE_HIGH")]
    High,
    #[doc(alias = "ATK_VALUE_VERY_HIGH")]
    VeryHigh,
    #[doc(alias = "ATK_VALUE_VERY_BAD")]
    VeryBad,
    #[doc(alias = "ATK_VALUE_BAD")]
    Bad,
    #[doc(alias = "ATK_VALUE_GOOD")]
    Good,
    #[doc(alias = "ATK_VALUE_VERY_GOOD")]
    VeryGood,
    #[doc(alias = "ATK_VALUE_BEST")]
    Best,
    #[doc(alias = "ATK_VALUE_LAST_DEFINED")]
    LastDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

impl ValueType {
    #[doc(alias = "atk_value_type_get_localized_name")]
    pub fn get_localized_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_value_type_get_localized_name(self.to_glib())) }
    }

    #[doc(alias = "atk_value_type_get_name")]
    pub fn get_name(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::atk_value_type_get_name(self.to_glib())) }
    }
}

impl fmt::Display for ValueType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ValueType::{}",
            match *self {
                ValueType::VeryWeak => "VeryWeak",
                ValueType::Weak => "Weak",
                ValueType::Acceptable => "Acceptable",
                ValueType::Strong => "Strong",
                ValueType::VeryStrong => "VeryStrong",
                ValueType::VeryLow => "VeryLow",
                ValueType::Low => "Low",
                ValueType::Medium => "Medium",
                ValueType::High => "High",
                ValueType::VeryHigh => "VeryHigh",
                ValueType::VeryBad => "VeryBad",
                ValueType::Bad => "Bad",
                ValueType::Good => "Good",
                ValueType::VeryGood => "VeryGood",
                ValueType::Best => "Best",
                ValueType::LastDefined => "LastDefined",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ValueType {
    type GlibType = ffi::AtkValueType;

    fn to_glib(&self) -> ffi::AtkValueType {
        match *self {
            ValueType::VeryWeak => ffi::ATK_VALUE_VERY_WEAK,
            ValueType::Weak => ffi::ATK_VALUE_WEAK,
            ValueType::Acceptable => ffi::ATK_VALUE_ACCEPTABLE,
            ValueType::Strong => ffi::ATK_VALUE_STRONG,
            ValueType::VeryStrong => ffi::ATK_VALUE_VERY_STRONG,
            ValueType::VeryLow => ffi::ATK_VALUE_VERY_LOW,
            ValueType::Low => ffi::ATK_VALUE_LOW,
            ValueType::Medium => ffi::ATK_VALUE_MEDIUM,
            ValueType::High => ffi::ATK_VALUE_HIGH,
            ValueType::VeryHigh => ffi::ATK_VALUE_VERY_HIGH,
            ValueType::VeryBad => ffi::ATK_VALUE_VERY_BAD,
            ValueType::Bad => ffi::ATK_VALUE_BAD,
            ValueType::Good => ffi::ATK_VALUE_GOOD,
            ValueType::VeryGood => ffi::ATK_VALUE_VERY_GOOD,
            ValueType::Best => ffi::ATK_VALUE_BEST,
            ValueType::LastDefined => ffi::ATK_VALUE_LAST_DEFINED,
            ValueType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AtkValueType> for ValueType {
    unsafe fn from_glib(value: ffi::AtkValueType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ValueType::VeryWeak,
            1 => ValueType::Weak,
            2 => ValueType::Acceptable,
            3 => ValueType::Strong,
            4 => ValueType::VeryStrong,
            5 => ValueType::VeryLow,
            6 => ValueType::Low,
            7 => ValueType::Medium,
            8 => ValueType::High,
            9 => ValueType::VeryHigh,
            10 => ValueType::VeryBad,
            11 => ValueType::Bad,
            12 => ValueType::Good,
            13 => ValueType::VeryGood,
            14 => ValueType::Best,
            15 => ValueType::LastDefined,
            value => ValueType::__Unknown(value),
        }
    }
}

impl StaticType for ValueType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::atk_value_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ValueType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ValueType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ValueType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
