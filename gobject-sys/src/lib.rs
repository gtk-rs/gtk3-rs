// This file was generated by gir (b91816f) from gir-files (71d73f0)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

pub const G_TYPE_INVALID: GType = 0 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_NONE: GType = 1 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INTERFACE: GType = 2 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_CHAR: GType = 3 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UCHAR: GType = 4 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_BOOLEAN: GType = 5 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INT: GType = 6 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UINT: GType = 7 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_LONG: GType = 8 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_ULONG: GType = 9 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INT64: GType = 10 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_UINT64: GType = 11 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_ENUM: GType = 12 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_FLAGS: GType = 13 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_FLOAT: GType = 14 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_DOUBLE: GType = 15 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_STRING: GType = 16 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_POINTER: GType = 17 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_BOXED: GType = 18 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_PARAM: GType = 19 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_OBJECT: GType = 20 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_VARIANT: GType = 21 << G_TYPE_FUNDAMENTAL_SHIFT;

// Aliases
pub type GSignalCMarshaller = GClosureMarshal;
//pub type GSignalCVaMarshaller = /*Ignored*/GVaClosureMarshal;

// Constants
pub const G_PARAM_MASK: i32 = 255;
pub const G_PARAM_STATIC_STRINGS: i32 = 0;
pub const G_PARAM_USER_SHIFT: i32 = 8;
pub const G_SIGNAL_FLAGS_MASK: i32 = 511;
pub const G_SIGNAL_MATCH_MASK: i32 = 63;
//pub const G_TYPE_FLAG_RESERVED_ID_BIT: /*Ignored*/glib::Type = 1;
pub const G_TYPE_FUNDAMENTAL_MAX: i32 = 255;
pub const G_TYPE_FUNDAMENTAL_SHIFT: i32 = 2;
pub const G_TYPE_RESERVED_BSE_FIRST: i32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: i32 = 48;
pub const G_TYPE_RESERVED_GLIB_FIRST: i32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: i32 = 31;
pub const G_TYPE_RESERVED_USER_FIRST: i32 = 49;
pub const G_VALUE_COLLECT_FORMAT_MAX_LENGTH: i32 = 8;
pub const G_VALUE_NOCOPY_CONTENTS: i32 = 134217728;

// Flags
bitflags! {
    #[repr(C)]
    flags GBindingFlags: c_uint {
        const G_BINDING_DEFAULT = 0,
        const G_BINDING_BIDIRECTIONAL = 1,
        const G_BINDING_SYNC_CREATE = 2,
        const G_BINDING_INVERT_BOOLEAN = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GConnectFlags: c_uint {
        const G_CONNECT_AFTER = 1,
        const G_CONNECT_SWAPPED = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GParamFlags: c_uint {
        const G_PARAM_READABLE = 1,
        const G_PARAM_WRITABLE = 2,
        const G_PARAM_READWRITE = 3,
        const G_PARAM_CONSTRUCT = 4,
        const G_PARAM_CONSTRUCT_ONLY = 8,
        const G_PARAM_LAX_VALIDATION = 16,
        const G_PARAM_STATIC_NAME = 32,
        const G_PARAM_PRIVATE = 32,
        const G_PARAM_STATIC_NICK = 64,
        const G_PARAM_STATIC_BLURB = 128,
        const G_PARAM_EXPLICIT_NOTIFY = 1073741824,
        const G_PARAM_DEPRECATED = 2147483648,
    }
}

bitflags! {
    #[repr(C)]
    flags GSignalFlags: c_uint {
        const G_SIGNAL_RUN_FIRST = 1,
        const G_SIGNAL_RUN_LAST = 2,
        const G_SIGNAL_RUN_CLEANUP = 4,
        const G_SIGNAL_NO_RECURSE = 8,
        const G_SIGNAL_DETAILED = 16,
        const G_SIGNAL_ACTION = 32,
        const G_SIGNAL_NO_HOOKS = 64,
        const G_SIGNAL_MUST_COLLECT = 128,
        const G_SIGNAL_DEPRECATED = 256,
    }
}

bitflags! {
    #[repr(C)]
    flags GSignalMatchType: c_uint {
        const G_SIGNAL_MATCH_ID = 1,
        const G_SIGNAL_MATCH_DETAIL = 2,
        const G_SIGNAL_MATCH_CLOSURE = 4,
        const G_SIGNAL_MATCH_FUNC = 8,
        const G_SIGNAL_MATCH_DATA = 16,
        const G_SIGNAL_MATCH_UNBLOCKED = 32,
    }
}

bitflags! {
    #[repr(C)]
    flags GTypeDebugFlags: c_uint {
        const G_TYPE_DEBUG_NONE = 0,
        const G_TYPE_DEBUG_OBJECTS = 1,
        const G_TYPE_DEBUG_SIGNALS = 2,
        const G_TYPE_DEBUG_INSTANCE_COUNT = 4,
        const G_TYPE_DEBUG_MASK = 7,
    }
}

bitflags! {
    #[repr(C)]
    flags GTypeFlags: c_uint {
        const G_TYPE_FLAG_ABSTRACT = 16,
        const G_TYPE_FLAG_VALUE_ABSTRACT = 32,
    }
}

bitflags! {
    #[repr(C)]
    flags GTypeFundamentalFlags: c_uint {
        const G_TYPE_FLAG_CLASSED = 1,
        const G_TYPE_FLAG_INSTANTIATABLE = 2,
        const G_TYPE_FLAG_DERIVABLE = 4,
        const G_TYPE_FLAG_DEEP_DERIVABLE = 8,
    }
}

// Unions
pub type GTypeCValue = c_void; // union

// Callbacks
pub type GBaseFinalizeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GBaseInitFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GBindingTransformFunc = Option<unsafe extern "C" fn(*mut GBinding, *const GValue, *mut GValue, gpointer) -> gboolean>;
pub type GBoxedCopyFunc = Option<unsafe extern "C" fn(gpointer) -> gpointer>;
pub type GBoxedFreeFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GCallback = Option<unsafe extern "C" fn()>;
pub type GClassFinalizeFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GClassInitFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GClosureMarshal = Option<unsafe extern "C" fn(*mut GClosure, *mut GValue, c_uint, *mut GValue, gpointer, gpointer)>;
pub type GClosureNotify = Option<unsafe extern "C" fn(gpointer, *mut GClosure)>;
pub type GInstanceInitFunc = Option<unsafe extern "C" fn(*mut GTypeInstance, gpointer)>;
pub type GInterfaceFinalizeFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GInterfaceInitFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GObjectFinalizeFunc = Option<unsafe extern "C" fn(*mut GObject)>;
pub type GObjectGetPropertyFunc = Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>;
pub type GObjectSetPropertyFunc = Option<unsafe extern "C" fn(*mut GObject, c_uint, *const GValue, *mut GParamSpec)>;
pub type GSignalAccumulator = Option<unsafe extern "C" fn(*mut GSignalInvocationHint, *mut GValue, *const GValue, gpointer) -> gboolean>;
pub type GSignalEmissionHook = Option<unsafe extern "C" fn(*mut GSignalInvocationHint, c_uint, *mut GValue, gpointer) -> gboolean>;
pub type GToggleNotify = Option<unsafe extern "C" fn(gpointer, *mut GObject, gboolean)>;
pub type GTypeClassCacheFunc = Option<unsafe extern "C" fn(gpointer, *mut GTypeClass) -> gboolean>;
pub type GTypeInterfaceCheckFunc = Option<unsafe extern "C" fn(gpointer, gpointer)>;
pub type GTypePluginCompleteInterfaceInfo = Option<unsafe extern "C" fn(*mut GTypePlugin, GType, GType, *mut GInterfaceInfo)>;
pub type GTypePluginCompleteTypeInfo = Option<unsafe extern "C" fn(*mut GTypePlugin, GType, *mut GTypeInfo, *mut GTypeValueTable)>;
pub type GTypePluginUnuse = Option<unsafe extern "C" fn(*mut GTypePlugin)>;
pub type GTypePluginUse = Option<unsafe extern "C" fn(*mut GTypePlugin)>;
//pub type GVaClosureMarshal = Option<unsafe extern "C" fn(*mut GClosure, *mut GValue, gpointer, /*Unimplemented*/va_list, gpointer, c_int, *mut GType)>;
pub type GValueTransform = Option<unsafe extern "C" fn(*const GValue, *mut GValue)>;
pub type GWeakNotify = Option<unsafe extern "C" fn(gpointer, *mut GObject)>;

// Records
#[repr(C)]
pub struct GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}

#[repr(C)]
pub struct GClosure {
    _truncated_record_marker: c_void,
    //ref_count: volatile guint: 15,
    //meta_marshal_nouse: volatile guint: 1,
    //n_guards: volatile guint: 1,
    //n_fnotifiers: volatile guint: 2,
    //n_inotifiers: volatile guint: 8,
    //in_inotify: volatile guint: 1,
    //floating: volatile guint: 1,
    //derivative_flag: volatile guint: 1,
    //in_marshal: volatile guint: 1,
    //is_invalid: volatile guint: 1,
    //marshal: fn,
    //data: gpointer,
    //notifiers: GClosureNotifyData*,
}

#[repr(C)]
pub struct GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}

#[repr(C)]
pub struct GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: c_int,
    pub maximum: c_int,
    pub n_values: c_uint,
    pub values: *mut GEnumValue,
}

#[repr(C)]
pub struct GEnumValue {
    pub value: c_int,
    pub value_name: *const c_char,
    pub value_nick: *const c_char,
}

#[repr(C)]
pub struct GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: c_uint,
    pub n_values: c_uint,
    pub values: *mut GFlagsValue,
}

#[repr(C)]
pub struct GFlagsValue {
    pub value: c_uint,
    pub value_name: *const c_char,
    pub value_nick: *const c_char,
}

#[repr(C)]
pub struct GInitiallyUnownedClass {
    pub g_type_class: GTypeClass,
    construct_properties: *mut glib::GSList,
    pub constructor: Option<unsafe extern "C" fn(GType, c_uint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub get_property: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<unsafe extern "C" fn(*mut GObject)>,
    pub finalize: Option<unsafe extern "C" fn(*mut GObject)>,
    pub dispatch_properties_changed: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut *mut GParamSpec)>,
    pub notify: Option<unsafe extern "C" fn(*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<unsafe extern "C" fn(*mut GObject)>,
    flags: size_t,
    pdummy: [gpointer; 6],
}

#[repr(C)]
pub struct GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}

#[repr(C)]
pub struct GObjectClass {
    pub g_type_class: GTypeClass,
    construct_properties: *mut glib::GSList,
    pub constructor: Option<unsafe extern "C" fn(GType, c_uint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub get_property: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<unsafe extern "C" fn(*mut GObject)>,
    pub finalize: Option<unsafe extern "C" fn(*mut GObject)>,
    pub dispatch_properties_changed: Option<unsafe extern "C" fn(*mut GObject, c_uint, *mut *mut GParamSpec)>,
    pub notify: Option<unsafe extern "C" fn(*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<unsafe extern "C" fn(*mut GObject)>,
    flags: size_t,
    pdummy: [gpointer; 6],
}

#[repr(C)]
pub struct GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}

#[repr(C)]
pub struct GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_set_default: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp: Option<unsafe extern "C" fn(*mut GParamSpec, *const GValue, *const GValue) -> c_int>,
    dummy: [gpointer; 4],
}

#[repr(C)]
pub struct GParamSpecPool(c_void);

#[repr(C)]
pub struct GParamSpecTypeInfo {
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: Option<unsafe extern "C" fn(*mut GParamSpec)>,
    pub value_set_default: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<unsafe extern "C" fn(*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp: Option<unsafe extern "C" fn(*mut GParamSpec, *const GValue, *const GValue) -> c_int>,
}

#[repr(C)]
pub struct GParameter {
    pub name: *const c_char,
    pub value: GValue,
}

#[repr(C)]
pub struct GSignalInvocationHint {
    pub signal_id: c_uint,
    pub detail: glib::GQuark,
    pub run_type: GSignalFlags,
}

#[repr(C)]
pub struct GSignalQuery {
    pub signal_id: c_uint,
    pub signal_name: *const c_char,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: c_uint,
    pub param_types: *mut GType,
}

#[repr(C)]
pub struct GTypeClass {
    g_type: GType,
}

#[repr(C)]
pub struct GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}

#[repr(C)]
pub struct GTypeInfo {
    pub class_size: u16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}

#[repr(C)]
pub struct GTypeInstance {
    g_class: *mut GTypeClass,
}

#[repr(C)]
pub struct GTypeInterface {
    g_type: GType,
    g_instance_type: GType,
}

#[repr(C)]
pub struct GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: Option<unsafe extern "C" fn(*mut GTypeModule) -> gboolean>,
    pub unload: Option<unsafe extern "C" fn(*mut GTypeModule)>,
    pub reserved1: Option<unsafe extern "C" fn()>,
    pub reserved2: Option<unsafe extern "C" fn()>,
    pub reserved3: Option<unsafe extern "C" fn()>,
    pub reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GTypePluginClass {
    base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}

#[repr(C)]
pub struct GTypeQuery {
    pub type_: GType,
    pub type_name: *const c_char,
    pub class_size: c_uint,
    pub instance_size: c_uint,
}

#[repr(C)]
pub struct GTypeValueTable {
    pub value_init: Option<unsafe extern "C" fn(*mut GValue)>,
    pub value_free: Option<unsafe extern "C" fn(*mut GValue)>,
    pub value_copy: Option<unsafe extern "C" fn(*const GValue, *mut GValue)>,
    pub value_peek_pointer: Option<unsafe extern "C" fn(*const GValue) -> gpointer>,
    pub collect_format: *const c_char,
    pub collect_value: Option<unsafe extern "C" fn(*const GValue, c_uint, *mut GTypeCValue, c_uint) -> *mut c_char>,
    pub lcopy_format: *const c_char,
    pub lcopy_value: Option<unsafe extern "C" fn(*const GValue, c_uint, *mut GTypeCValue, c_uint) -> *mut c_char>,
}

#[cfg(target_pointer_width = "128")]
const ERROR: () = "Your pointers are too big.";

#[repr(C)]
pub struct GValue {
    g_type: GType,
    pub data: [u64; 2],
}

#[repr(C)]
pub struct GValueArray {
    pub n_values: c_uint,
    pub values: *mut GValue,
    n_prealloced: c_uint,
}

#[repr(C)]
pub struct GWeakRef {
    _truncated_record_marker: c_void,
    //union,
}

// Classes
#[repr(C)]
pub struct GBinding(c_void);

#[repr(C)]
pub struct GInitiallyUnowned {
    pub g_type_instance: GTypeInstance,
    ref_count: Volatile<c_uint>,
    qdata: *mut glib::GData,
}

#[repr(C)]
pub struct GObject {
    pub g_type_instance: GTypeInstance,
    ref_count: Volatile<c_uint>,
    qdata: *mut glib::GData,
}

#[repr(C)]
pub struct GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const c_char,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    _nick: *mut c_char,
    _blurb: *mut c_char,
    qdata: *mut glib::GData,
    ref_count: c_uint,
    param_id: c_uint,
}

#[repr(C)]
pub struct GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}

#[repr(C)]
pub struct GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: i8,
    pub maximum: i8,
    pub default_value: i8,
}

#[repr(C)]
pub struct GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: c_double,
    pub maximum: c_double,
    pub default_value: c_double,
    pub epsilon: c_double,
}

#[repr(C)]
pub struct GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: c_int,
}

#[repr(C)]
pub struct GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: c_uint,
}

#[repr(C)]
pub struct GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: c_float,
    pub maximum: c_float,
    pub default_value: c_float,
    pub epsilon: c_float,
}

#[repr(C)]
pub struct GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}

#[repr(C)]
pub struct GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: c_int,
    pub maximum: c_int,
    pub default_value: c_int,
}

#[repr(C)]
pub struct GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: i64,
    pub maximum: i64,
    pub default_value: i64,
}

#[repr(C)]
pub struct GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: c_long,
    pub maximum: c_long,
    pub default_value: c_long,
}

#[repr(C)]
pub struct GParamSpecObject {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecOverride {
    parent_instance: GParamSpec,
    overridden: *mut GParamSpec,
}

#[repr(C)]
pub struct GParamSpecParam {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecPointer {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut c_char,
    pub cset_first: *mut c_char,
    pub cset_nth: *mut c_char,
    pub substitutor: c_char,
    _truncated_record_marker: c_void,
    //null_fold_if_empty: guint: 1,
    //ensure_non_null: guint: 1,
}

#[repr(C)]
pub struct GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: u8,
    pub maximum: u8,
    pub default_value: u8,
}

#[repr(C)]
pub struct GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: c_uint,
    pub maximum: c_uint,
    pub default_value: c_uint,
}

#[repr(C)]
pub struct GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: u64,
    pub maximum: u64,
    pub default_value: u64,
}

#[repr(C)]
pub struct GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: c_ulong,
    pub maximum: c_ulong,
    pub default_value: c_ulong,
}

#[repr(C)]
pub struct GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: u32,
}

#[repr(C)]
pub struct GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: c_uint,
}

#[repr(C)]
pub struct GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut glib::GVariantType,
    pub default_value: *mut glib::GVariant,
    padding: [gpointer; 4],
}

#[repr(C)]
pub struct GTypeModule {
    pub parent_instance: GObject,
    pub use_count: c_uint,
    pub type_infos: *mut glib::GSList,
    pub interface_infos: *mut glib::GSList,
    pub name: *mut c_char,
}

// Interfaces
#[repr(C)]
pub struct GTypePlugin(c_void);

extern "C" {

    //=========================================================================
    // GCClosure
    //=========================================================================
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOOLEAN(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__BOOLEANv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOXED(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__BOXEDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__CHAR(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__CHARv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__DOUBLE(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__DOUBLEv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ENUM(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__ENUMv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLAGS(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__FLAGSv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLOAT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__FLOATv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__INT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__INTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__LONG(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__LONGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__OBJECT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__OBJECTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__PARAM(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__PARAMv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__STRING(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__STRINGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UCHAR(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__UCHARv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    //pub fn g_cclosure_marshal_VOID__UINTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ULONG(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__ULONGv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VARIANT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__VARIANTv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VOID(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_VOID__VOIDv(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_marshal_generic(closure: *mut GClosure, return_gvalue: *mut GValue, n_param_values: c_uint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    //pub fn g_cclosure_marshal_generic_va(closure: *mut GClosure, return_value: *mut GValue, instance: gpointer, args_list: /*Unimplemented*/va_list, marshal_data: gpointer, n_params: c_int, param_types: *mut GType);
    pub fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_object_swap(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;

    //=========================================================================
    // GClosure
    //=========================================================================
    pub fn g_closure_get_type() -> GType;
    pub fn g_closure_new_object(sizeof_closure: c_uint, object: *mut GObject) -> *mut GClosure;
    pub fn g_closure_new_simple(sizeof_closure: c_uint, data: gpointer) -> *mut GClosure;
    pub fn g_closure_add_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_add_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_add_marshal_guards(closure: *mut GClosure, pre_marshal_data: gpointer, pre_marshal_notify: GClosureNotify, post_marshal_data: gpointer, post_marshal_notify: GClosureNotify);
    pub fn g_closure_invalidate(closure: *mut GClosure);
    pub fn g_closure_invoke(closure: *mut GClosure, return_value: *mut GValue, n_param_values: c_uint, param_values: *mut GValue, invocation_hint: gpointer);
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
    pub fn g_closure_remove_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_remove_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
    pub fn g_closure_set_meta_marshal(closure: *mut GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal);
    pub fn g_closure_sink(closure: *mut GClosure);
    pub fn g_closure_unref(closure: *mut GClosure);

    //=========================================================================
    // GObjectClass
    //=========================================================================
    pub fn g_object_class_find_property(oclass: *mut GObjectClass, property_name: *const c_char) -> *mut GParamSpec;
    pub fn g_object_class_install_properties(oclass: *mut GObjectClass, n_pspecs: c_uint, pspecs: *mut *mut GParamSpec);
    pub fn g_object_class_install_property(oclass: *mut GObjectClass, property_id: c_uint, pspec: *mut GParamSpec);
    pub fn g_object_class_list_properties(oclass: *mut GObjectClass, n_properties: *mut c_uint) -> *mut *mut GParamSpec;
    pub fn g_object_class_override_property(oclass: *mut GObjectClass, property_id: c_uint, name: *const c_char);

    //=========================================================================
    // GParamSpecPool
    //=========================================================================
    pub fn g_param_spec_pool_insert(pool: *mut GParamSpecPool, pspec: *mut GParamSpec, owner_type: GType);
    pub fn g_param_spec_pool_list(pool: *mut GParamSpecPool, owner_type: GType, n_pspecs_p: *mut c_uint) -> *mut *mut GParamSpec;
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType) -> *mut glib::GList;
    pub fn g_param_spec_pool_lookup(pool: *mut GParamSpecPool, param_name: *const c_char, owner_type: GType, walk_ancestors: gboolean) -> *mut GParamSpec;
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;

    //=========================================================================
    // GTypeClass
    //=========================================================================
    pub fn g_type_class_add_private(g_class: gpointer, private_size: size_t);
    #[cfg(feature = "v2_38")]
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> c_int;
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
    pub fn g_type_class_unref(g_class: gpointer);
    pub fn g_type_class_unref_uncached(g_class: gpointer);
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut c_int);
    pub fn g_type_class_peek(type_: GType) -> gpointer;
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
    pub fn g_type_class_ref(type_: GType) -> gpointer;

    //=========================================================================
    // GTypeInstance
    //=========================================================================
    pub fn g_type_instance_get_private(instance: *mut GTypeInstance, private_type: GType) -> gpointer;

    //=========================================================================
    // GTypeInterface
    //=========================================================================
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
    pub fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) -> *mut GTypePlugin;
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
    pub fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: *mut c_uint) -> *mut GType;

    //=========================================================================
    // GTypeValueTable
    //=========================================================================
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;

    //=========================================================================
    // GValue
    //=========================================================================
    pub fn g_value_get_type() -> GType;
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_dup_object(value: *const GValue) -> *mut GObject;
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_dup_string(value: *const GValue) -> *mut c_char;
    pub fn g_value_dup_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_get_char(value: *const GValue) -> c_char;
    pub fn g_value_get_double(value: *const GValue) -> c_double;
    pub fn g_value_get_enum(value: *const GValue) -> c_int;
    pub fn g_value_get_flags(value: *const GValue) -> c_uint;
    pub fn g_value_get_float(value: *const GValue) -> c_float;
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
    pub fn g_value_get_int(value: *const GValue) -> c_int;
    pub fn g_value_get_int64(value: *const GValue) -> i64;
    pub fn g_value_get_long(value: *const GValue) -> c_long;
    pub fn g_value_get_object(value: *const GValue) -> *mut GObject;
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_get_schar(value: *const GValue) -> i8;
    pub fn g_value_get_string(value: *const GValue) -> *const c_char;
    pub fn g_value_get_uchar(value: *const GValue) -> c_uchar;
    pub fn g_value_get_uint(value: *const GValue) -> c_uint;
    pub fn g_value_get_uint64(value: *const GValue) -> u64;
    pub fn g_value_get_ulong(value: *const GValue) -> c_ulong;
    pub fn g_value_get_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
    #[cfg(feature = "v2_42")]
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_char(value: *mut GValue, v_char: c_char);
    pub fn g_value_set_double(value: *mut GValue, v_double: c_double);
    pub fn g_value_set_enum(value: *mut GValue, v_enum: c_int);
    pub fn g_value_set_flags(value: *mut GValue, v_flags: c_uint);
    pub fn g_value_set_float(value: *mut GValue, v_float: c_float);
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_set_int(value: *mut GValue, v_int: c_int);
    pub fn g_value_set_int64(value: *mut GValue, v_int64: i64);
    pub fn g_value_set_long(value: *mut GValue, v_long: c_long);
    pub fn g_value_set_object(value: *mut GValue, v_object: *mut GObject);
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
    pub fn g_value_set_schar(value: *mut GValue, v_char: i8);
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const c_char);
    pub fn g_value_set_string(value: *mut GValue, v_string: *const c_char);
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut c_char);
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: c_uchar);
    pub fn g_value_set_uint(value: *mut GValue, v_uint: c_uint);
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: u64);
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: c_ulong);
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut glib::GVariant);
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut c_char);
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut glib::GVariant);
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
    pub fn g_value_unset(value: *mut GValue);
    pub fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform);
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;

    //=========================================================================
    // GValueArray
    //=========================================================================
    pub fn g_value_array_get_type() -> GType;
    pub fn g_value_array_new(n_prealloced: c_uint) -> *mut GValueArray;
    pub fn g_value_array_append(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
    pub fn g_value_array_free(value_array: *mut GValueArray);
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: c_uint) -> *mut GValue;
    pub fn g_value_array_insert(value_array: *mut GValueArray, index_: c_uint, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_prepend(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: c_uint) -> *mut GValueArray;
    pub fn g_value_array_sort(value_array: *mut GValueArray, compare_func: glib::GCompareFunc) -> *mut GValueArray;
    pub fn g_value_array_sort_with_data(value_array: *mut GValueArray, compare_func: glib::GCompareDataFunc, user_data: gpointer) -> *mut GValueArray;

    //=========================================================================
    // GWeakRef
    //=========================================================================
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> *mut GObject;
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: *mut GObject);
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: *mut GObject);

    //=========================================================================
    // GBinding
    //=========================================================================
    pub fn g_binding_get_type() -> GType;
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const c_char;
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const c_char;
    #[cfg(feature = "v2_38")]
    pub fn g_binding_unbind(binding: *mut GBinding);

    //=========================================================================
    // GInitiallyUnowned
    //=========================================================================
    pub fn g_initially_unowned_get_type() -> GType;

    //=========================================================================
    // GObject
    //=========================================================================
    pub fn g_object_get_type() -> GType;
    pub fn g_object_new(object_type: GType, first_property_name: *const c_char, ...) -> *mut GObject;
    //pub fn g_object_new_valist(object_type: GType, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut GObject;
    pub fn g_object_newv(object_type: GType, n_parameters: c_uint, parameters: *mut GParameter) -> *mut GObject;
    pub fn g_object_compat_control(what: size_t, data: gpointer) -> size_t;
    pub fn g_object_interface_find_property(g_iface: gpointer, property_name: *const c_char) -> *mut GParamSpec;
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
    pub fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: *mut c_uint) -> *mut *mut GParamSpec;
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
    pub fn g_object_bind_property(source: *mut GObject, source_property: *const c_char, target: *mut GObject, target_property: *const c_char, flags: GBindingFlags) -> *mut GBinding;
    pub fn g_object_bind_property_full(source: *mut GObject, source_property: *const c_char, target: *mut GObject, target_property: *const c_char, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GBinding;
    pub fn g_object_bind_property_with_closures(source: *mut GObject, source_property: *const c_char, target: *mut GObject, target_property: *const c_char, flags: GBindingFlags, transform_to: *mut GClosure, transform_from: *mut GClosure) -> *mut GBinding;
    pub fn g_object_connect(object: *mut GObject, signal_spec: *const c_char, ...) -> *mut GObject;
    pub fn g_object_disconnect(object: *mut GObject, signal_spec: *const c_char, ...);
    #[cfg(feature = "v2_34")]
    pub fn g_object_dup_data(object: *mut GObject, key: *const c_char, dup_func: glib::GDuplicateFunc, user_data: gpointer) -> gpointer;
    #[cfg(feature = "v2_34")]
    pub fn g_object_dup_qdata(object: *mut GObject, quark: glib::GQuark, dup_func: glib::GDuplicateFunc, user_data: gpointer) -> gpointer;
    pub fn g_object_force_floating(object: *mut GObject);
    pub fn g_object_freeze_notify(object: *mut GObject);
    pub fn g_object_get(object: *mut GObject, first_property_name: *const c_char, ...);
    pub fn g_object_get_data(object: *mut GObject, key: *const c_char) -> gpointer;
    pub fn g_object_get_property(object: *mut GObject, property_name: *const c_char, value: *mut GValue);
    pub fn g_object_get_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    //pub fn g_object_get_valist(object: *mut GObject, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_object_is_floating(object: *mut GObject) -> gboolean;
    pub fn g_object_notify(object: *mut GObject, property_name: *const c_char);
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
    pub fn g_object_ref(object: *mut GObject) -> *mut GObject;
    pub fn g_object_ref_sink(object: *mut GObject) -> *mut GObject;
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
    #[cfg(feature = "v2_34")]
    pub fn g_object_replace_data(object: *mut GObject, key: *const c_char, oldval: gpointer, newval: gpointer, destroy: glib::GDestroyNotify, old_destroy: *mut glib::GDestroyNotify) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_object_replace_qdata(object: *mut GObject, quark: glib::GQuark, oldval: gpointer, newval: gpointer, destroy: glib::GDestroyNotify, old_destroy: *mut glib::GDestroyNotify) -> gboolean;
    pub fn g_object_run_dispose(object: *mut GObject);
    pub fn g_object_set(object: *mut GObject, first_property_name: *const c_char, ...);
    pub fn g_object_set_data(object: *mut GObject, key: *const c_char, data: gpointer);
    pub fn g_object_set_data_full(object: *mut GObject, key: *const c_char, data: gpointer, destroy: glib::GDestroyNotify);
    pub fn g_object_set_property(object: *mut GObject, property_name: *const c_char, value: *const GValue);
    pub fn g_object_set_qdata(object: *mut GObject, quark: glib::GQuark, data: gpointer);
    pub fn g_object_set_qdata_full(object: *mut GObject, quark: glib::GQuark, data: gpointer, destroy: glib::GDestroyNotify);
    //pub fn g_object_set_valist(object: *mut GObject, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_object_steal_data(object: *mut GObject, key: *const c_char) -> gpointer;
    pub fn g_object_steal_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    pub fn g_object_thaw_notify(object: *mut GObject);
    pub fn g_object_unref(object: *mut GObject);
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);

    //=========================================================================
    // GParamSpec
    //=========================================================================
    pub fn g_param_spec_internal(param_type: GType, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const c_char;
    #[cfg(feature = "v2_38")]
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const c_char;
    #[cfg(feature = "v2_46")]
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> glib::GQuark;
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const c_char;
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: glib::GQuark, data: gpointer);
    pub fn g_param_spec_set_qdata_full(pspec: *mut GParamSpec, quark: glib::GQuark, data: gpointer, destroy: glib::GDestroyNotify);
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);

    //=========================================================================
    // GTypeModule
    //=========================================================================
    pub fn g_type_module_get_type() -> GType;
    pub fn g_type_module_add_interface(module: *mut GTypeModule, instance_type: GType, interface_type: GType, interface_info: *const GInterfaceInfo);
    pub fn g_type_module_register_enum(module: *mut GTypeModule, name: *const c_char, const_static_values: *const GEnumValue) -> GType;
    pub fn g_type_module_register_flags(module: *mut GTypeModule, name: *const c_char, const_static_values: *const GFlagsValue) -> GType;
    pub fn g_type_module_register_type(module: *mut GTypeModule, parent_type: GType, type_name: *const c_char, type_info: *const GTypeInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const c_char);
    pub fn g_type_module_unuse(module: *mut GTypeModule);
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;

    //=========================================================================
    // GTypePlugin
    //=========================================================================
    pub fn g_type_plugin_get_type() -> GType;
    pub fn g_type_plugin_complete_interface_info(plugin: *mut GTypePlugin, instance_type: GType, interface_type: GType, info: *mut GInterfaceInfo);
    pub fn g_type_plugin_complete_type_info(plugin: *mut GTypePlugin, g_type: GType, info: *mut GTypeInfo, value_table: *mut GTypeValueTable);
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
    pub fn g_boxed_type_register_static(name: *const c_char, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) -> GType;
    pub fn g_clear_object(object_ptr: *mut *mut Volatile<GObject>);
    pub fn g_enum_complete_type_info(g_enum_type: GType, info: *mut GTypeInfo, const_values: *const GEnumValue);
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: c_int) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_name(enum_class: *mut GEnumClass, name: *const c_char) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_nick(enum_class: *mut GEnumClass, nick: *const c_char) -> *mut GEnumValue;
    pub fn g_enum_register_static(name: *const c_char, const_static_values: *const GEnumValue) -> GType;
    pub fn g_flags_complete_type_info(g_flags_type: GType, info: *mut GTypeInfo, const_values: *const GFlagsValue);
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: c_uint) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_name(flags_class: *mut GFlagsClass, name: *const c_char) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_nick(flags_class: *mut GFlagsClass, nick: *const c_char) -> *mut GFlagsValue;
    pub fn g_flags_register_static(name: *const c_char, const_static_values: *const GFlagsValue) -> GType;
    pub fn g_gtype_get_type() -> GType;
    pub fn g_param_spec_boolean(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: gboolean, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boxed(name: *const c_char, nick: *const c_char, blurb: *const c_char, boxed_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_char(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: i8, maximum: i8, default_value: i8, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_double(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_double, maximum: c_double, default_value: c_double, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_enum(name: *const c_char, nick: *const c_char, blurb: *const c_char, enum_type: GType, default_value: c_int, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_flags(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags_type: GType, default_value: c_uint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_float(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_float, maximum: c_float, default_value: c_float, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_gtype(name: *const c_char, nick: *const c_char, blurb: *const c_char, is_a_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_int, maximum: c_int, default_value: c_int, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int64(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: i64, maximum: i64, default_value: i64, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_long(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_long, maximum: c_long, default_value: c_long, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_object(name: *const c_char, nick: *const c_char, blurb: *const c_char, object_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_override(name: *const c_char, overridden: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_param(name: *const c_char, nick: *const c_char, blurb: *const c_char, param_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_pointer(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_string(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *const c_char, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uchar(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: u8, maximum: u8, default_value: u8, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_uint, maximum: c_uint, default_value: c_uint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint64(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: u64, maximum: u64, default_value: u64, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_ulong(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_ulong, maximum: c_ulong, default_value: c_ulong, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_unichar(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: u32, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_value_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, element_spec: *mut GParamSpec, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_variant(name: *const c_char, nick: *const c_char, blurb: *const c_char, type_: *const glib::GVariantType, default_value: *mut glib::GVariant, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_type_register_static(name: *const c_char, pspec_info: *const GParamSpecTypeInfo) -> GType;
    pub fn g_param_value_convert(pspec: *mut GParamSpec, src_value: *const GValue, dest_value: *mut GValue, strict_validation: gboolean) -> gboolean;
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
    pub fn g_param_values_cmp(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue) -> c_int;
    pub fn g_pointer_type_register_static(name: *const c_char) -> GType;
    pub fn g_signal_accumulator_first_wins(ihint: *mut GSignalInvocationHint, return_accu: *mut GValue, handler_return: *const GValue, dummy: gpointer) -> gboolean;
    pub fn g_signal_accumulator_true_handled(ihint: *mut GSignalInvocationHint, return_accu: *mut GValue, handler_return: *const GValue, dummy: gpointer) -> gboolean;
    pub fn g_signal_add_emission_hook(signal_id: c_uint, detail: glib::GQuark, hook_func: GSignalEmissionHook, hook_data: gpointer, data_destroy: glib::GDestroyNotify) -> c_ulong;
    pub fn g_signal_chain_from_overridden(instance_and_params: *mut GValue, return_value: *mut GValue);
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
    pub fn g_signal_connect_closure(instance: *mut GObject, detailed_signal: *const c_char, closure: *mut GClosure, after: gboolean) -> c_ulong;
    pub fn g_signal_connect_closure_by_id(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark, closure: *mut GClosure, after: gboolean) -> c_ulong;
    pub fn g_signal_connect_data(instance: *mut GObject, detailed_signal: *const c_char, c_handler: GCallback, data: gpointer, destroy_data: GClosureNotify, connect_flags: GConnectFlags) -> c_ulong;
    pub fn g_signal_connect_object(instance: gpointer, detailed_signal: *const c_char, c_handler: GCallback, gobject: *mut GObject, connect_flags: GConnectFlags) -> c_ulong;
    pub fn g_signal_emit(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark, ...);
    pub fn g_signal_emit_by_name(instance: *mut GObject, detailed_signal: *const c_char, ...);
    //pub fn g_signal_emit_valist(instance: gpointer, signal_id: c_uint, detail: glib::GQuark, var_args: /*Unimplemented*/va_list);
    pub fn g_signal_emitv(instance_and_params: *mut GValue, signal_id: c_uint, detail: glib::GQuark, return_value: *mut GValue);
    pub fn g_signal_get_invocation_hint(instance: *mut GObject) -> *mut GSignalInvocationHint;
    pub fn g_signal_handler_block(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handler_disconnect(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handler_find(instance: *mut GObject, mask: GSignalMatchType, signal_id: c_uint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> c_ulong;
    pub fn g_signal_handler_is_connected(instance: *mut GObject, handler_id: c_ulong) -> gboolean;
    pub fn g_signal_handler_unblock(instance: *mut GObject, handler_id: c_ulong);
    pub fn g_signal_handlers_block_matched(instance: *mut GObject, mask: GSignalMatchType, signal_id: c_uint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> c_uint;
    pub fn g_signal_handlers_destroy(instance: *mut GObject);
    pub fn g_signal_handlers_disconnect_matched(instance: *mut GObject, mask: GSignalMatchType, signal_id: c_uint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> c_uint;
    pub fn g_signal_handlers_unblock_matched(instance: *mut GObject, mask: GSignalMatchType, signal_id: c_uint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> c_uint;
    pub fn g_signal_has_handler_pending(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark, may_be_blocked: gboolean) -> gboolean;
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut c_uint) -> *mut c_uint;
    pub fn g_signal_lookup(name: *const c_char, itype: GType) -> c_uint;
    pub fn g_signal_name(signal_id: c_uint) -> *const c_char;
    pub fn g_signal_new(signal_name: *const c_char, itype: GType, signal_flags: GSignalFlags, class_offset: c_uint, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: c_uint, ...) -> c_uint;
    pub fn g_signal_new_class_handler(signal_name: *const c_char, itype: GType, signal_flags: GSignalFlags, class_handler: GCallback, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: c_uint, ...) -> c_uint;
    //pub fn g_signal_new_valist(signal_name: *const c_char, itype: GType, signal_flags: GSignalFlags, class_closure: *mut GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: c_uint, args: /*Unimplemented*/va_list) -> c_uint;
    pub fn g_signal_newv(signal_name: *const c_char, itype: GType, signal_flags: GSignalFlags, class_closure: *mut GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: c_uint, param_types: *mut GType) -> c_uint;
    pub fn g_signal_override_class_closure(signal_id: c_uint, instance_type: GType, class_closure: *mut GClosure);
    pub fn g_signal_override_class_handler(signal_name: *const c_char, instance_type: GType, class_handler: GCallback);
    pub fn g_signal_parse_name(detailed_signal: *const c_char, itype: GType, signal_id_p: *mut c_uint, detail_p: *mut glib::GQuark, force_detail_quark: gboolean) -> gboolean;
    pub fn g_signal_query(signal_id: c_uint, query: *mut GSignalQuery);
    pub fn g_signal_remove_emission_hook(signal_id: c_uint, hook_id: c_ulong);
    //pub fn g_signal_set_va_marshaller(signal_id: c_uint, instance_type: GType, va_marshaller: /*Ignored*/GSignalCVaMarshaller);
    pub fn g_signal_stop_emission(instance: *mut GObject, signal_id: c_uint, detail: glib::GQuark);
    pub fn g_signal_stop_emission_by_name(instance: *mut GObject, detailed_signal: *const c_char);
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: c_uint) -> *mut GClosure;
    pub fn g_source_set_closure(source: *mut glib::GSource, closure: *mut GClosure);
    pub fn g_source_set_dummy_callback(source: *mut glib::GSource);
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut c_char;
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_add_class_private(class_type: GType, private_size: size_t);
    pub fn g_type_add_instance_private(class_type: GType, private_size: size_t) -> c_int;
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: *mut GTypePlugin);
    pub fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: *const GInterfaceInfo);
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
    pub fn g_type_check_instance_cast(instance: *mut GTypeInstance, iface_type: GType) -> *mut GTypeInstance;
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
    pub fn g_type_check_instance_is_fundamentally_a(instance: *mut GTypeInstance, fundamental_type: GType) -> gboolean;
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
    pub fn g_type_check_value_holds(value: *mut GValue, type_: GType) -> gboolean;
    pub fn g_type_children(type_: GType, n_children: *mut c_uint) -> *mut GType;
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_unref(g_iface: gpointer);
    pub fn g_type_depth(type_: GType) -> c_uint;
    #[cfg(feature = "v2_34")]
    pub fn g_type_ensure(type_: GType);
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
    pub fn g_type_from_name(name: *const c_char) -> GType;
    pub fn g_type_fundamental(type_id: GType) -> GType;
    pub fn g_type_fundamental_next() -> GType;
    #[cfg(feature = "v2_44")]
    pub fn g_type_get_instance_count(type_: GType) -> c_int;
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
    pub fn g_type_get_qdata(type_: GType, quark: glib::GQuark) -> gpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_type_get_type_registration_serial() -> c_uint;
    pub fn g_type_init();
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut c_uint) -> *mut GType;
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
    pub fn g_type_name(type_: GType) -> *const c_char;
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const c_char;
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const c_char;
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
    pub fn g_type_parent(type_: GType) -> GType;
    pub fn g_type_qname(type_: GType) -> glib::GQuark;
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
    pub fn g_type_register_dynamic(parent_type: GType, type_name: *const c_char, plugin: *mut GTypePlugin, flags: GTypeFlags) -> GType;
    pub fn g_type_register_fundamental(type_id: GType, type_name: *const c_char, info: *const GTypeInfo, finfo: *const GTypeFundamentalInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_register_static(parent_type: GType, type_name: *const c_char, info: *const GTypeInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_register_static_simple(parent_type: GType, type_name: *const c_char, class_size: c_uint, class_init: GClassInitFunc, instance_size: c_uint, instance_init: GInstanceInitFunc, flags: GTypeFlags) -> GType;
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_set_qdata(type_: GType, quark: glib::GQuark, data: gpointer);
    pub fn g_type_test_flags(type_: GType, flags: c_uint) -> gboolean;

}
