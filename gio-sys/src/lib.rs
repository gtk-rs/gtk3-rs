// This file was generated by gir (b91816f) from gir-files (71d73f0)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GBusType {
    Starter = -1,
    None = 0,
    System = 1,
    Session = 2,
}
pub const G_BUS_TYPE_STARTER: GBusType = GBusType::Starter;
pub const G_BUS_TYPE_NONE: GBusType = GBusType::None;
pub const G_BUS_TYPE_SYSTEM: GBusType = GBusType::System;
pub const G_BUS_TYPE_SESSION: GBusType = GBusType::Session;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GConverterResult {
    Error = 0,
    Converted = 1,
    Finished = 2,
    Flushed = 3,
}
pub const G_CONVERTER_ERROR: GConverterResult = GConverterResult::Error;
pub const G_CONVERTER_CONVERTED: GConverterResult = GConverterResult::Converted;
pub const G_CONVERTER_FINISHED: GConverterResult = GConverterResult::Finished;
pub const G_CONVERTER_FLUSHED: GConverterResult = GConverterResult::Flushed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GCredentialsType {
    Invalid = 0,
    LinuxUcred = 1,
    FreebsdCmsgcred = 2,
    OpenbsdSockpeercred = 3,
    SolarisUcred = 4,
    NetbsdUnpcbid = 5,
}
pub const G_CREDENTIALS_TYPE_INVALID: GCredentialsType = GCredentialsType::Invalid;
pub const G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = GCredentialsType::LinuxUcred;
pub const G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = GCredentialsType::FreebsdCmsgcred;
pub const G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = GCredentialsType::OpenbsdSockpeercred;
pub const G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = GCredentialsType::SolarisUcred;
pub const G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = GCredentialsType::NetbsdUnpcbid;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDBusError {
    Failed = 0,
    NoMemory = 1,
    ServiceUnknown = 2,
    NameHasNoOwner = 3,
    NoReply = 4,
    IoError = 5,
    BadAddress = 6,
    NotSupported = 7,
    LimitsExceeded = 8,
    AccessDenied = 9,
    AuthFailed = 10,
    NoServer = 11,
    Timeout = 12,
    NoNetwork = 13,
    AddressInUse = 14,
    Disconnected = 15,
    InvalidArgs = 16,
    FileNotFound = 17,
    FileExists = 18,
    UnknownMethod = 19,
    TimedOut = 20,
    MatchRuleNotFound = 21,
    MatchRuleInvalid = 22,
    SpawnExecFailed = 23,
    SpawnForkFailed = 24,
    SpawnChildExited = 25,
    SpawnChildSignaled = 26,
    SpawnFailed = 27,
    SpawnSetupFailed = 28,
    SpawnConfigInvalid = 29,
    SpawnServiceInvalid = 30,
    SpawnServiceNotFound = 31,
    SpawnPermissionsInvalid = 32,
    SpawnFileInvalid = 33,
    SpawnNoMemory = 34,
    UnixProcessIdUnknown = 35,
    InvalidSignature = 36,
    InvalidFileContent = 37,
    SelinuxSecurityContextUnknown = 38,
    AdtAuditDataUnknown = 39,
    ObjectPathInUse = 40,
    UnknownObject = 41,
    UnknownInterface = 42,
    UnknownProperty = 43,
    PropertyReadOnly = 44,
}
pub const G_DBUS_ERROR_FAILED: GDBusError = GDBusError::Failed;
pub const G_DBUS_ERROR_NO_MEMORY: GDBusError = GDBusError::NoMemory;
pub const G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = GDBusError::ServiceUnknown;
pub const G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = GDBusError::NameHasNoOwner;
pub const G_DBUS_ERROR_NO_REPLY: GDBusError = GDBusError::NoReply;
pub const G_DBUS_ERROR_IO_ERROR: GDBusError = GDBusError::IoError;
pub const G_DBUS_ERROR_BAD_ADDRESS: GDBusError = GDBusError::BadAddress;
pub const G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = GDBusError::NotSupported;
pub const G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = GDBusError::LimitsExceeded;
pub const G_DBUS_ERROR_ACCESS_DENIED: GDBusError = GDBusError::AccessDenied;
pub const G_DBUS_ERROR_AUTH_FAILED: GDBusError = GDBusError::AuthFailed;
pub const G_DBUS_ERROR_NO_SERVER: GDBusError = GDBusError::NoServer;
pub const G_DBUS_ERROR_TIMEOUT: GDBusError = GDBusError::Timeout;
pub const G_DBUS_ERROR_NO_NETWORK: GDBusError = GDBusError::NoNetwork;
pub const G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = GDBusError::AddressInUse;
pub const G_DBUS_ERROR_DISCONNECTED: GDBusError = GDBusError::Disconnected;
pub const G_DBUS_ERROR_INVALID_ARGS: GDBusError = GDBusError::InvalidArgs;
pub const G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = GDBusError::FileNotFound;
pub const G_DBUS_ERROR_FILE_EXISTS: GDBusError = GDBusError::FileExists;
pub const G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = GDBusError::UnknownMethod;
pub const G_DBUS_ERROR_TIMED_OUT: GDBusError = GDBusError::TimedOut;
pub const G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = GDBusError::MatchRuleNotFound;
pub const G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = GDBusError::MatchRuleInvalid;
pub const G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = GDBusError::SpawnExecFailed;
pub const G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = GDBusError::SpawnForkFailed;
pub const G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = GDBusError::SpawnChildExited;
pub const G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = GDBusError::SpawnChildSignaled;
pub const G_DBUS_ERROR_SPAWN_FAILED: GDBusError = GDBusError::SpawnFailed;
pub const G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = GDBusError::SpawnSetupFailed;
pub const G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = GDBusError::SpawnConfigInvalid;
pub const G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = GDBusError::SpawnServiceInvalid;
pub const G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = GDBusError::SpawnServiceNotFound;
pub const G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = GDBusError::SpawnPermissionsInvalid;
pub const G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = GDBusError::SpawnFileInvalid;
pub const G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = GDBusError::SpawnNoMemory;
pub const G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = GDBusError::UnixProcessIdUnknown;
pub const G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = GDBusError::InvalidSignature;
pub const G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = GDBusError::InvalidFileContent;
pub const G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = GDBusError::SelinuxSecurityContextUnknown;
pub const G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = GDBusError::AdtAuditDataUnknown;
pub const G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = GDBusError::ObjectPathInUse;
pub const G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = GDBusError::UnknownObject;
pub const G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = GDBusError::UnknownInterface;
pub const G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = GDBusError::UnknownProperty;
pub const G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = GDBusError::PropertyReadOnly;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDBusMessageByteOrder {
    BigEndian = 66,
    LittleEndian = 108,
}
pub const G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = GDBusMessageByteOrder::BigEndian;
pub const G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder = GDBusMessageByteOrder::LittleEndian;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDBusMessageHeaderField {
    Invalid = 0,
    Path = 1,
    Interface = 2,
    Member = 3,
    ErrorName = 4,
    ReplySerial = 5,
    Destination = 6,
    Sender = 7,
    Signature = 8,
    NumUnixFds = 9,
}
pub const G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = GDBusMessageHeaderField::Invalid;
pub const G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = GDBusMessageHeaderField::Path;
pub const G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField = GDBusMessageHeaderField::Interface;
pub const G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = GDBusMessageHeaderField::Member;
pub const G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField = GDBusMessageHeaderField::ErrorName;
pub const G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: GDBusMessageHeaderField = GDBusMessageHeaderField::ReplySerial;
pub const G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField = GDBusMessageHeaderField::Destination;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = GDBusMessageHeaderField::Sender;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField = GDBusMessageHeaderField::Signature;
pub const G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: GDBusMessageHeaderField = GDBusMessageHeaderField::NumUnixFds;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDBusMessageType {
    Invalid = 0,
    MethodCall = 1,
    MethodReturn = 2,
    Error = 3,
    Signal = 4,
}
pub const G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = GDBusMessageType::Invalid;
pub const G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = GDBusMessageType::MethodCall;
pub const G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = GDBusMessageType::MethodReturn;
pub const G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = GDBusMessageType::Error;
pub const G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = GDBusMessageType::Signal;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDataStreamByteOrder {
    BigEndian = 0,
    LittleEndian = 1,
    HostEndian = 2,
}
pub const G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::BigEndian;
pub const G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::LittleEndian;
pub const G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::HostEndian;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDataStreamNewlineType {
    Lf = 0,
    Cr = 1,
    CrLf = 2,
    Any = 3,
}
pub const G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = GDataStreamNewlineType::Lf;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = GDataStreamNewlineType::Cr;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = GDataStreamNewlineType::CrLf;
pub const G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = GDataStreamNewlineType::Any;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GDriveStartStopType {
    Unknown = 0,
    Shutdown = 1,
    Network = 2,
    Multidisk = 3,
    Password = 4,
}
pub const G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = GDriveStartStopType::Unknown;
pub const G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = GDriveStartStopType::Shutdown;
pub const G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = GDriveStartStopType::Network;
pub const G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = GDriveStartStopType::Multidisk;
pub const G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = GDriveStartStopType::Password;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GEmblemOrigin {
    Unknown = 0,
    Device = 1,
    Livemetadata = 2,
    Tag = 3,
}
pub const G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = GEmblemOrigin::Unknown;
pub const G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = GEmblemOrigin::Device;
pub const G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = GEmblemOrigin::Livemetadata;
pub const G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = GEmblemOrigin::Tag;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFileAttributeStatus {
    Unset = 0,
    Set = 1,
    ErrorSetting = 2,
}
pub const G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = GFileAttributeStatus::Unset;
pub const G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = GFileAttributeStatus::Set;
pub const G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = GFileAttributeStatus::ErrorSetting;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFileAttributeType {
    Invalid = 0,
    String = 1,
    ByteString = 2,
    Boolean = 3,
    Uint32 = 4,
    Int32 = 5,
    Uint64 = 6,
    Int64 = 7,
    Object = 8,
    Stringv = 9,
}
pub const G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = GFileAttributeType::Invalid;
pub const G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = GFileAttributeType::String;
pub const G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = GFileAttributeType::ByteString;
pub const G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = GFileAttributeType::Boolean;
pub const G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = GFileAttributeType::Uint32;
pub const G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = GFileAttributeType::Int32;
pub const G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = GFileAttributeType::Uint64;
pub const G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = GFileAttributeType::Int64;
pub const G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = GFileAttributeType::Object;
pub const G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = GFileAttributeType::Stringv;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFileMonitorEvent {
    Changed = 0,
    ChangesDoneHint = 1,
    Deleted = 2,
    Created = 3,
    AttributeChanged = 4,
    PreUnmount = 5,
    Unmounted = 6,
    Moved = 7,
    Renamed = 8,
    MovedIn = 9,
    MovedOut = 10,
}
pub const G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = GFileMonitorEvent::Changed;
pub const G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = GFileMonitorEvent::ChangesDoneHint;
pub const G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = GFileMonitorEvent::Deleted;
pub const G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = GFileMonitorEvent::Created;
pub const G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = GFileMonitorEvent::AttributeChanged;
pub const G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = GFileMonitorEvent::PreUnmount;
pub const G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = GFileMonitorEvent::Unmounted;
pub const G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = GFileMonitorEvent::Moved;
pub const G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = GFileMonitorEvent::Renamed;
pub const G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = GFileMonitorEvent::MovedIn;
pub const G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = GFileMonitorEvent::MovedOut;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFileType {
    Unknown = 0,
    Regular = 1,
    Directory = 2,
    SymbolicLink = 3,
    Special = 4,
    Shortcut = 5,
    Mountable = 6,
}
pub const G_FILE_TYPE_UNKNOWN: GFileType = GFileType::Unknown;
pub const G_FILE_TYPE_REGULAR: GFileType = GFileType::Regular;
pub const G_FILE_TYPE_DIRECTORY: GFileType = GFileType::Directory;
pub const G_FILE_TYPE_SYMBOLIC_LINK: GFileType = GFileType::SymbolicLink;
pub const G_FILE_TYPE_SPECIAL: GFileType = GFileType::Special;
pub const G_FILE_TYPE_SHORTCUT: GFileType = GFileType::Shortcut;
pub const G_FILE_TYPE_MOUNTABLE: GFileType = GFileType::Mountable;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GFilesystemPreviewType {
    IfAlways = 0,
    IfLocal = 1,
    Never = 2,
}
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = GFilesystemPreviewType::IfAlways;
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = GFilesystemPreviewType::IfLocal;
pub const G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = GFilesystemPreviewType::Never;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GIOErrorEnum {
    Failed = 0,
    NotFound = 1,
    Exists = 2,
    IsDirectory = 3,
    NotDirectory = 4,
    NotEmpty = 5,
    NotRegularFile = 6,
    NotSymbolicLink = 7,
    NotMountableFile = 8,
    FilenameTooLong = 9,
    InvalidFilename = 10,
    TooManyLinks = 11,
    NoSpace = 12,
    InvalidArgument = 13,
    PermissionDenied = 14,
    NotSupported = 15,
    NotMounted = 16,
    AlreadyMounted = 17,
    Closed = 18,
    Cancelled = 19,
    Pending = 20,
    ReadOnly = 21,
    CantCreateBackup = 22,
    WrongEtag = 23,
    TimedOut = 24,
    WouldRecurse = 25,
    Busy = 26,
    WouldBlock = 27,
    HostNotFound = 28,
    WouldMerge = 29,
    FailedHandled = 30,
    TooManyOpenFiles = 31,
    NotInitialized = 32,
    AddressInUse = 33,
    PartialInput = 34,
    InvalidData = 35,
    DbusError = 36,
    HostUnreachable = 37,
    NetworkUnreachable = 38,
    ConnectionRefused = 39,
    ProxyFailed = 40,
    ProxyAuthFailed = 41,
    ProxyNeedAuth = 42,
    ProxyNotAllowed = 43,
    BrokenPipe = 44,
    NotConnected = 45,
    MessageTooLarge = 46,
}
pub const G_IO_ERROR_FAILED: GIOErrorEnum = GIOErrorEnum::Failed;
pub const G_IO_ERROR_NOT_FOUND: GIOErrorEnum = GIOErrorEnum::NotFound;
pub const G_IO_ERROR_EXISTS: GIOErrorEnum = GIOErrorEnum::Exists;
pub const G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = GIOErrorEnum::IsDirectory;
pub const G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = GIOErrorEnum::NotDirectory;
pub const G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = GIOErrorEnum::NotEmpty;
pub const G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = GIOErrorEnum::NotRegularFile;
pub const G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = GIOErrorEnum::NotSymbolicLink;
pub const G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = GIOErrorEnum::NotMountableFile;
pub const G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = GIOErrorEnum::FilenameTooLong;
pub const G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = GIOErrorEnum::InvalidFilename;
pub const G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = GIOErrorEnum::TooManyLinks;
pub const G_IO_ERROR_NO_SPACE: GIOErrorEnum = GIOErrorEnum::NoSpace;
pub const G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = GIOErrorEnum::InvalidArgument;
pub const G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = GIOErrorEnum::PermissionDenied;
pub const G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = GIOErrorEnum::NotSupported;
pub const G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = GIOErrorEnum::NotMounted;
pub const G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = GIOErrorEnum::AlreadyMounted;
pub const G_IO_ERROR_CLOSED: GIOErrorEnum = GIOErrorEnum::Closed;
pub const G_IO_ERROR_CANCELLED: GIOErrorEnum = GIOErrorEnum::Cancelled;
pub const G_IO_ERROR_PENDING: GIOErrorEnum = GIOErrorEnum::Pending;
pub const G_IO_ERROR_READ_ONLY: GIOErrorEnum = GIOErrorEnum::ReadOnly;
pub const G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = GIOErrorEnum::CantCreateBackup;
pub const G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = GIOErrorEnum::WrongEtag;
pub const G_IO_ERROR_TIMED_OUT: GIOErrorEnum = GIOErrorEnum::TimedOut;
pub const G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = GIOErrorEnum::WouldRecurse;
pub const G_IO_ERROR_BUSY: GIOErrorEnum = GIOErrorEnum::Busy;
pub const G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = GIOErrorEnum::WouldBlock;
pub const G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = GIOErrorEnum::HostNotFound;
pub const G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = GIOErrorEnum::WouldMerge;
pub const G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = GIOErrorEnum::FailedHandled;
pub const G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = GIOErrorEnum::TooManyOpenFiles;
pub const G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = GIOErrorEnum::NotInitialized;
pub const G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = GIOErrorEnum::AddressInUse;
pub const G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = GIOErrorEnum::PartialInput;
pub const G_IO_ERROR_INVALID_DATA: GIOErrorEnum = GIOErrorEnum::InvalidData;
pub const G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = GIOErrorEnum::DbusError;
pub const G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = GIOErrorEnum::HostUnreachable;
pub const G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = GIOErrorEnum::NetworkUnreachable;
pub const G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = GIOErrorEnum::ConnectionRefused;
pub const G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = GIOErrorEnum::ProxyFailed;
pub const G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = GIOErrorEnum::ProxyAuthFailed;
pub const G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = GIOErrorEnum::ProxyNeedAuth;
pub const G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = GIOErrorEnum::ProxyNotAllowed;
pub const G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = GIOErrorEnum::BrokenPipe;
pub const G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = GIOErrorEnum::BrokenPipe;
pub const G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = GIOErrorEnum::NotConnected;
pub const G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = GIOErrorEnum::MessageTooLarge;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GIOModuleScopeFlags {
    None = 0,
    BlockDuplicates = 1,
}
pub const G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = GIOModuleScopeFlags::None;
pub const G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = GIOModuleScopeFlags::BlockDuplicates;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GMountOperationResult {
    Handled = 0,
    Aborted = 1,
    Unhandled = 2,
}
pub const G_MOUNT_OPERATION_HANDLED: GMountOperationResult = GMountOperationResult::Handled;
pub const G_MOUNT_OPERATION_ABORTED: GMountOperationResult = GMountOperationResult::Aborted;
pub const G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = GMountOperationResult::Unhandled;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GNetworkConnectivity {
    Local = 1,
    Limited = 2,
    Portal = 3,
    Full = 4,
}
pub const G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = GNetworkConnectivity::Local;
pub const G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = GNetworkConnectivity::Limited;
pub const G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = GNetworkConnectivity::Portal;
pub const G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = GNetworkConnectivity::Full;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GNotificationPriority {
    Normal = 0,
    Low = 1,
    High = 2,
    Urgent = 3,
}
pub const G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = GNotificationPriority::Normal;
pub const G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = GNotificationPriority::Low;
pub const G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = GNotificationPriority::High;
pub const G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = GNotificationPriority::Urgent;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GPasswordSave {
    Never = 0,
    ForSession = 1,
    Permanently = 2,
}
pub const G_PASSWORD_SAVE_NEVER: GPasswordSave = GPasswordSave::Never;
pub const G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = GPasswordSave::ForSession;
pub const G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = GPasswordSave::Permanently;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GResolverError {
    NotFound = 0,
    TemporaryFailure = 1,
    Internal = 2,
}
pub const G_RESOLVER_ERROR_NOT_FOUND: GResolverError = GResolverError::NotFound;
pub const G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = GResolverError::TemporaryFailure;
pub const G_RESOLVER_ERROR_INTERNAL: GResolverError = GResolverError::Internal;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GResolverRecordType {
    Srv = 1,
    Mx = 2,
    Txt = 3,
    Soa = 4,
    Ns = 5,
}
pub const G_RESOLVER_RECORD_SRV: GResolverRecordType = GResolverRecordType::Srv;
pub const G_RESOLVER_RECORD_MX: GResolverRecordType = GResolverRecordType::Mx;
pub const G_RESOLVER_RECORD_TXT: GResolverRecordType = GResolverRecordType::Txt;
pub const G_RESOLVER_RECORD_SOA: GResolverRecordType = GResolverRecordType::Soa;
pub const G_RESOLVER_RECORD_NS: GResolverRecordType = GResolverRecordType::Ns;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GResourceError {
    NotFound = 0,
    Internal = 1,
}
pub const G_RESOURCE_ERROR_NOT_FOUND: GResourceError = GResourceError::NotFound;
pub const G_RESOURCE_ERROR_INTERNAL: GResourceError = GResourceError::Internal;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSocketClientEvent {
    Resolving = 0,
    Resolved = 1,
    Connecting = 2,
    Connected = 3,
    ProxyNegotiating = 4,
    ProxyNegotiated = 5,
    TlsHandshaking = 6,
    TlsHandshaked = 7,
    Complete = 8,
}
pub const G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = GSocketClientEvent::Resolving;
pub const G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = GSocketClientEvent::Resolved;
pub const G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = GSocketClientEvent::Connecting;
pub const G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = GSocketClientEvent::Connected;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = GSocketClientEvent::ProxyNegotiating;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = GSocketClientEvent::ProxyNegotiated;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = GSocketClientEvent::TlsHandshaking;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = GSocketClientEvent::TlsHandshaked;
pub const G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = GSocketClientEvent::Complete;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSocketFamily {
    Invalid = 0,
    Unix = 1,
    Ipv4 = 2,
    Ipv6 = 10,
}
pub const G_SOCKET_FAMILY_INVALID: GSocketFamily = GSocketFamily::Invalid;
pub const G_SOCKET_FAMILY_UNIX: GSocketFamily = GSocketFamily::Unix;
pub const G_SOCKET_FAMILY_IPV4: GSocketFamily = GSocketFamily::Ipv4;
pub const G_SOCKET_FAMILY_IPV6: GSocketFamily = GSocketFamily::Ipv6;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSocketListenerEvent {
    Binding = 0,
    Bound = 1,
    Listening = 2,
    Listened = 3,
}
pub const G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = GSocketListenerEvent::Binding;
pub const G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = GSocketListenerEvent::Bound;
pub const G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = GSocketListenerEvent::Listening;
pub const G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = GSocketListenerEvent::Listened;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSocketProtocol {
    Unknown = -1,
    Default = 0,
    Tcp = 6,
    Udp = 17,
    Sctp = 132,
}
pub const G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = GSocketProtocol::Unknown;
pub const G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = GSocketProtocol::Default;
pub const G_SOCKET_PROTOCOL_TCP: GSocketProtocol = GSocketProtocol::Tcp;
pub const G_SOCKET_PROTOCOL_UDP: GSocketProtocol = GSocketProtocol::Udp;
pub const G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = GSocketProtocol::Sctp;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GSocketType {
    Invalid = 0,
    Stream = 1,
    Datagram = 2,
    Seqpacket = 3,
}
pub const G_SOCKET_TYPE_INVALID: GSocketType = GSocketType::Invalid;
pub const G_SOCKET_TYPE_STREAM: GSocketType = GSocketType::Stream;
pub const G_SOCKET_TYPE_DATAGRAM: GSocketType = GSocketType::Datagram;
pub const G_SOCKET_TYPE_SEQPACKET: GSocketType = GSocketType::Seqpacket;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTlsAuthenticationMode {
    None = 0,
    Requested = 1,
    Required = 2,
}
pub const G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = GTlsAuthenticationMode::None;
pub const G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = GTlsAuthenticationMode::Requested;
pub const G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = GTlsAuthenticationMode::Required;

pub type TlsCertificateRequestFlags = c_int;
pub const G_TLS_CERTIFICATE_REQUEST_NONE: TlsCertificateRequestFlags = 0;
pub type GTlsCertificateRequestFlags = TlsCertificateRequestFlags;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTlsDatabaseLookupFlags {
    None = 0,
    Keypair = 1,
}
pub const G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = GTlsDatabaseLookupFlags::None;
pub const G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = GTlsDatabaseLookupFlags::Keypair;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTlsError {
    Unavailable = 0,
    Misc = 1,
    BadCertificate = 2,
    NotTls = 3,
    Handshake = 4,
    CertificateRequired = 5,
    Eof = 6,
}
pub const G_TLS_ERROR_UNAVAILABLE: GTlsError = GTlsError::Unavailable;
pub const G_TLS_ERROR_MISC: GTlsError = GTlsError::Misc;
pub const G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = GTlsError::BadCertificate;
pub const G_TLS_ERROR_NOT_TLS: GTlsError = GTlsError::NotTls;
pub const G_TLS_ERROR_HANDSHAKE: GTlsError = GTlsError::Handshake;
pub const G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = GTlsError::CertificateRequired;
pub const G_TLS_ERROR_EOF: GTlsError = GTlsError::Eof;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTlsInteractionResult {
    Unhandled = 0,
    Handled = 1,
    Failed = 2,
}
pub const G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = GTlsInteractionResult::Unhandled;
pub const G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = GTlsInteractionResult::Handled;
pub const G_TLS_INTERACTION_FAILED: GTlsInteractionResult = GTlsInteractionResult::Failed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GTlsRehandshakeMode {
    Never = 0,
    Safely = 1,
    Unsafely = 2,
}
pub const G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = GTlsRehandshakeMode::Never;
pub const G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = GTlsRehandshakeMode::Safely;
pub const G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = GTlsRehandshakeMode::Unsafely;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GUnixSocketAddressType {
    Invalid = 0,
    Anonymous = 1,
    Path = 2,
    Abstract = 3,
    AbstractPadded = 4,
}
pub const G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = GUnixSocketAddressType::Invalid;
pub const G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = GUnixSocketAddressType::Anonymous;
pub const G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = GUnixSocketAddressType::Path;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = GUnixSocketAddressType::Abstract;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = GUnixSocketAddressType::AbstractPadded;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GZlibCompressorFormat {
    Zlib = 0,
    Gzip = 1,
    Raw = 2,
}
pub const G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = GZlibCompressorFormat::Zlib;
pub const G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = GZlibCompressorFormat::Gzip;
pub const G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = GZlibCompressorFormat::Raw;

// Constants
pub const G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: &'static str = r##"gio-desktop-app-info-lookup"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &'static str = r##"access::can-delete"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &'static str = r##"access::can-execute"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &'static str = r##"access::can-read"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &'static str = r##"access::can-rename"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &'static str = r##"access::can-trash"##;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &'static str = r##"access::can-write"##;
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &'static str = r##"dos::is-archive"##;
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &'static str = r##"dos::is-system"##;
pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &'static str = r##"etag::value"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &'static str = r##"filesystem::free"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &'static str = r##"filesystem::readonly"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE: &'static str = r##"filesystem::remote"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &'static str = r##"filesystem::size"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &'static str = r##"filesystem::type"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &'static str = r##"filesystem::used"##;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &'static str = r##"filesystem::use-preview"##;
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &'static str = r##"gvfs::backend"##;
pub const G_FILE_ATTRIBUTE_ID_FILE: &'static str = r##"id::file"##;
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &'static str = r##"id::filesystem"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &'static str = r##"mountable::can-eject"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &'static str = r##"mountable::can-mount"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &'static str = r##"mountable::can-poll"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &'static str = r##"mountable::can-start"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &'static str = r##"mountable::can-start-degraded"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &'static str = r##"mountable::can-stop"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &'static str = r##"mountable::can-unmount"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &'static str = r##"mountable::hal-udi"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &'static str = r##"mountable::is-media-check-automatic"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &'static str = r##"mountable::start-stop-type"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &'static str = r##"mountable::unix-device"##;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &'static str = r##"mountable::unix-device-file"##;
pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &'static str = r##"owner::group"##;
pub const G_FILE_ATTRIBUTE_OWNER_USER: &'static str = r##"owner::user"##;
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &'static str = r##"owner::user-real"##;
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &'static str = r##"preview::icon"##;
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &'static str = r##"selinux::context"##;
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &'static str = r##"standard::allocated-size"##;
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &'static str = r##"standard::content-type"##;
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &'static str = r##"standard::copy-name"##;
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &'static str = r##"standard::description"##;
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &'static str = r##"standard::display-name"##;
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &'static str = r##"standard::edit-name"##;
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &'static str = r##"standard::fast-content-type"##;
pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &'static str = r##"standard::icon"##;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &'static str = r##"standard::is-backup"##;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &'static str = r##"standard::is-hidden"##;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &'static str = r##"standard::is-symlink"##;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &'static str = r##"standard::is-virtual"##;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &'static str = r##"standard::is-volatile"##;
pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &'static str = r##"standard::name"##;
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &'static str = r##"standard::size"##;
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &'static str = r##"standard::sort-order"##;
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &'static str = r##"standard::symbolic-icon"##;
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &'static str = r##"standard::symlink-target"##;
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &'static str = r##"standard::target-uri"##;
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &'static str = r##"standard::type"##;
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &'static str = r##"thumbnail::failed"##;
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &'static str = r##"thumbnail::is-valid"##;
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &'static str = r##"thumbnail::path"##;
pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &'static str = r##"time::access"##;
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &'static str = r##"time::access-usec"##;
pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &'static str = r##"time::changed"##;
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &'static str = r##"time::changed-usec"##;
pub const G_FILE_ATTRIBUTE_TIME_CREATED: &'static str = r##"time::created"##;
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &'static str = r##"time::created-usec"##;
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &'static str = r##"time::modified"##;
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &'static str = r##"time::modified-usec"##;
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &'static str = r##"trash::deletion-date"##;
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &'static str = r##"trash::item-count"##;
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &'static str = r##"trash::orig-path"##;
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &'static str = r##"unix::blocks"##;
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &'static str = r##"unix::block-size"##;
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &'static str = r##"unix::device"##;
pub const G_FILE_ATTRIBUTE_UNIX_GID: &'static str = r##"unix::gid"##;
pub const G_FILE_ATTRIBUTE_UNIX_INODE: &'static str = r##"unix::inode"##;
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &'static str = r##"unix::is-mountpoint"##;
pub const G_FILE_ATTRIBUTE_UNIX_MODE: &'static str = r##"unix::mode"##;
pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &'static str = r##"unix::nlink"##;
pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &'static str = r##"unix::rdev"##;
pub const G_FILE_ATTRIBUTE_UNIX_UID: &'static str = r##"unix::uid"##;
pub const G_MENU_ATTRIBUTE_ACTION: &'static str = r##"action"##;
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &'static str = r##"action-namespace"##;
pub const G_MENU_ATTRIBUTE_ICON: &'static str = r##"icon"##;
pub const G_MENU_ATTRIBUTE_LABEL: &'static str = r##"label"##;
pub const G_MENU_ATTRIBUTE_TARGET: &'static str = r##"target"##;
pub const G_MENU_LINK_SECTION: &'static str = r##"section"##;
pub const G_MENU_LINK_SUBMENU: &'static str = r##"submenu"##;
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static str = r##"gio-native-volume-monitor"##;
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &'static str = r##"gio-network-monitor"##;
pub const G_PROXY_EXTENSION_POINT_NAME: &'static str = r##"gio-proxy"##;
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &'static str = r##"gio-proxy-resolver"##;
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &'static str = r##"gio-tls-backend"##;
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &'static str = r##"1.3.6.1.5.5.7.3.2"##;
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &'static str = r##"1.3.6.1.5.5.7.3.1"##;
pub const G_VFS_EXTENSION_POINT_NAME: &'static str = r##"gio-vfs"##;
pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &'static str = r##"class"##;
pub const G_VOLUME_IDENTIFIER_KIND_HAL_UDI: &'static str = r##"hal-udi"##;
pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &'static str = r##"label"##;
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &'static str = r##"nfs-mount"##;
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &'static str = r##"unix-device"##;
pub const G_VOLUME_IDENTIFIER_KIND_UUID: &'static str = r##"uuid"##;
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static str = r##"gio-volume-monitor"##;

// Flags
bitflags! {
    #[repr(C)]
    flags GAppInfoCreateFlags: c_uint {
        const G_APP_INFO_CREATE_NONE = 0,
        const G_APP_INFO_CREATE_NEEDS_TERMINAL = 1,
        const G_APP_INFO_CREATE_SUPPORTS_URIS = 2,
        const G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GApplicationFlags: c_uint {
        const G_APPLICATION_FLAGS_NONE = 0,
        const G_APPLICATION_IS_SERVICE = 1,
        const G_APPLICATION_IS_LAUNCHER = 2,
        const G_APPLICATION_HANDLES_OPEN = 4,
        const G_APPLICATION_HANDLES_COMMAND_LINE = 8,
        const G_APPLICATION_SEND_ENVIRONMENT = 16,
        const G_APPLICATION_NON_UNIQUE = 32,
        const G_APPLICATION_CAN_OVERRIDE_APP_ID = 64,
    }
}

bitflags! {
    #[repr(C)]
    flags GAskPasswordFlags: c_uint {
        const G_ASK_PASSWORD_NEED_PASSWORD = 1,
        const G_ASK_PASSWORD_NEED_USERNAME = 2,
        const G_ASK_PASSWORD_NEED_DOMAIN = 4,
        const G_ASK_PASSWORD_SAVING_SUPPORTED = 8,
        const G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16,
    }
}

bitflags! {
    #[repr(C)]
    flags GBusNameOwnerFlags: c_uint {
        const G_BUS_NAME_OWNER_FLAGS_NONE = 0,
        const G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1,
        const G_BUS_NAME_OWNER_FLAGS_REPLACE = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GBusNameWatcherFlags: c_uint {
        const G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
        const G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GConverterFlags: c_uint {
        const G_CONVERTER_NO_FLAGS = 0,
        const G_CONVERTER_INPUT_AT_END = 1,
        const G_CONVERTER_FLUSH = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusCallFlags: c_uint {
        const G_DBUS_CALL_FLAGS_NONE = 0,
        const G_DBUS_CALL_FLAGS_NO_AUTO_START = 1,
        const G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusCapabilityFlags: c_uint {
        const G_DBUS_CAPABILITY_FLAGS_NONE = 0,
        const G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusConnectionFlags: c_uint {
        const G_DBUS_CONNECTION_FLAGS_NONE = 0,
        const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1,
        const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2,
        const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4,
        const G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8,
        const G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusInterfaceSkeletonFlags: c_uint {
        const G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
        const G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusMessageFlags: c_uint {
        const G_DBUS_MESSAGE_FLAGS_NONE = 0,
        const G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1,
        const G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2,
        const G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusObjectManagerClientFlags: c_uint {
        const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
        const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusPropertyInfoFlags: c_uint {
        const G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
        const G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1,
        const G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusProxyFlags: c_uint {
        const G_DBUS_PROXY_FLAGS_NONE = 0,
        const G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1,
        const G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2,
        const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4,
        const G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8,
        const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusSendMessageFlags: c_uint {
        const G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
        const G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusServerFlags: c_uint {
        const G_DBUS_SERVER_FLAGS_NONE = 0,
        const G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1,
        const G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusSignalFlags: c_uint {
        const G_DBUS_SIGNAL_FLAGS_NONE = 0,
        const G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1,
        const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2,
        const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GDBusSubtreeFlags: c_uint {
        const G_DBUS_SUBTREE_FLAGS_NONE = 0,
        const G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GDriveStartFlags: c_uint {
        const G_DRIVE_START_NONE = 0,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileAttributeInfoFlags: c_uint {
        const G_FILE_ATTRIBUTE_INFO_NONE = 0,
        const G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1,
        const G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileCopyFlags: c_uint {
        const G_FILE_COPY_NONE = 0,
        const G_FILE_COPY_OVERWRITE = 1,
        const G_FILE_COPY_BACKUP = 2,
        const G_FILE_COPY_NOFOLLOW_SYMLINKS = 4,
        const G_FILE_COPY_ALL_METADATA = 8,
        const G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16,
        const G_FILE_COPY_TARGET_DEFAULT_PERMS = 32,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileCreateFlags: c_uint {
        const G_FILE_CREATE_NONE = 0,
        const G_FILE_CREATE_PRIVATE = 1,
        const G_FILE_CREATE_REPLACE_DESTINATION = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileMeasureFlags: c_uint {
        const G_FILE_MEASURE_NONE = 0,
        const G_FILE_MEASURE_REPORT_ANY_ERROR = 2,
        const G_FILE_MEASURE_APPARENT_SIZE = 4,
        const G_FILE_MEASURE_NO_XDEV = 8,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileMonitorFlags: c_uint {
        const G_FILE_MONITOR_NONE = 0,
        const G_FILE_MONITOR_WATCH_MOUNTS = 1,
        const G_FILE_MONITOR_SEND_MOVED = 2,
        const G_FILE_MONITOR_WATCH_HARD_LINKS = 4,
        const G_FILE_MONITOR_WATCH_MOVES = 8,
    }
}

bitflags! {
    #[repr(C)]
    flags GFileQueryInfoFlags: c_uint {
        const G_FILE_QUERY_INFO_NONE = 0,
        const G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GIOStreamSpliceFlags: c_uint {
        const G_IO_STREAM_SPLICE_NONE = 0,
        const G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1,
        const G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2,
        const G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GMountMountFlags: c_uint {
        const G_MOUNT_MOUNT_NONE = 0,
    }
}

bitflags! {
    #[repr(C)]
    flags GMountUnmountFlags: c_uint {
        const G_MOUNT_UNMOUNT_NONE = 0,
        const G_MOUNT_UNMOUNT_FORCE = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GOutputStreamSpliceFlags: c_uint {
        const G_OUTPUT_STREAM_SPLICE_NONE = 0,
        const G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1,
        const G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags GResourceFlags: c_uint {
        const G_RESOURCE_FLAGS_NONE = 0,
        const G_RESOURCE_FLAGS_COMPRESSED = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags GResourceLookupFlags: c_uint {
        const G_RESOURCE_LOOKUP_FLAGS_NONE = 0,
    }
}

bitflags! {
    #[repr(C)]
    flags GSettingsBindFlags: c_uint {
        const G_SETTINGS_BIND_DEFAULT = 0,
        const G_SETTINGS_BIND_GET = 1,
        const G_SETTINGS_BIND_SET = 2,
        const G_SETTINGS_BIND_NO_SENSITIVITY = 4,
        const G_SETTINGS_BIND_GET_NO_CHANGES = 8,
        const G_SETTINGS_BIND_INVERT_BOOLEAN = 16,
    }
}

bitflags! {
    #[repr(C)]
    flags GSocketMsgFlags: c_uint {
        const G_SOCKET_MSG_NONE = 0,
        const G_SOCKET_MSG_OOB = 1,
        const G_SOCKET_MSG_PEEK = 2,
        const G_SOCKET_MSG_DONTROUTE = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags GSubprocessFlags: c_uint {
        const G_SUBPROCESS_FLAGS_NONE = 0,
        const G_SUBPROCESS_FLAGS_STDIN_PIPE = 1,
        const G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2,
        const G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4,
        const G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8,
        const G_SUBPROCESS_FLAGS_STDERR_PIPE = 16,
        const G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32,
        const G_SUBPROCESS_FLAGS_STDERR_MERGE = 64,
        const G_SUBPROCESS_FLAGS_INHERIT_FDS = 128,
    }
}

bitflags! {
    #[repr(C)]
    flags GTestDBusFlags: c_uint {
        const G_TEST_DBUS_NONE = 0,
    }
}

bitflags! {
    #[repr(C)]
    flags GTlsCertificateFlags: c_uint {
        const G_TLS_CERTIFICATE_UNKNOWN_CA = 1,
        const G_TLS_CERTIFICATE_BAD_IDENTITY = 2,
        const G_TLS_CERTIFICATE_NOT_ACTIVATED = 4,
        const G_TLS_CERTIFICATE_EXPIRED = 8,
        const G_TLS_CERTIFICATE_REVOKED = 16,
        const G_TLS_CERTIFICATE_INSECURE = 32,
        const G_TLS_CERTIFICATE_GENERIC_ERROR = 64,
        const G_TLS_CERTIFICATE_VALIDATE_ALL = 127,
    }
}

bitflags! {
    #[repr(C)]
    flags GTlsDatabaseVerifyFlags: c_uint {
        const G_TLS_DATABASE_VERIFY_NONE = 0,
    }
}

bitflags! {
    #[repr(C)]
    flags GTlsPasswordFlags: c_uint {
        const G_TLS_PASSWORD_NONE = 0,
        const G_TLS_PASSWORD_RETRY = 2,
        const G_TLS_PASSWORD_MANY_TRIES = 4,
        const G_TLS_PASSWORD_FINAL_TRY = 8,
    }
}

// Callbacks
pub type GAsyncReadyCallback = Option<unsafe extern "C" fn(*mut gobject::GObject, *mut GAsyncResult, gpointer)>;
pub type GBusAcquiredCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, gpointer)>;
pub type GBusNameAcquiredCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, gpointer)>;
pub type GBusNameAppearedCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, gpointer)>;
pub type GBusNameLostCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, gpointer)>;
pub type GBusNameVanishedCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, gpointer)>;
pub type GCancellableSourceFunc = Option<unsafe extern "C" fn(*mut GCancellable, gpointer) -> gboolean>;
pub type GDBusInterfaceGetPropertyFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, *const c_char, *mut *mut glib::GError, gpointer) -> *mut glib::GVariant>;
pub type GDBusInterfaceMethodCallFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, *const c_char, *mut glib::GVariant, *mut GDBusMethodInvocation, gpointer)>;
pub type GDBusInterfaceSetPropertyFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, *const c_char, *mut glib::GVariant, *mut *mut glib::GError, gpointer) -> gboolean>;
pub type GDBusMessageFilterFunction = Option<unsafe extern "C" fn(*mut GDBusConnection, *mut GDBusMessage, gboolean, gpointer) -> *mut GDBusMessage>;
pub type GDBusProxyTypeFunc = Option<unsafe extern "C" fn(*mut GDBusObjectManagerClient, *const c_char, *const c_char, gpointer) -> GType>;
pub type GDBusSignalCallback = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, *const c_char, *mut glib::GVariant, gpointer)>;
pub type GDBusSubtreeDispatchFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, *const c_char, *mut gpointer, gpointer) -> *const GDBusInterfaceVTable>;
pub type GDBusSubtreeEnumerateFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, gpointer) -> *mut *mut c_char>;
pub type GDBusSubtreeIntrospectFunc = Option<unsafe extern "C" fn(*mut GDBusConnection, *const c_char, *const c_char, *const c_char, gpointer) -> *mut *mut GDBusInterfaceInfo>;
pub type GDatagramBasedSourceFunc = Option<unsafe extern "C" fn(*mut GDatagramBased, glib::GIOCondition, gpointer) -> gboolean>;
pub type GDesktopAppLaunchCallback = Option<unsafe extern "C" fn(*mut GDesktopAppInfo, glib::GPid, gpointer)>;
pub type GFileMeasureProgressCallback = Option<unsafe extern "C" fn(gboolean, u64, u64, u64, gpointer)>;
pub type GFileProgressCallback = Option<unsafe extern "C" fn(i64, i64, gpointer)>;
pub type GFileReadMoreCallback = Option<unsafe extern "C" fn(*const c_char, i64, gpointer) -> gboolean>;
pub type GIOSchedulerJobFunc = Option<unsafe extern "C" fn(*mut GIOSchedulerJob, *mut GCancellable, gpointer) -> gboolean>;
pub type GPollableSourceFunc = Option<unsafe extern "C" fn(*mut gobject::GObject, gpointer) -> gboolean>;
pub type GReallocFunc = Option<unsafe extern "C" fn(gpointer, size_t) -> gpointer>;
pub type GSettingsBindGetMapping = Option<unsafe extern "C" fn(*mut gobject::GValue, *mut glib::GVariant, gpointer) -> gboolean>;
pub type GSettingsBindSetMapping = Option<unsafe extern "C" fn(*const gobject::GValue, *const glib::GVariantType, gpointer) -> *mut glib::GVariant>;
pub type GSettingsGetMapping = Option<unsafe extern "C" fn(*mut glib::GVariant, *mut gpointer, gpointer) -> gboolean>;
pub type GSimpleAsyncThreadFunc = Option<unsafe extern "C" fn(*mut GSimpleAsyncResult, *mut gobject::GObject, *mut GCancellable)>;
pub type GSocketSourceFunc = Option<unsafe extern "C" fn(*mut GSocket, glib::GIOCondition, gpointer) -> gboolean>;
pub type GTaskThreadFunc = Option<unsafe extern "C" fn(*mut GTask, *mut gobject::GObject, gpointer, *mut GCancellable)>;
pub type GVfsFileLookupFunc = Option<unsafe extern "C" fn(*mut GVfs, *const c_char, gpointer) -> *mut GFile>;

// Records
#[repr(C)]
pub struct GActionEntry {
    pub name: *const c_char,
    pub activate: Option<unsafe extern "C" fn(*mut GSimpleAction, *mut glib::GVariant, gpointer)>,
    pub parameter_type: *const c_char,
    pub state: *const c_char,
    pub change_state: Option<unsafe extern "C" fn(*mut GSimpleAction, *mut glib::GVariant, gpointer)>,
    padding: [size_t; 3],
}

#[repr(C)]
pub struct GActionGroupInterface {
    pub g_iface: gobject::GTypeInterface,
    pub has_action: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> gboolean>,
    pub list_actions: Option<unsafe extern "C" fn(*mut GActionGroup) -> *mut *mut c_char>,
    pub get_action_enabled: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> gboolean>,
    pub get_action_parameter_type: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> *const glib::GVariantType>,
    pub get_action_state_type: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> *const glib::GVariantType>,
    pub get_action_state_hint: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> *mut glib::GVariant>,
    pub get_action_state: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char) -> *mut glib::GVariant>,
    pub change_action_state: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char, *mut glib::GVariant)>,
    pub activate_action: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char, *mut glib::GVariant)>,
    pub action_added: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char)>,
    pub action_removed: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char)>,
    pub action_enabled_changed: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char, gboolean)>,
    pub action_state_changed: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char, *mut glib::GVariant)>,
    pub query_action: Option<unsafe extern "C" fn(*mut GActionGroup, *const c_char, *mut gboolean, *mut *const glib::GVariantType, *mut *const glib::GVariantType, *mut *mut glib::GVariant, *mut *mut glib::GVariant) -> gboolean>,
}

#[repr(C)]
pub struct GActionInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_name: Option<unsafe extern "C" fn(*mut GAction) -> *const c_char>,
    pub get_parameter_type: Option<unsafe extern "C" fn(*mut GAction) -> *const glib::GVariantType>,
    pub get_state_type: Option<unsafe extern "C" fn(*mut GAction) -> *const glib::GVariantType>,
    pub get_state_hint: Option<unsafe extern "C" fn(*mut GAction) -> *mut glib::GVariant>,
    pub get_enabled: Option<unsafe extern "C" fn(*mut GAction) -> gboolean>,
    pub get_state: Option<unsafe extern "C" fn(*mut GAction) -> *mut glib::GVariant>,
    pub change_state: Option<unsafe extern "C" fn(*mut GAction, *mut glib::GVariant)>,
    pub activate: Option<unsafe extern "C" fn(*mut GAction, *mut glib::GVariant)>,
}

#[repr(C)]
pub struct GActionMapInterface {
    pub g_iface: gobject::GTypeInterface,
    pub lookup_action: Option<unsafe extern "C" fn(*mut GActionMap, *const c_char) -> *mut GAction>,
    pub add_action: Option<unsafe extern "C" fn(*mut GActionMap, *mut GAction)>,
    pub remove_action: Option<unsafe extern "C" fn(*mut GActionMap, *const c_char)>,
}

#[repr(C)]
pub struct GAppInfoIface {
    pub g_iface: gobject::GTypeInterface,
    pub dup: Option<unsafe extern "C" fn(*mut GAppInfo) -> *mut GAppInfo>,
    pub equal: Option<unsafe extern "C" fn(*mut GAppInfo, *mut GAppInfo) -> gboolean>,
    pub get_id: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub get_name: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub get_description: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub get_executable: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub get_icon: Option<unsafe extern "C" fn(*mut GAppInfo) -> *mut GIcon>,
    pub launch: Option<unsafe extern "C" fn(*mut GAppInfo, *mut glib::GList, *mut GAppLaunchContext, *mut *mut glib::GError) -> gboolean>,
    pub supports_uris: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub supports_files: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub launch_uris: Option<unsafe extern "C" fn(*mut GAppInfo, *mut glib::GList, *mut GAppLaunchContext, *mut *mut glib::GError) -> gboolean>,
    pub should_show: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: Option<unsafe extern "C" fn(*mut GAppInfo, *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub set_as_default_for_extension: Option<unsafe extern "C" fn(*mut GAppInfo, *mut c_char, *mut *mut glib::GError) -> gboolean>,
    pub add_supports_type: Option<unsafe extern "C" fn(*mut GAppInfo, *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub can_remove_supports_type: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub remove_supports_type: Option<unsafe extern "C" fn(*mut GAppInfo, *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub can_delete: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub do_delete: Option<unsafe extern "C" fn(*mut GAppInfo) -> gboolean>,
    pub get_commandline: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub get_display_name: Option<unsafe extern "C" fn(*mut GAppInfo) -> *const c_char>,
    pub set_as_last_used_for_type: Option<unsafe extern "C" fn(*mut GAppInfo, *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub get_supported_types: Option<unsafe extern "C" fn(*mut GAppInfo) -> *mut *mut c_char>,
}

#[repr(C)]
pub struct GAppLaunchContextClass {
    pub parent_class: gobject::GObjectClass,
    pub get_display: Option<unsafe extern "C" fn(*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GList) -> *mut c_char>,
    pub get_startup_notify_id: Option<unsafe extern "C" fn(*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GList) -> *mut c_char>,
    pub launch_failed: Option<unsafe extern "C" fn(*mut GAppLaunchContext, *const c_char)>,
    pub launched: Option<unsafe extern "C" fn(*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GVariant)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GAppLaunchContextPrivate(c_void);

#[repr(C)]
pub struct GApplicationClass {
    parent_class: gobject::GObjectClass,
    pub startup: Option<unsafe extern "C" fn(*mut GApplication)>,
    pub activate: Option<unsafe extern "C" fn(*mut GApplication)>,
    pub open: Option<unsafe extern "C" fn(*mut GApplication, *mut *mut GFile, c_int, *const c_char)>,
    pub command_line: Option<unsafe extern "C" fn(*mut GApplication, *mut GApplicationCommandLine) -> c_int>,
    pub local_command_line: Option<unsafe extern "C" fn(*mut GApplication, *mut *mut *mut c_char, *mut c_int) -> gboolean>,
    pub before_emit: Option<unsafe extern "C" fn(*mut GApplication, *mut glib::GVariant)>,
    pub after_emit: Option<unsafe extern "C" fn(*mut GApplication, *mut glib::GVariant)>,
    pub add_platform_data: Option<unsafe extern "C" fn(*mut GApplication, *mut glib::GVariantBuilder)>,
    pub quit_mainloop: Option<unsafe extern "C" fn(*mut GApplication)>,
    pub run_mainloop: Option<unsafe extern "C" fn(*mut GApplication)>,
    pub shutdown: Option<unsafe extern "C" fn(*mut GApplication)>,
    pub dbus_register: Option<unsafe extern "C" fn(*mut GApplication, *mut GDBusConnection, *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub dbus_unregister: Option<unsafe extern "C" fn(*mut GApplication, *mut GDBusConnection, *const c_char)>,
    pub handle_local_options: Option<unsafe extern "C" fn(*mut GApplication, *mut glib::GVariantDict) -> c_int>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GApplicationCommandLineClass {
    parent_class: gobject::GObjectClass,
    pub print_literal: Option<unsafe extern "C" fn(*mut GApplicationCommandLine, *const c_char)>,
    pub printerr_literal: Option<unsafe extern "C" fn(*mut GApplicationCommandLine, *const c_char)>,
    pub get_stdin: Option<unsafe extern "C" fn(*mut GApplicationCommandLine) -> *mut GInputStream>,
    padding: [gpointer; 11],
}

#[repr(C)]
pub struct GApplicationCommandLinePrivate(c_void);

#[repr(C)]
pub struct GApplicationPrivate(c_void);

#[repr(C)]
pub struct GAsyncInitableIface {
    pub g_iface: gobject::GTypeInterface,
    pub init_async: Option<unsafe extern "C" fn(*mut GAsyncInitable, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub init_finish: Option<unsafe extern "C" fn(*mut GAsyncInitable, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GAsyncResultIface {
    pub g_iface: gobject::GTypeInterface,
    pub get_user_data: Option<unsafe extern "C" fn(*mut GAsyncResult) -> gpointer>,
    pub get_source_object: Option<unsafe extern "C" fn(*mut GAsyncResult) -> *mut gobject::GObject>,
    pub is_tagged: Option<unsafe extern "C" fn(*mut GAsyncResult, gpointer) -> gboolean>,
}

#[repr(C)]
pub struct GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: Option<unsafe extern "C" fn(*mut GBufferedInputStream, ssize_t, *mut GCancellable, *mut *mut glib::GError) -> ssize_t>,
    pub fill_async: Option<unsafe extern "C" fn(*mut GBufferedInputStream, ssize_t, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub fill_finish: Option<unsafe extern "C" fn(*mut GBufferedInputStream, *mut GAsyncResult, *mut *mut glib::GError) -> ssize_t>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GBufferedInputStreamPrivate(c_void);

#[repr(C)]
pub struct GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GBufferedOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GCancellableClass {
    pub parent_class: gobject::GObjectClass,
    pub cancelled: Option<unsafe extern "C" fn(*mut GCancellable)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GCancellablePrivate(c_void);

#[repr(C)]
pub struct GCharsetConverterClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GConverterIface {
    pub g_iface: gobject::GTypeInterface,
    pub convert: Option<unsafe extern "C" fn(*mut GConverter, *mut u8, size_t, *mut u8, size_t, GConverterFlags, *mut size_t, *mut size_t, *mut *mut glib::GError) -> GConverterResult>,
    pub reset: Option<unsafe extern "C" fn(*mut GConverter)>,
}

#[repr(C)]
pub struct GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GConverterInputStreamPrivate(c_void);

#[repr(C)]
pub struct GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GConverterOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GCredentialsClass(c_void);

#[repr(C)]
pub struct GDBusAnnotationInfo {
    pub ref_count: Volatile<c_int>,
    pub key: *mut c_char,
    pub value: *mut c_char,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusArgInfo {
    pub ref_count: Volatile<c_int>,
    pub name: *mut c_char,
    pub signature: *mut c_char,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusErrorEntry {
    pub error_code: c_int,
    pub dbus_error_name: *const c_char,
}

#[repr(C)]
pub struct GDBusInterfaceIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_info: Option<unsafe extern "C" fn(*mut GDBusInterface) -> *mut GDBusInterfaceInfo>,
    pub get_object: Option<unsafe extern "C" fn(*mut GDBusInterface) -> *mut GDBusObject>,
    pub set_object: Option<unsafe extern "C" fn(*mut GDBusInterface, *mut GDBusObject)>,
    pub dup_object: Option<unsafe extern "C" fn(*mut GDBusInterface) -> *mut GDBusObject>,
}

#[repr(C)]
pub struct GDBusInterfaceInfo {
    pub ref_count: Volatile<c_int>,
    pub name: *mut c_char,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusInterfaceSkeletonClass {
    pub parent_class: gobject::GObjectClass,
    pub get_info: Option<unsafe extern "C" fn(*mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo>,
    pub get_vtable: Option<unsafe extern "C" fn(*mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable>,
    pub get_properties: Option<unsafe extern "C" fn(*mut GDBusInterfaceSkeleton) -> *mut glib::GVariant>,
    pub flush: Option<unsafe extern "C" fn(*mut GDBusInterfaceSkeleton)>,
    vfunc_padding: [gpointer; 8],
    pub g_authorize_method: Option<unsafe extern "C" fn(*mut GDBusInterfaceSkeleton, *mut GDBusMethodInvocation) -> gboolean>,
    signal_padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusInterfaceSkeletonPrivate(c_void);

#[repr(C)]
pub struct GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusMethodInfo {
    pub ref_count: Volatile<c_int>,
    pub name: *mut c_char,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusNodeInfo {
    pub ref_count: Volatile<c_int>,
    pub path: *mut c_char,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusObjectIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_object_path: Option<unsafe extern "C" fn(*mut GDBusObject) -> *const c_char>,
    pub get_interfaces: Option<unsafe extern "C" fn(*mut GDBusObject) -> *mut glib::GList>,
    pub get_interface: Option<unsafe extern "C" fn(*mut GDBusObject, *const c_char) -> *mut GDBusInterface>,
    pub interface_added: Option<unsafe extern "C" fn(*mut GDBusObject, *mut GDBusInterface)>,
    pub interface_removed: Option<unsafe extern "C" fn(*mut GDBusObject, *mut GDBusInterface)>,
}

#[repr(C)]
pub struct GDBusObjectManagerClientClass {
    pub parent_class: gobject::GObjectClass,
    pub interface_proxy_signal: Option<unsafe extern "C" fn(*mut GDBusObjectManagerClient, *mut GDBusObjectProxy, *mut GDBusProxy, *const c_char, *const c_char, *mut glib::GVariant)>,
    pub interface_proxy_properties_changed: Option<unsafe extern "C" fn(*mut GDBusObjectManagerClient, *mut GDBusObjectProxy, *mut GDBusProxy, *mut glib::GVariant, *const *const c_char)>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectManagerClientPrivate(c_void);

#[repr(C)]
pub struct GDBusObjectManagerIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_object_path: Option<unsafe extern "C" fn(*mut GDBusObjectManager) -> *const c_char>,
    pub get_objects: Option<unsafe extern "C" fn(*mut GDBusObjectManager) -> *mut glib::GList>,
    pub get_object: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *const c_char) -> *mut GDBusObject>,
    pub get_interface: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *const c_char, *const c_char) -> *mut GDBusInterface>,
    pub object_added: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *mut GDBusObject)>,
    pub object_removed: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *mut GDBusObject)>,
    pub interface_added: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *mut GDBusObject, *mut GDBusInterface)>,
    pub interface_removed: Option<unsafe extern "C" fn(*mut GDBusObjectManager, *mut GDBusObject, *mut GDBusInterface)>,
}

#[repr(C)]
pub struct GDBusObjectManagerServerClass {
    pub parent_class: gobject::GObjectClass,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectManagerServerPrivate(c_void);

#[repr(C)]
pub struct GDBusObjectProxyClass {
    pub parent_class: gobject::GObjectClass,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectProxyPrivate(c_void);

#[repr(C)]
pub struct GDBusObjectSkeletonClass {
    pub parent_class: gobject::GObjectClass,
    pub authorize_method: Option<unsafe extern "C" fn(*mut GDBusObjectSkeleton, *mut GDBusInterfaceSkeleton, *mut GDBusMethodInvocation) -> gboolean>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectSkeletonPrivate(c_void);

#[repr(C)]
pub struct GDBusPropertyInfo {
    pub ref_count: Volatile<c_int>,
    pub name: *mut c_char,
    pub signature: *mut c_char,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusProxyClass {
    parent_class: gobject::GObjectClass,
    pub g_properties_changed: Option<unsafe extern "C" fn(*mut GDBusProxy, *mut glib::GVariant, *const *const c_char)>,
    pub g_signal: Option<unsafe extern "C" fn(*mut GDBusProxy, *const c_char, *const c_char, *mut glib::GVariant)>,
    padding: [gpointer; 32],
}

#[repr(C)]
pub struct GDBusProxyPrivate(c_void);

#[repr(C)]
pub struct GDBusSignalInfo {
    pub ref_count: Volatile<c_int>,
    pub name: *mut c_char,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GDataInputStreamPrivate(c_void);

#[repr(C)]
pub struct GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GDataOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GDatagramBasedInterface {
    pub g_iface: gobject::GTypeInterface,
    pub receive_messages: Option<unsafe extern "C" fn(*mut GDatagramBased, *mut GInputMessage, c_uint, c_int, i64, *mut GCancellable, *mut *mut glib::GError) -> c_int>,
    pub send_messages: Option<unsafe extern "C" fn(*mut GDatagramBased, *mut GOutputMessage, c_uint, c_int, i64, *mut GCancellable, *mut *mut glib::GError) -> c_int>,
    pub create_source: Option<unsafe extern "C" fn(*mut GDatagramBased, glib::GIOCondition, *mut GCancellable) -> *mut glib::GSource>,
    pub condition_check: Option<unsafe extern "C" fn(*mut GDatagramBased, glib::GIOCondition) -> glib::GIOCondition>,
    pub condition_wait: Option<unsafe extern "C" fn(*mut GDatagramBased, glib::GIOCondition, i64, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GDesktopAppInfoClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GDesktopAppInfoLookupIface {
    pub g_iface: gobject::GTypeInterface,
    pub get_default_for_uri_scheme: Option<unsafe extern "C" fn(*mut GDesktopAppInfoLookup, *const c_char) -> *mut GAppInfo>,
}

#[repr(C)]
pub struct GDriveIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<unsafe extern "C" fn(*mut GDrive)>,
    pub disconnected: Option<unsafe extern "C" fn(*mut GDrive)>,
    pub eject_button: Option<unsafe extern "C" fn(*mut GDrive)>,
    pub get_name: Option<unsafe extern "C" fn(*mut GDrive) -> *const c_char>,
    pub get_icon: Option<unsafe extern "C" fn(*mut GDrive) -> *mut GIcon>,
    pub has_volumes: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub get_volumes: Option<unsafe extern "C" fn(*mut GDrive) -> *mut glib::GList>,
    pub is_media_removable: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub has_media: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub is_media_check_automatic: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub can_eject: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub can_poll_for_media: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub eject: Option<unsafe extern "C" fn(*mut GDrive, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_finish: Option<unsafe extern "C" fn(*mut GDrive, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub poll_for_media: Option<unsafe extern "C" fn(*mut GDrive, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub poll_for_media_finish: Option<unsafe extern "C" fn(*mut GDrive, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub get_identifier: Option<unsafe extern "C" fn(*mut GDrive, *const c_char) -> *mut c_char>,
    pub enumerate_identifiers: Option<unsafe extern "C" fn(*mut GDrive) -> *mut *mut c_char>,
    pub get_start_stop_type: Option<unsafe extern "C" fn(*mut GDrive) -> GDriveStartStopType>,
    pub can_start: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub can_start_degraded: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GDrive, GDriveStartFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub start_finish: Option<unsafe extern "C" fn(*mut GDrive, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub can_stop: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GDrive, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub stop_finish: Option<unsafe extern "C" fn(*mut GDrive, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub stop_button: Option<unsafe extern "C" fn(*mut GDrive)>,
    pub eject_with_operation: Option<unsafe extern "C" fn(*mut GDrive, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_with_operation_finish: Option<unsafe extern "C" fn(*mut GDrive, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub get_sort_key: Option<unsafe extern "C" fn(*mut GDrive) -> *const c_char>,
    pub get_symbolic_icon: Option<unsafe extern "C" fn(*mut GDrive) -> *mut GIcon>,
    pub is_removable: Option<unsafe extern "C" fn(*mut GDrive) -> gboolean>,
}

#[repr(C)]
pub struct GDtlsClientConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GDtlsConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
    pub accept_certificate: Option<unsafe extern "C" fn(*mut GDtlsConnection, *mut GTlsCertificate, GTlsCertificateFlags) -> gboolean>,
    pub handshake: Option<unsafe extern "C" fn(*mut GDtlsConnection, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub handshake_async: Option<unsafe extern "C" fn(*mut GDtlsConnection, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub handshake_finish: Option<unsafe extern "C" fn(*mut GDtlsConnection, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub shutdown: Option<unsafe extern "C" fn(*mut GDtlsConnection, gboolean, gboolean, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub shutdown_async: Option<unsafe extern "C" fn(*mut GDtlsConnection, gboolean, gboolean, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub shutdown_finish: Option<unsafe extern "C" fn(*mut GDtlsConnection, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GDtlsServerConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GEmblemClass(c_void);

#[repr(C)]
pub struct GEmblemedIconClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GEmblemedIconPrivate(c_void);

#[repr(C)]
pub struct GFileAttributeInfo {
    pub name: *mut c_char,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}

#[repr(C)]
pub struct GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: c_int,
}

#[repr(C)]
pub struct GFileAttributeMatcher(c_void);

#[repr(C)]
pub struct GFileDescriptorBasedIface {
    pub g_iface: gobject::GTypeInterface,
    pub get_fd: Option<unsafe extern "C" fn(*mut GFileDescriptorBased) -> c_int>,
}

#[repr(C)]
pub struct GFileEnumeratorClass {
    pub parent_class: gobject::GObjectClass,
    pub next_file: Option<unsafe extern "C" fn(*mut GFileEnumerator, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub close_fn: Option<unsafe extern "C" fn(*mut GFileEnumerator, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub next_files_async: Option<unsafe extern "C" fn(*mut GFileEnumerator, c_int, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub next_files_finish: Option<unsafe extern "C" fn(*mut GFileEnumerator, *mut GAsyncResult, *mut *mut glib::GError) -> *mut glib::GList>,
    pub close_async: Option<unsafe extern "C" fn(*mut GFileEnumerator, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub close_finish: Option<unsafe extern "C" fn(*mut GFileEnumerator, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFileEnumeratorPrivate(c_void);

#[repr(C)]
pub struct GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: Option<unsafe extern "C" fn(*mut GFileIOStream) -> i64>,
    pub can_seek: Option<unsafe extern "C" fn(*mut GFileIOStream) -> gboolean>,
    pub seek: Option<unsafe extern "C" fn(*mut GFileIOStream, i64, glib::GSeekType, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub can_truncate: Option<unsafe extern "C" fn(*mut GFileIOStream) -> gboolean>,
    pub truncate_fn: Option<unsafe extern "C" fn(*mut GFileIOStream, i64, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub query_info: Option<unsafe extern "C" fn(*mut GFileIOStream, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_info_async: Option<unsafe extern "C" fn(*mut GFileIOStream, *const c_char, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub query_info_finish: Option<unsafe extern "C" fn(*mut GFileIOStream, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub get_etag: Option<unsafe extern "C" fn(*mut GFileIOStream) -> *mut c_char>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFileIOStreamPrivate(c_void);

#[repr(C)]
pub struct GFileIconClass(c_void);

#[repr(C)]
pub struct GFileIface {
    pub g_iface: gobject::GTypeInterface,
    pub dup: Option<unsafe extern "C" fn(*mut GFile) -> *mut GFile>,
    pub hash: Option<unsafe extern "C" fn(*mut GFile) -> c_uint>,
    pub equal: Option<unsafe extern "C" fn(*mut GFile, *mut GFile) -> gboolean>,
    pub is_native: Option<unsafe extern "C" fn(*mut GFile) -> gboolean>,
    pub has_uri_scheme: Option<unsafe extern "C" fn(*mut GFile, *const c_char) -> gboolean>,
    pub get_uri_scheme: Option<unsafe extern "C" fn(*mut GFile) -> *mut c_char>,
    pub get_basename: Option<unsafe extern "C" fn(*mut GFile) -> *mut c_char>,
    pub get_path: Option<unsafe extern "C" fn(*mut GFile) -> *mut c_char>,
    pub get_uri: Option<unsafe extern "C" fn(*mut GFile) -> *mut c_char>,
    pub get_parse_name: Option<unsafe extern "C" fn(*mut GFile) -> *mut c_char>,
    pub get_parent: Option<unsafe extern "C" fn(*mut GFile) -> *mut GFile>,
    pub prefix_matches: Option<unsafe extern "C" fn(*mut GFile, *mut GFile) -> gboolean>,
    pub get_relative_path: Option<unsafe extern "C" fn(*mut GFile, *mut GFile) -> *mut c_char>,
    pub resolve_relative_path: Option<unsafe extern "C" fn(*mut GFile, *mut c_char) -> *mut GFile>,
    pub get_child_for_display_name: Option<unsafe extern "C" fn(*mut GFile, *const c_char, *mut *mut glib::GError) -> *mut GFile>,
    pub enumerate_children: Option<unsafe extern "C" fn(*mut GFile, *const c_char, GFileQueryInfoFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileEnumerator>,
    pub enumerate_children_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, GFileQueryInfoFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub enumerate_children_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileEnumerator>,
    pub query_info: Option<unsafe extern "C" fn(*mut GFile, *const c_char, GFileQueryInfoFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_info_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, GFileQueryInfoFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub query_info_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_filesystem_info: Option<unsafe extern "C" fn(*mut GFile, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_filesystem_info_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub query_filesystem_info_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub find_enclosing_mount: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> *mut GMount>,
    pub find_enclosing_mount_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub find_enclosing_mount_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GMount>,
    pub set_display_name: Option<unsafe extern "C" fn(*mut GFile, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GFile>,
    pub set_display_name_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub set_display_name_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFile>,
    pub query_settable_attributes: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileAttributeInfoList>,
    pub _query_settable_attributes_async: Option<unsafe extern "C" fn()>,
    pub _query_settable_attributes_finish: Option<unsafe extern "C" fn()>,
    pub query_writable_namespaces: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileAttributeInfoList>,
    pub _query_writable_namespaces_async: Option<unsafe extern "C" fn()>,
    pub _query_writable_namespaces_finish: Option<unsafe extern "C" fn()>,
    pub set_attribute: Option<unsafe extern "C" fn(*mut GFile, *const c_char, GFileAttributeType, gpointer, GFileQueryInfoFlags, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub set_attributes_from_info: Option<unsafe extern "C" fn(*mut GFile, *mut GFileInfo, GFileQueryInfoFlags, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub set_attributes_async: Option<unsafe extern "C" fn(*mut GFile, *mut GFileInfo, GFileQueryInfoFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub set_attributes_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut GFileInfo, *mut *mut glib::GError) -> gboolean>,
    pub read_fn: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInputStream>,
    pub read_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub read_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInputStream>,
    pub append_to: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub append_to_async: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub append_to_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub create: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub create_async: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub create_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub replace: Option<unsafe extern "C" fn(*mut GFile, *const c_char, gboolean, GFileCreateFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub replace_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, gboolean, GFileCreateFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub replace_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileOutputStream>,
    pub delete_file: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub delete_file_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub delete_file_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub trash: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub trash_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub trash_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub make_directory: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub make_directory_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub make_directory_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub make_symbolic_link: Option<unsafe extern "C" fn(*mut GFile, *mut c_char, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub _make_symbolic_link_async: Option<unsafe extern "C" fn()>,
    pub _make_symbolic_link_finish: Option<unsafe extern "C" fn()>,
    pub copy: Option<unsafe extern "C" fn(*mut GFile, *mut GFile, GFileCopyFlags, *mut GCancellable, GFileProgressCallback, gpointer, *mut *mut glib::GError) -> gboolean>,
    pub copy_async: Option<unsafe extern "C" fn(*mut GFile, *mut GFile, GFileCopyFlags, c_int, *mut GCancellable, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)>,
    pub copy_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub move_: Option<unsafe extern "C" fn(*mut GFile, *mut GFile, GFileCopyFlags, *mut GCancellable, GFileProgressCallback, gpointer, *mut *mut glib::GError) -> gboolean>,
    pub _move_async: Option<unsafe extern "C" fn()>,
    pub _move_finish: Option<unsafe extern "C" fn()>,
    pub mount_mountable: Option<unsafe extern "C" fn(*mut GFile, GMountMountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub mount_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFile>,
    pub unmount_mountable: Option<unsafe extern "C" fn(*mut GFile, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub unmount_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub eject_mountable: Option<unsafe extern "C" fn(*mut GFile, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub mount_enclosing_volume: Option<unsafe extern "C" fn(*mut GFile, GMountMountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub mount_enclosing_volume_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub monitor_dir: Option<unsafe extern "C" fn(*mut GFile, GFileMonitorFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileMonitor>,
    pub monitor_file: Option<unsafe extern "C" fn(*mut GFile, GFileMonitorFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileMonitor>,
    pub open_readwrite: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub open_readwrite_async: Option<unsafe extern "C" fn(*mut GFile, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub open_readwrite_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub create_readwrite: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub create_readwrite_async: Option<unsafe extern "C" fn(*mut GFile, GFileCreateFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub create_readwrite_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub replace_readwrite: Option<unsafe extern "C" fn(*mut GFile, *const c_char, gboolean, GFileCreateFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub replace_readwrite_async: Option<unsafe extern "C" fn(*mut GFile, *const c_char, gboolean, GFileCreateFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub replace_readwrite_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileIOStream>,
    pub start_mountable: Option<unsafe extern "C" fn(*mut GFile, GDriveStartFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub start_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub stop_mountable: Option<unsafe extern "C" fn(*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub stop_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: Option<unsafe extern "C" fn(*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub unmount_mountable_with_operation_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub eject_mountable_with_operation: Option<unsafe extern "C" fn(*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_mountable_with_operation_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub poll_mountable: Option<unsafe extern "C" fn(*mut GFile, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub poll_mountable_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub measure_disk_usage: Option<unsafe extern "C" fn(*mut GFile, GFileMeasureFlags, *mut GCancellable, GFileMeasureProgressCallback, gpointer, *mut u64, *mut u64, *mut u64, *mut *mut glib::GError) -> gboolean>,
    pub measure_disk_usage_async: Option<unsafe extern "C" fn(*mut GFile, GFileMeasureFlags, c_int, *mut GCancellable, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)>,
    pub measure_disk_usage_finish: Option<unsafe extern "C" fn(*mut GFile, *mut GAsyncResult, *mut u64, *mut u64, *mut u64, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GFileInfoClass(c_void);

#[repr(C)]
pub struct GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: Option<unsafe extern "C" fn(*mut GFileInputStream) -> i64>,
    pub can_seek: Option<unsafe extern "C" fn(*mut GFileInputStream) -> gboolean>,
    pub seek: Option<unsafe extern "C" fn(*mut GFileInputStream, i64, glib::GSeekType, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub query_info: Option<unsafe extern "C" fn(*mut GFileInputStream, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_info_async: Option<unsafe extern "C" fn(*mut GFileInputStream, *const c_char, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub query_info_finish: Option<unsafe extern "C" fn(*mut GFileInputStream, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFileInputStreamPrivate(c_void);

#[repr(C)]
pub struct GFileMonitorClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<unsafe extern "C" fn(*mut GFileMonitor, *mut GFile, *mut GFile, GFileMonitorEvent)>,
    pub cancel: Option<unsafe extern "C" fn(*mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFileMonitorPrivate(c_void);

#[repr(C)]
pub struct GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell: Option<unsafe extern "C" fn(*mut GFileOutputStream) -> i64>,
    pub can_seek: Option<unsafe extern "C" fn(*mut GFileOutputStream) -> gboolean>,
    pub seek: Option<unsafe extern "C" fn(*mut GFileOutputStream, i64, glib::GSeekType, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub can_truncate: Option<unsafe extern "C" fn(*mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: Option<unsafe extern "C" fn(*mut GFileOutputStream, i64, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub query_info: Option<unsafe extern "C" fn(*mut GFileOutputStream, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub query_info_async: Option<unsafe extern "C" fn(*mut GFileOutputStream, *const c_char, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub query_info_finish: Option<unsafe extern "C" fn(*mut GFileOutputStream, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GFileInfo>,
    pub get_etag: Option<unsafe extern "C" fn(*mut GFileOutputStream) -> *mut c_char>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFileOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GFilenameCompleterClass {
    pub parent_class: gobject::GObjectClass,
    pub got_completion_data: Option<unsafe extern "C" fn(*mut GFilenameCompleter)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GIOExtension(c_void);

#[repr(C)]
pub struct GIOExtensionPoint(c_void);

#[repr(C)]
pub struct GIOModuleClass(c_void);

#[repr(C)]
pub struct GIOModuleScope(c_void);

#[repr(C)]
pub struct GIOSchedulerJob(c_void);

#[repr(C)]
pub struct GIOStreamAdapter(c_void);

#[repr(C)]
pub struct GIOStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub get_input_stream: Option<unsafe extern "C" fn(*mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream: Option<unsafe extern "C" fn(*mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: Option<unsafe extern "C" fn(*mut GIOStream, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub close_async: Option<unsafe extern "C" fn(*mut GIOStream, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub close_finish: Option<unsafe extern "C" fn(*mut GIOStream, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
    pub _g_reserved8: Option<unsafe extern "C" fn()>,
    pub _g_reserved9: Option<unsafe extern "C" fn()>,
    pub _g_reserved10: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GIOStreamPrivate(c_void);

#[repr(C)]
pub struct GIconIface {
    pub g_iface: gobject::GTypeInterface,
    pub hash: Option<unsafe extern "C" fn(*mut GIcon) -> c_uint>,
    pub equal: Option<unsafe extern "C" fn(*mut GIcon, *mut GIcon) -> gboolean>,
    pub to_tokens: Option<unsafe extern "C" fn(*mut GIcon, *mut glib::GPtrArray, *mut c_int) -> gboolean>,
    pub from_tokens: Option<unsafe extern "C" fn(*mut *mut c_char, c_int, c_int, *mut *mut glib::GError) -> *mut GIcon>,
    pub serialize: Option<unsafe extern "C" fn(*mut GIcon) -> *mut glib::GVariant>,
}

#[repr(C)]
pub struct GInetAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub to_string: Option<unsafe extern "C" fn(*mut GInetAddress) -> *mut c_char>,
    pub to_bytes: Option<unsafe extern "C" fn(*mut GInetAddress) -> *const u8>,
}

#[repr(C)]
pub struct GInetAddressMaskClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GInetAddressMaskPrivate(c_void);

#[repr(C)]
pub struct GInetAddressPrivate(c_void);

#[repr(C)]
pub struct GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}

#[repr(C)]
pub struct GInetSocketAddressPrivate(c_void);

#[repr(C)]
pub struct GInitableIface {
    pub g_iface: gobject::GTypeInterface,
    pub init: Option<unsafe extern "C" fn(*mut GInitable, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: c_uint,
    pub bytes_received: size_t,
    pub flags: c_int,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: *mut c_uint,
}

#[repr(C)]
pub struct GInputStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub read_fn: Option<unsafe extern "C" fn(*mut GInputStream, *mut c_void, size_t, *mut GCancellable, *mut *mut glib::GError) -> ssize_t>,
    pub skip: Option<unsafe extern "C" fn(*mut GInputStream, size_t, *mut GCancellable, *mut *mut glib::GError) -> ssize_t>,
    pub close_fn: Option<unsafe extern "C" fn(*mut GInputStream, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub read_async: Option<unsafe extern "C" fn(*mut GInputStream, *mut u8, size_t, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub read_finish: Option<unsafe extern "C" fn(*mut GInputStream, *mut GAsyncResult, *mut *mut glib::GError) -> ssize_t>,
    pub skip_async: Option<unsafe extern "C" fn(*mut GInputStream, size_t, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub skip_finish: Option<unsafe extern "C" fn(*mut GInputStream, *mut GAsyncResult, *mut *mut glib::GError) -> ssize_t>,
    pub close_async: Option<unsafe extern "C" fn(*mut GInputStream, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub close_finish: Option<unsafe extern "C" fn(*mut GInputStream, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GInputStreamPrivate(c_void);

#[repr(C)]
pub struct GInputVector {
    pub buffer: gpointer,
    pub size: size_t,
}

#[repr(C)]
pub struct GListModelInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_item_type: Option<unsafe extern "C" fn(*mut GListModel) -> GType>,
    pub get_n_items: Option<unsafe extern "C" fn(*mut GListModel) -> c_uint>,
    pub get_item: Option<unsafe extern "C" fn(*mut GListModel, c_uint) -> gpointer>,
}

#[repr(C)]
pub struct GListStoreClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GLoadableIconIface {
    pub g_iface: gobject::GTypeInterface,
    pub load: Option<unsafe extern "C" fn(*mut GLoadableIcon, c_int, *mut *mut c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut GInputStream>,
    pub load_async: Option<unsafe extern "C" fn(*mut GLoadableIcon, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub load_finish: Option<unsafe extern "C" fn(*mut GLoadableIcon, *mut GAsyncResult, *mut *mut c_char, *mut *mut glib::GError) -> *mut GInputStream>,
}

#[repr(C)]
pub struct GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GMemoryInputStreamPrivate(c_void);

#[repr(C)]
pub struct GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GMemoryOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GMenuAttributeIterClass {
    pub parent_class: gobject::GObjectClass,
    pub get_next: Option<unsafe extern "C" fn(*mut GMenuAttributeIter, *mut *const c_char, *mut *mut glib::GVariant) -> gboolean>,
}

#[repr(C)]
pub struct GMenuAttributeIterPrivate(c_void);

#[repr(C)]
pub struct GMenuLinkIterClass {
    pub parent_class: gobject::GObjectClass,
    pub get_next: Option<unsafe extern "C" fn(*mut GMenuLinkIter, *mut *const c_char, *mut *mut GMenuModel) -> gboolean>,
}

#[repr(C)]
pub struct GMenuLinkIterPrivate(c_void);

#[repr(C)]
pub struct GMenuModelClass {
    pub parent_class: gobject::GObjectClass,
    pub is_mutable: Option<unsafe extern "C" fn(*mut GMenuModel) -> gboolean>,
    pub get_n_items: Option<unsafe extern "C" fn(*mut GMenuModel) -> c_int>,
    pub get_item_attributes: Option<unsafe extern "C" fn(*mut GMenuModel, c_int, *mut *mut glib::GHashTable)>,
    pub iterate_item_attributes: Option<unsafe extern "C" fn(*mut GMenuModel, c_int) -> *mut GMenuAttributeIter>,
    pub get_item_attribute_value: Option<unsafe extern "C" fn(*mut GMenuModel, c_int, *const c_char, *const glib::GVariantType) -> *mut glib::GVariant>,
    pub get_item_links: Option<unsafe extern "C" fn(*mut GMenuModel, c_int, *mut *mut glib::GHashTable)>,
    pub iterate_item_links: Option<unsafe extern "C" fn(*mut GMenuModel, c_int) -> *mut GMenuLinkIter>,
    pub get_item_link: Option<unsafe extern "C" fn(*mut GMenuModel, c_int, *const c_char) -> *mut GMenuModel>,
}

#[repr(C)]
pub struct GMenuModelPrivate(c_void);

#[repr(C)]
pub struct GMountIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<unsafe extern "C" fn(*mut GMount)>,
    pub unmounted: Option<unsafe extern "C" fn(*mut GMount)>,
    pub get_root: Option<unsafe extern "C" fn(*mut GMount) -> *mut GFile>,
    pub get_name: Option<unsafe extern "C" fn(*mut GMount) -> *const c_char>,
    pub get_icon: Option<unsafe extern "C" fn(*mut GMount) -> *mut GIcon>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut GMount) -> *const c_char>,
    pub get_volume: Option<unsafe extern "C" fn(*mut GMount) -> *mut GVolume>,
    pub get_drive: Option<unsafe extern "C" fn(*mut GMount) -> *mut GDrive>,
    pub can_unmount: Option<unsafe extern "C" fn(*mut GMount) -> gboolean>,
    pub can_eject: Option<unsafe extern "C" fn(*mut GMount) -> gboolean>,
    pub unmount: Option<unsafe extern "C" fn(*mut GMount, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub unmount_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub eject: Option<unsafe extern "C" fn(*mut GMount, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub remount: Option<unsafe extern "C" fn(*mut GMount, GMountMountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub remount_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub guess_content_type: Option<unsafe extern "C" fn(*mut GMount, gboolean, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub guess_content_type_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> *mut *mut c_char>,
    pub guess_content_type_sync: Option<unsafe extern "C" fn(*mut GMount, gboolean, *mut GCancellable, *mut *mut glib::GError) -> *mut *mut c_char>,
    pub pre_unmount: Option<unsafe extern "C" fn(*mut GMount)>,
    pub unmount_with_operation: Option<unsafe extern "C" fn(*mut GMount, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub unmount_with_operation_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub eject_with_operation: Option<unsafe extern "C" fn(*mut GMount, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_with_operation_finish: Option<unsafe extern "C" fn(*mut GMount, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub get_default_location: Option<unsafe extern "C" fn(*mut GMount) -> *mut GFile>,
    pub get_sort_key: Option<unsafe extern "C" fn(*mut GMount) -> *const c_char>,
    pub get_symbolic_icon: Option<unsafe extern "C" fn(*mut GMount) -> *mut GIcon>,
}

#[repr(C)]
pub struct GMountOperationClass {
    pub parent_class: gobject::GObjectClass,
    pub ask_password: Option<unsafe extern "C" fn(*mut GMountOperation, *const c_char, *const c_char, *const c_char, GAskPasswordFlags)>,
    pub ask_question: Option<unsafe extern "C" fn(*mut GMountOperation, *const c_char, *const c_char)>,
    pub reply: Option<unsafe extern "C" fn(*mut GMountOperation, GMountOperationResult)>,
    pub aborted: Option<unsafe extern "C" fn(*mut GMountOperation)>,
    pub show_processes: Option<unsafe extern "C" fn(*mut GMountOperation, *const c_char, *mut glib::GArray, *const c_char)>,
    pub show_unmount_progress: Option<unsafe extern "C" fn(*mut GMountOperation, *const c_char, i64, i64)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
    pub _g_reserved8: Option<unsafe extern "C" fn()>,
    pub _g_reserved9: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GMountOperationPrivate(c_void);

#[repr(C)]
pub struct GNativeSocketAddress(c_void);

#[repr(C)]
pub struct GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: Option<unsafe extern "C" fn(*const c_char, *mut GCancellable) -> *mut GMount>,
}

#[repr(C)]
pub struct GNetworkAddressClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GNetworkAddressPrivate(c_void);

#[repr(C)]
pub struct GNetworkMonitorInterface {
    pub g_iface: gobject::GTypeInterface,
    pub network_changed: Option<unsafe extern "C" fn(*mut GNetworkMonitor, gboolean)>,
    pub can_reach: Option<unsafe extern "C" fn(*mut GNetworkMonitor, *mut GSocketConnectable, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub can_reach_async: Option<unsafe extern "C" fn(*mut GNetworkMonitor, *mut GSocketConnectable, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub can_reach_finish: Option<unsafe extern "C" fn(*mut GNetworkMonitor, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GNetworkServiceClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GNetworkServicePrivate(c_void);

#[repr(C)]
pub struct GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: c_uint,
    pub bytes_sent: c_uint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: c_uint,
}

#[repr(C)]
pub struct GOutputStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub write_fn: Option<unsafe extern "C" fn(*mut GOutputStream, *mut u8, size_t, *mut GCancellable, *mut *mut glib::GError) -> ssize_t>,
    pub splice: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GInputStream, GOutputStreamSpliceFlags, *mut GCancellable, *mut *mut glib::GError) -> ssize_t>,
    pub flush: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub close_fn: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub write_async: Option<unsafe extern "C" fn(*mut GOutputStream, *mut u8, size_t, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub write_finish: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GAsyncResult, *mut *mut glib::GError) -> ssize_t>,
    pub splice_async: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GInputStream, GOutputStreamSpliceFlags, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub splice_finish: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GAsyncResult, *mut *mut glib::GError) -> ssize_t>,
    pub flush_async: Option<unsafe extern "C" fn(*mut GOutputStream, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub flush_finish: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub close_async: Option<unsafe extern "C" fn(*mut GOutputStream, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub close_finish: Option<unsafe extern "C" fn(*mut GOutputStream, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
    pub _g_reserved8: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GOutputVector {
    pub buffer: gconstpointer,
    pub size: size_t,
}

#[repr(C)]
pub struct GPermissionClass {
    pub parent_class: gobject::GObjectClass,
    pub acquire: Option<unsafe extern "C" fn(*mut GPermission, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub acquire_async: Option<unsafe extern "C" fn(*mut GPermission, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub acquire_finish: Option<unsafe extern "C" fn(*mut GPermission, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub release: Option<unsafe extern "C" fn(*mut GPermission, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub release_async: Option<unsafe extern "C" fn(*mut GPermission, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub release_finish: Option<unsafe extern "C" fn(*mut GPermission, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub reserved: [gpointer; 16],
}

#[repr(C)]
pub struct GPermissionPrivate(c_void);

#[repr(C)]
pub struct GPollableInputStreamInterface {
    pub g_iface: gobject::GTypeInterface,
    pub can_poll: Option<unsafe extern "C" fn(*mut GPollableInputStream) -> gboolean>,
    pub is_readable: Option<unsafe extern "C" fn(*mut GPollableInputStream) -> gboolean>,
    pub create_source: Option<unsafe extern "C" fn(*mut GPollableInputStream, *mut GCancellable) -> *mut glib::GSource>,
    pub read_nonblocking: Option<unsafe extern "C" fn(*mut GPollableInputStream, *mut u8, size_t, *mut *mut glib::GError) -> ssize_t>,
}

#[repr(C)]
pub struct GPollableOutputStreamInterface {
    pub g_iface: gobject::GTypeInterface,
    pub can_poll: Option<unsafe extern "C" fn(*mut GPollableOutputStream) -> gboolean>,
    pub is_writable: Option<unsafe extern "C" fn(*mut GPollableOutputStream) -> gboolean>,
    pub create_source: Option<unsafe extern "C" fn(*mut GPollableOutputStream, *mut GCancellable) -> *mut glib::GSource>,
    pub write_nonblocking: Option<unsafe extern "C" fn(*mut GPollableOutputStream, *mut u8, size_t, *mut *mut glib::GError) -> ssize_t>,
}

#[repr(C)]
pub struct GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}

#[repr(C)]
pub struct GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GProxyAddressEnumeratorPrivate(c_void);

#[repr(C)]
pub struct GProxyAddressPrivate(c_void);

#[repr(C)]
pub struct GProxyInterface {
    pub g_iface: gobject::GTypeInterface,
    pub connect: Option<unsafe extern "C" fn(*mut GProxy, *mut GIOStream, *mut GProxyAddress, *mut GCancellable, *mut *mut glib::GError) -> *mut GIOStream>,
    pub connect_async: Option<unsafe extern "C" fn(*mut GProxy, *mut GIOStream, *mut GProxyAddress, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub connect_finish: Option<unsafe extern "C" fn(*mut GProxy, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GIOStream>,
    pub supports_hostname: Option<unsafe extern "C" fn(*mut GProxy) -> gboolean>,
}

#[repr(C)]
pub struct GProxyResolverInterface {
    pub g_iface: gobject::GTypeInterface,
    pub is_supported: Option<unsafe extern "C" fn(*mut GProxyResolver) -> gboolean>,
    pub lookup: Option<unsafe extern "C" fn(*mut GProxyResolver, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut *mut c_char>,
    pub lookup_async: Option<unsafe extern "C" fn(*mut GProxyResolver, *const c_char, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_finish: Option<unsafe extern "C" fn(*mut GProxyResolver, *mut GAsyncResult, *mut *mut glib::GError) -> *mut *mut c_char>,
}

#[repr(C)]
pub struct GRemoteActionGroupInterface {
    pub g_iface: gobject::GTypeInterface,
    pub activate_action_full: Option<unsafe extern "C" fn(*mut GRemoteActionGroup, *const c_char, *mut glib::GVariant, *mut glib::GVariant)>,
    pub change_action_state_full: Option<unsafe extern "C" fn(*mut GRemoteActionGroup, *const c_char, *mut glib::GVariant, *mut glib::GVariant)>,
}

#[repr(C)]
pub struct GResolverClass {
    pub parent_class: gobject::GObjectClass,
    pub reload: Option<unsafe extern "C" fn(*mut GResolver)>,
    pub lookup_by_name: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_by_name_async: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_by_name_finish: Option<unsafe extern "C" fn(*mut GResolver, *mut GAsyncResult, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_by_address: Option<unsafe extern "C" fn(*mut GResolver, *mut GInetAddress, *mut GCancellable, *mut *mut glib::GError) -> *mut c_char>,
    pub lookup_by_address_async: Option<unsafe extern "C" fn(*mut GResolver, *mut GInetAddress, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_by_address_finish: Option<unsafe extern "C" fn(*mut GResolver, *mut GAsyncResult, *mut *mut glib::GError) -> *mut c_char>,
    pub lookup_service: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, *mut GCancellable, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_service_async: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_service_finish: Option<unsafe extern "C" fn(*mut GResolver, *mut GAsyncResult, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_records: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, GResolverRecordType, *mut GCancellable, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_records_async: Option<unsafe extern "C" fn(*mut GResolver, *const c_char, GResolverRecordType, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_records_finish: Option<unsafe extern "C" fn(*mut GResolver, *mut GAsyncResult, *mut *mut glib::GError) -> *mut glib::GList>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GResolverPrivate(c_void);

#[repr(C)]
pub struct GResource(c_void);

#[repr(C)]
pub struct GSeekableIface {
    pub g_iface: gobject::GTypeInterface,
    pub tell: Option<unsafe extern "C" fn(*mut GSeekable) -> i64>,
    pub can_seek: Option<unsafe extern "C" fn(*mut GSeekable) -> gboolean>,
    pub seek: Option<unsafe extern "C" fn(*mut GSeekable, i64, glib::GSeekType, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub can_truncate: Option<unsafe extern "C" fn(*mut GSeekable) -> gboolean>,
    pub truncate_fn: Option<unsafe extern "C" fn(*mut GSeekable, i64, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GSettingsBackend(c_void);

#[repr(C)]
pub struct GSettingsClass {
    pub parent_class: gobject::GObjectClass,
    pub writable_changed: Option<unsafe extern "C" fn(*mut GSettings, *const c_char)>,
    pub changed: Option<unsafe extern "C" fn(*mut GSettings, *const c_char)>,
    pub writable_change_event: Option<unsafe extern "C" fn(*mut GSettings, glib::GQuark) -> gboolean>,
    pub change_event: Option<unsafe extern "C" fn(*mut GSettings, *const glib::GQuark, c_int) -> gboolean>,
    pub padding: [gpointer; 20],
}

#[repr(C)]
pub struct GSettingsPrivate(c_void);

#[repr(C)]
pub struct GSettingsSchema(c_void);

#[repr(C)]
pub struct GSettingsSchemaKey(c_void);

#[repr(C)]
pub struct GSettingsSchemaSource(c_void);

#[repr(C)]
pub struct GSimpleActionGroupClass {
    parent_class: gobject::GObjectClass,
    padding: [gpointer; 12],
}

#[repr(C)]
pub struct GSimpleActionGroupPrivate(c_void);

#[repr(C)]
pub struct GSimpleAsyncResultClass(c_void);

#[repr(C)]
pub struct GSimpleProxyResolverClass {
    pub parent_class: gobject::GObjectClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSimpleProxyResolverPrivate(c_void);

#[repr(C)]
pub struct GSocketAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub get_family: Option<unsafe extern "C" fn(*mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size: Option<unsafe extern "C" fn(*mut GSocketAddress) -> ssize_t>,
    pub to_native: Option<unsafe extern "C" fn(*mut GSocketAddress, gpointer, size_t, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GSocketAddressEnumeratorClass {
    pub parent_class: gobject::GObjectClass,
    pub next: Option<unsafe extern "C" fn(*mut GSocketAddressEnumerator, *mut GCancellable, *mut *mut glib::GError) -> *mut GSocketAddress>,
    pub next_async: Option<unsafe extern "C" fn(*mut GSocketAddressEnumerator, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub next_finish: Option<unsafe extern "C" fn(*mut GSocketAddressEnumerator, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GSocketAddress>,
}

#[repr(C)]
pub struct GSocketClass {
    pub parent_class: gobject::GObjectClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
    pub _g_reserved7: Option<unsafe extern "C" fn()>,
    pub _g_reserved8: Option<unsafe extern "C" fn()>,
    pub _g_reserved9: Option<unsafe extern "C" fn()>,
    pub _g_reserved10: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketClientClass {
    pub parent_class: gobject::GObjectClass,
    pub event: Option<unsafe extern "C" fn(*mut GSocketClient, GSocketClientEvent, *mut GSocketConnectable, *mut GIOStream)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketClientPrivate(c_void);

#[repr(C)]
pub struct GSocketConnectableIface {
    pub g_iface: gobject::GTypeInterface,
    pub enumerate: Option<unsafe extern "C" fn(*mut GSocketConnectable) -> *mut GSocketAddressEnumerator>,
    pub proxy_enumerate: Option<unsafe extern "C" fn(*mut GSocketConnectable) -> *mut GSocketAddressEnumerator>,
    pub to_string: Option<unsafe extern "C" fn(*mut GSocketConnectable) -> *mut c_char>,
}

#[repr(C)]
pub struct GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketConnectionPrivate(c_void);

#[repr(C)]
pub struct GSocketControlMessageClass {
    pub parent_class: gobject::GObjectClass,
    pub get_size: Option<unsafe extern "C" fn(*mut GSocketControlMessage) -> size_t>,
    pub get_level: Option<unsafe extern "C" fn(*mut GSocketControlMessage) -> c_int>,
    pub get_type: Option<unsafe extern "C" fn(*mut GSocketControlMessage) -> c_int>,
    pub serialize: Option<unsafe extern "C" fn(*mut GSocketControlMessage, gpointer)>,
    pub deserialize: Option<unsafe extern "C" fn(c_int, c_int, size_t, gpointer) -> *mut GSocketControlMessage>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketControlMessagePrivate(c_void);

#[repr(C)]
pub struct GSocketListenerClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<unsafe extern "C" fn(*mut GSocketListener)>,
    pub event: Option<unsafe extern "C" fn(*mut GSocketListener, *mut GSocketListenerEvent, *mut GSocket)>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketListenerPrivate(c_void);

#[repr(C)]
pub struct GSocketPrivate(c_void);

#[repr(C)]
pub struct GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: Option<unsafe extern "C" fn(*mut GSocketService, *mut GSocketConnection, *mut gobject::GObject) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GSocketServicePrivate(c_void);

#[repr(C)]
pub struct GSrvTarget(c_void);

#[repr(C)]
pub struct GStaticResource {
    data: *const u8,
    data_len: size_t,
    resource: *mut GResource,
    next: *mut GStaticResource,
    padding: gpointer,
}

#[repr(C)]
pub struct GTaskClass(c_void);

#[repr(C)]
pub struct GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}

#[repr(C)]
pub struct GTcpConnectionPrivate(c_void);

#[repr(C)]
pub struct GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}

#[repr(C)]
pub struct GTcpWrapperConnectionPrivate(c_void);

#[repr(C)]
pub struct GThemedIconClass(c_void);

#[repr(C)]
pub struct GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: Option<unsafe extern "C" fn(*mut GThreadedSocketService, *mut GSocketConnection, *mut gobject::GObject) -> gboolean>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GThreadedSocketServicePrivate(c_void);

#[repr(C)]
pub struct GTlsBackendInterface {
    pub g_iface: gobject::GTypeInterface,
    pub supports_tls: Option<unsafe extern "C" fn(*mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: Option<unsafe extern "C" fn() -> GType>,
    pub get_client_connection_type: Option<unsafe extern "C" fn() -> GType>,
    pub get_server_connection_type: Option<unsafe extern "C" fn() -> GType>,
    pub get_file_database_type: Option<unsafe extern "C" fn() -> GType>,
    pub get_default_database: Option<unsafe extern "C" fn(*mut GTlsBackend) -> *mut GTlsDatabase>,
    pub supports_dtls: Option<unsafe extern "C" fn(*mut GTlsBackend) -> gboolean>,
    pub get_dtls_client_connection_type: Option<unsafe extern "C" fn() -> GType>,
    pub get_dtls_server_connection_type: Option<unsafe extern "C" fn() -> GType>,
}

#[repr(C)]
pub struct GTlsCertificateClass {
    pub parent_class: gobject::GObjectClass,
    pub verify: Option<unsafe extern "C" fn(*mut GTlsCertificate, *mut GSocketConnectable, *mut GTlsCertificate) -> GTlsCertificateFlags>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GTlsCertificatePrivate(c_void);

#[repr(C)]
pub struct GTlsClientConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
    pub copy_session_state: Option<unsafe extern "C" fn(*mut GTlsClientConnection, *mut GTlsClientConnection)>,
}

#[repr(C)]
pub struct GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: Option<unsafe extern "C" fn(*mut GTlsConnection, *mut GTlsCertificate, GTlsCertificateFlags) -> gboolean>,
    pub handshake: Option<unsafe extern "C" fn(*mut GTlsConnection, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub handshake_async: Option<unsafe extern "C" fn(*mut GTlsConnection, c_int, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub handshake_finish: Option<unsafe extern "C" fn(*mut GTlsConnection, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GTlsConnectionPrivate(c_void);

#[repr(C)]
pub struct GTlsDatabaseClass {
    pub parent_class: gobject::GObjectClass,
    pub verify_chain: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GTlsCertificate, *const c_char, *mut GSocketConnectable, *mut GTlsInteraction, GTlsDatabaseVerifyFlags, *mut GCancellable, *mut *mut glib::GError) -> GTlsCertificateFlags>,
    pub verify_chain_async: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GTlsCertificate, *const c_char, *mut GSocketConnectable, *mut GTlsInteraction, GTlsDatabaseVerifyFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub verify_chain_finish: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GAsyncResult, *mut *mut glib::GError) -> GTlsCertificateFlags>,
    pub create_certificate_handle: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GTlsCertificate) -> *mut c_char>,
    pub lookup_certificate_for_handle: Option<unsafe extern "C" fn(*mut GTlsDatabase, *const c_char, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GTlsCertificate>,
    pub lookup_certificate_for_handle_async: Option<unsafe extern "C" fn(*mut GTlsDatabase, *const c_char, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_certificate_for_handle_finish: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GTlsCertificate>,
    pub lookup_certificate_issuer: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GTlsCertificate, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut GTlsCertificate>,
    pub lookup_certificate_issuer_async: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GTlsCertificate, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_certificate_issuer_finish: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GAsyncResult, *mut *mut glib::GError) -> *mut GTlsCertificate>,
    pub lookup_certificates_issued_by: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut glib::GByteArray, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, *mut *mut glib::GError) -> *mut glib::GList>,
    pub lookup_certificates_issued_by_async: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut glib::GByteArray, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub lookup_certificates_issued_by_finish: Option<unsafe extern "C" fn(*mut GTlsDatabase, *mut GAsyncResult, *mut *mut glib::GError) -> *mut glib::GList>,
    padding: [gpointer; 16],
}

#[repr(C)]
pub struct GTlsDatabasePrivate(c_void);

#[repr(C)]
pub struct GTlsFileDatabaseInterface {
    pub g_iface: gobject::GTypeInterface,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GTlsInteractionClass {
    parent_class: gobject::GObjectClass,
    pub ask_password: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GTlsPassword, *mut GCancellable, *mut *mut glib::GError) -> GTlsInteractionResult>,
    pub ask_password_async: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GTlsPassword, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub ask_password_finish: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GAsyncResult, *mut *mut glib::GError) -> GTlsInteractionResult>,
    pub request_certificate: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GTlsConnection, GTlsCertificateRequestFlags, *mut GCancellable, *mut *mut glib::GError) -> GTlsInteractionResult>,
    pub request_certificate_async: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GTlsConnection, GTlsCertificateRequestFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub request_certificate_finish: Option<unsafe extern "C" fn(*mut GTlsInteraction, *mut GAsyncResult, *mut *mut glib::GError) -> GTlsInteractionResult>,
    padding: [gpointer; 21],
}

#[repr(C)]
pub struct GTlsInteractionPrivate(c_void);

#[repr(C)]
pub struct GTlsPasswordClass {
    pub parent_class: gobject::GObjectClass,
    pub get_value: Option<unsafe extern "C" fn(*mut GTlsPassword, *mut size_t) -> *const u8>,
    pub set_value: Option<unsafe extern "C" fn(*mut GTlsPassword, *mut u8, ssize_t, glib::GDestroyNotify)>,
    pub get_default_warning: Option<unsafe extern "C" fn(*mut GTlsPassword) -> *const c_char>,
    padding: [gpointer; 4],
}

#[repr(C)]
pub struct GTlsPasswordPrivate(c_void);

#[repr(C)]
pub struct GTlsServerConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GUnixConnectionClass {
    pub parent_class: GSocketConnectionClass,
}

#[repr(C)]
pub struct GUnixConnectionPrivate(c_void);

#[repr(C)]
pub struct GUnixCredentialsMessageClass {
    pub parent_class: GSocketControlMessageClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GUnixCredentialsMessagePrivate(c_void);

#[repr(C)]
pub struct GUnixFDListClass {
    pub parent_class: gobject::GObjectClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GUnixFDListPrivate(c_void);

#[repr(C)]
pub struct GUnixFDMessageClass {
    pub parent_class: GSocketControlMessageClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GUnixFDMessagePrivate(c_void);

#[repr(C)]
pub struct GUnixInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GUnixInputStreamPrivate(c_void);

#[repr(C)]
pub struct GUnixMountEntry(c_void);

#[repr(C)]
pub struct GUnixMountMonitorClass(c_void);

#[repr(C)]
pub struct GUnixMountPoint(c_void);

#[repr(C)]
pub struct GUnixOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GUnixOutputStreamPrivate(c_void);

#[repr(C)]
pub struct GUnixSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}

#[repr(C)]
pub struct GUnixSocketAddressPrivate(c_void);

#[repr(C)]
pub struct GVfsClass {
    pub parent_class: gobject::GObjectClass,
    pub is_active: Option<unsafe extern "C" fn(*mut GVfs) -> gboolean>,
    pub get_file_for_path: Option<unsafe extern "C" fn(*mut GVfs, *const c_char) -> *mut GFile>,
    pub get_file_for_uri: Option<unsafe extern "C" fn(*mut GVfs, *const c_char) -> *mut GFile>,
    pub get_supported_uri_schemes: Option<unsafe extern "C" fn(*mut GVfs) -> *const *const c_char>,
    pub parse_name: Option<unsafe extern "C" fn(*mut GVfs, *const c_char) -> *mut GFile>,
    pub local_file_add_info: Option<unsafe extern "C" fn(*mut GVfs, *const c_char, u64, *mut GFileAttributeMatcher, *mut GFileInfo, *mut GCancellable, *mut gpointer, *mut glib::GDestroyNotify)>,
    pub add_writable_namespaces: Option<unsafe extern "C" fn(*mut GVfs, *mut GFileAttributeInfoList)>,
    pub local_file_set_attributes: Option<unsafe extern "C" fn(*mut GVfs, *const c_char, *mut GFileInfo, GFileQueryInfoFlags, *mut GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub local_file_removed: Option<unsafe extern "C" fn(*mut GVfs, *const c_char)>,
    pub local_file_moved: Option<unsafe extern "C" fn(*mut GVfs, *const c_char, *const c_char)>,
    pub deserialize_icon: Option<unsafe extern "C" fn(*mut GVfs, *mut glib::GVariant) -> *mut GIcon>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GVolumeIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<unsafe extern "C" fn(*mut GVolume)>,
    pub removed: Option<unsafe extern "C" fn(*mut GVolume)>,
    pub get_name: Option<unsafe extern "C" fn(*mut GVolume) -> *const c_char>,
    pub get_icon: Option<unsafe extern "C" fn(*mut GVolume) -> *mut GIcon>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut GVolume) -> *const c_char>,
    pub get_drive: Option<unsafe extern "C" fn(*mut GVolume) -> *mut GDrive>,
    pub get_mount: Option<unsafe extern "C" fn(*mut GVolume) -> *mut GMount>,
    pub can_mount: Option<unsafe extern "C" fn(*mut GVolume) -> gboolean>,
    pub can_eject: Option<unsafe extern "C" fn(*mut GVolume) -> gboolean>,
    pub mount_fn: Option<unsafe extern "C" fn(*mut GVolume, GMountMountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub mount_finish: Option<unsafe extern "C" fn(*mut GVolume, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub eject: Option<unsafe extern "C" fn(*mut GVolume, GMountUnmountFlags, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_finish: Option<unsafe extern "C" fn(*mut GVolume, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub get_identifier: Option<unsafe extern "C" fn(*mut GVolume, *const c_char) -> *mut c_char>,
    pub enumerate_identifiers: Option<unsafe extern "C" fn(*mut GVolume) -> *mut *mut c_char>,
    pub should_automount: Option<unsafe extern "C" fn(*mut GVolume) -> gboolean>,
    pub get_activation_root: Option<unsafe extern "C" fn(*mut GVolume) -> *mut GFile>,
    pub eject_with_operation: Option<unsafe extern "C" fn(*mut GVolume, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, GAsyncReadyCallback, gpointer)>,
    pub eject_with_operation_finish: Option<unsafe extern "C" fn(*mut GVolume, *mut GAsyncResult, *mut *mut glib::GError) -> gboolean>,
    pub get_sort_key: Option<unsafe extern "C" fn(*mut GVolume) -> *const c_char>,
    pub get_symbolic_icon: Option<unsafe extern "C" fn(*mut GVolume) -> *mut GIcon>,
}

#[repr(C)]
pub struct GVolumeMonitorClass {
    pub parent_class: gobject::GObjectClass,
    pub volume_added: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GVolume)>,
    pub volume_removed: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GVolume)>,
    pub volume_changed: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GVolume)>,
    pub mount_added: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GMount)>,
    pub mount_removed: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GMount)>,
    pub mount_pre_unmount: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GMount)>,
    pub mount_changed: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GMount)>,
    pub drive_connected: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_disconnected: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_changed: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GDrive)>,
    pub is_supported: Option<unsafe extern "C" fn() -> gboolean>,
    pub get_connected_drives: Option<unsafe extern "C" fn(*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_volumes: Option<unsafe extern "C" fn(*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_mounts: Option<unsafe extern "C" fn(*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_volume_for_uuid: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *const c_char) -> *mut GVolume>,
    pub get_mount_for_uuid: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *const c_char) -> *mut GMount>,
    pub adopt_orphan_mount: Option<unsafe extern "C" fn(*mut GMount, *mut GVolumeMonitor) -> *mut GVolume>,
    pub drive_eject_button: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_stop_button: Option<unsafe extern "C" fn(*mut GVolumeMonitor, *mut GDrive)>,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
    pub _g_reserved6: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct GZlibCompressorClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GZlibDecompressorClass {
    pub parent_class: gobject::GObjectClass,
}

// Classes
#[repr(C)]
pub struct GAppInfoMonitor(c_void);

#[repr(C)]
pub struct GAppLaunchContext {
    pub parent_instance: gobject::GObject,
    priv_: *mut GAppLaunchContextPrivate,
}

#[repr(C)]
pub struct GApplication {
    parent_instance: gobject::GObject,
    priv_: *mut GApplicationPrivate,
}

#[repr(C)]
pub struct GApplicationCommandLine {
    parent_instance: gobject::GObject,
    priv_: *mut GApplicationCommandLinePrivate,
}

#[repr(C)]
pub struct GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    priv_: *mut GBufferedInputStreamPrivate,
}

#[repr(C)]
pub struct GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}

#[repr(C)]
pub struct GBytesIcon(c_void);

#[repr(C)]
pub struct GCancellable {
    pub parent_instance: gobject::GObject,
    priv_: *mut GCancellablePrivate,
}

#[repr(C)]
pub struct GCharsetConverter(c_void);

#[repr(C)]
pub struct GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    priv_: *mut GConverterInputStreamPrivate,
}

#[repr(C)]
pub struct GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    priv_: *mut GConverterOutputStreamPrivate,
}

#[repr(C)]
pub struct GCredentials(c_void);

#[repr(C)]
pub struct GDBusActionGroup(c_void);

#[repr(C)]
pub struct GDBusAuthObserver(c_void);

#[repr(C)]
pub struct GDBusConnection(c_void);

#[repr(C)]
pub struct GDBusInterfaceSkeleton {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusInterfaceSkeletonPrivate,
}

#[repr(C)]
pub struct GDBusMenuModel(c_void);

#[repr(C)]
pub struct GDBusMessage(c_void);

#[repr(C)]
pub struct GDBusMethodInvocation(c_void);

#[repr(C)]
pub struct GDBusObjectManagerClient {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectManagerClientPrivate,
}

#[repr(C)]
pub struct GDBusObjectManagerServer {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectManagerServerPrivate,
}

#[repr(C)]
pub struct GDBusObjectProxy {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectProxyPrivate,
}

#[repr(C)]
pub struct GDBusObjectSkeleton {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectSkeletonPrivate,
}

#[repr(C)]
pub struct GDBusProxy {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusProxyPrivate,
}

#[repr(C)]
pub struct GDBusServer(c_void);

#[repr(C)]
pub struct GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    priv_: *mut GDataInputStreamPrivate,
}

#[repr(C)]
pub struct GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    priv_: *mut GDataOutputStreamPrivate,
}

#[repr(C)]
pub struct GDesktopAppInfo(c_void);

#[repr(C)]
pub struct GEmblem(c_void);

#[repr(C)]
pub struct GEmblemedIcon {
    pub parent_instance: gobject::GObject,
    priv_: *mut GEmblemedIconPrivate,
}

#[repr(C)]
pub struct GFileEnumerator {
    pub parent_instance: gobject::GObject,
    priv_: *mut GFileEnumeratorPrivate,
}

#[repr(C)]
pub struct GFileIOStream {
    pub parent_instance: GIOStream,
    priv_: *mut GFileIOStreamPrivate,
}

#[repr(C)]
pub struct GFileIcon(c_void);

#[repr(C)]
pub struct GFileInfo(c_void);

#[repr(C)]
pub struct GFileInputStream {
    pub parent_instance: GInputStream,
    priv_: *mut GFileInputStreamPrivate,
}

#[repr(C)]
pub struct GFileMonitor {
    pub parent_instance: gobject::GObject,
    priv_: *mut GFileMonitorPrivate,
}

#[repr(C)]
pub struct GFileOutputStream {
    pub parent_instance: GOutputStream,
    priv_: *mut GFileOutputStreamPrivate,
}

#[repr(C)]
pub struct GFilenameCompleter(c_void);

#[repr(C)]
pub struct GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}

#[repr(C)]
pub struct GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}

#[repr(C)]
pub struct GIOModule(c_void);

#[repr(C)]
pub struct GIOStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GIOStreamPrivate,
}

#[repr(C)]
pub struct GInetAddress {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInetAddressPrivate,
}

#[repr(C)]
pub struct GInetAddressMask {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInetAddressMaskPrivate,
}

#[repr(C)]
pub struct GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    priv_: *mut GInetSocketAddressPrivate,
}

#[repr(C)]
pub struct GInputStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInputStreamPrivate,
}

#[repr(C)]
pub struct GListStore(c_void);

#[repr(C)]
pub struct GMemoryInputStream {
    pub parent_instance: GInputStream,
    priv_: *mut GMemoryInputStreamPrivate,
}

#[repr(C)]
pub struct GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    priv_: *mut GMemoryOutputStreamPrivate,
}

#[repr(C)]
pub struct GMenu(c_void);

#[repr(C)]
pub struct GMenuAttributeIter {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}

#[repr(C)]
pub struct GMenuItem(c_void);

#[repr(C)]
pub struct GMenuLinkIter {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}

#[repr(C)]
pub struct GMenuModel {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuModelPrivate,
}

#[repr(C)]
pub struct GMountOperation {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMountOperationPrivate,
}

#[repr(C)]
pub struct GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}

#[repr(C)]
pub struct GNetworkAddress {
    pub parent_instance: gobject::GObject,
    priv_: *mut GNetworkAddressPrivate,
}

#[repr(C)]
pub struct GNetworkService {
    pub parent_instance: gobject::GObject,
    priv_: *mut GNetworkServicePrivate,
}

#[repr(C)]
pub struct GNotification(c_void);

#[repr(C)]
pub struct GOutputStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GOutputStreamPrivate,
}

#[repr(C)]
pub struct GPermission {
    pub parent_instance: gobject::GObject,
    priv_: *mut GPermissionPrivate,
}

#[repr(C)]
pub struct GPropertyAction(c_void);

#[repr(C)]
pub struct GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    priv_: *mut GProxyAddressPrivate,
}

#[repr(C)]
pub struct GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}

#[repr(C)]
pub struct GResolver {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GResolverPrivate,
}

#[repr(C)]
pub struct GSettings {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSettingsPrivate,
}

#[repr(C)]
pub struct GSimpleAction(c_void);

#[repr(C)]
pub struct GSimpleActionGroup {
    parent_instance: gobject::GObject,
    priv_: *mut GSimpleActionGroupPrivate,
}

#[repr(C)]
pub struct GSimpleAsyncResult(c_void);

#[repr(C)]
pub struct GSimpleIOStream(c_void);

#[repr(C)]
pub struct GSimplePermission(c_void);

#[repr(C)]
pub struct GSimpleProxyResolver {
    pub parent_instance: gobject::GObject,
    priv_: *mut GSimpleProxyResolverPrivate,
}

#[repr(C)]
pub struct GSocket {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketPrivate,
}

#[repr(C)]
pub struct GSocketAddress {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GSocketAddressEnumerator {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GSocketClient {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketClientPrivate,
}

#[repr(C)]
pub struct GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}

#[repr(C)]
pub struct GSocketControlMessage {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}

#[repr(C)]
pub struct GSocketListener {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketListenerPrivate,
}

#[repr(C)]
pub struct GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}

#[repr(C)]
pub struct GSubprocess(c_void);

#[repr(C)]
pub struct GSubprocessLauncher(c_void);

#[repr(C)]
pub struct GTask(c_void);

#[repr(C)]
pub struct GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}

#[repr(C)]
pub struct GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}

#[repr(C)]
pub struct GTestDBus(c_void);

#[repr(C)]
pub struct GThemedIcon(c_void);

#[repr(C)]
pub struct GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}

#[repr(C)]
pub struct GTlsCertificate {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}

#[repr(C)]
pub struct GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}

#[repr(C)]
pub struct GTlsDatabase {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}

#[repr(C)]
pub struct GTlsInteraction {
    parent_instance: gobject::GObject,
    priv_: *mut GTlsInteractionPrivate,
}

#[repr(C)]
pub struct GTlsPassword {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}

#[repr(C)]
pub struct GUnixConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GUnixConnectionPrivate,
}

#[repr(C)]
pub struct GUnixCredentialsMessage {
    pub parent_instance: GSocketControlMessage,
    pub priv_: *mut GUnixCredentialsMessagePrivate,
}

#[repr(C)]
pub struct GUnixFDList {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GUnixFDListPrivate,
}

#[repr(C)]
pub struct GUnixFDMessage {
    pub parent_instance: GSocketControlMessage,
    pub priv_: *mut GUnixFDMessagePrivate,
}

#[repr(C)]
pub struct GUnixInputStream {
    pub parent_instance: GInputStream,
    priv_: *mut GUnixInputStreamPrivate,
}

#[repr(C)]
pub struct GUnixMountMonitor(c_void);

#[repr(C)]
pub struct GUnixOutputStream {
    pub parent_instance: GOutputStream,
    priv_: *mut GUnixOutputStreamPrivate,
}

#[repr(C)]
pub struct GUnixSocketAddress {
    pub parent_instance: GSocketAddress,
    priv_: *mut GUnixSocketAddressPrivate,
}

#[repr(C)]
pub struct GVfs {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GVolumeMonitor {
    pub parent_instance: gobject::GObject,
    priv_: gpointer,
}

#[repr(C)]
pub struct GZlibCompressor(c_void);

#[repr(C)]
pub struct GZlibDecompressor(c_void);

// Interfaces
#[repr(C)]
pub struct GAction(c_void);
#[repr(C)]
pub struct GActionGroup(c_void);
#[repr(C)]
pub struct GActionMap(c_void);
#[repr(C)]
pub struct GAppInfo(c_void);
#[repr(C)]
pub struct GAsyncInitable(c_void);
#[repr(C)]
pub struct GAsyncResult(c_void);
#[repr(C)]
pub struct GConverter(c_void);
#[repr(C)]
pub struct GDBusInterface(c_void);
#[repr(C)]
pub struct GDBusObject(c_void);
#[repr(C)]
pub struct GDBusObjectManager(c_void);
#[repr(C)]
pub struct GDatagramBased(c_void);
#[repr(C)]
pub struct GDesktopAppInfoLookup(c_void);
#[repr(C)]
pub struct GDrive(c_void);
#[repr(C)]
pub struct GDtlsClientConnection(c_void);
#[repr(C)]
pub struct GDtlsConnection(c_void);
#[repr(C)]
pub struct GDtlsServerConnection(c_void);
#[repr(C)]
pub struct GFile(c_void);
#[repr(C)]
pub struct GFileDescriptorBased(c_void);
#[repr(C)]
pub struct GIcon(c_void);
#[repr(C)]
pub struct GInitable(c_void);
#[repr(C)]
pub struct GListModel(c_void);
#[repr(C)]
pub struct GLoadableIcon(c_void);
#[repr(C)]
pub struct GMount(c_void);
#[repr(C)]
pub struct GNetworkMonitor(c_void);
#[repr(C)]
pub struct GPollableInputStream(c_void);
#[repr(C)]
pub struct GPollableOutputStream(c_void);
#[repr(C)]
pub struct GProxy(c_void);
#[repr(C)]
pub struct GProxyResolver(c_void);
#[repr(C)]
pub struct GRemoteActionGroup(c_void);
#[repr(C)]
pub struct GSeekable(c_void);
#[repr(C)]
pub struct GSocketConnectable(c_void);
#[repr(C)]
pub struct GTlsBackend(c_void);
#[repr(C)]
pub struct GTlsClientConnection(c_void);
#[repr(C)]
pub struct GTlsFileDatabase(c_void);
#[repr(C)]
pub struct GTlsServerConnection(c_void);
#[repr(C)]
pub struct GVolume(c_void);

extern "C" {

    //=========================================================================
    // GDBusError
    //=========================================================================
    pub fn g_dbus_error_encode_gerror(error: *const glib::GError) -> *mut c_char;
    pub fn g_dbus_error_get_remote_error(error: *const glib::GError) -> *mut c_char;
    pub fn g_dbus_error_is_remote_error(error: *const glib::GError) -> gboolean;
    pub fn g_dbus_error_new_for_dbus_error(dbus_error_name: *const c_char, dbus_error_message: *const c_char) -> *mut glib::GError;
    pub fn g_dbus_error_quark() -> glib::GQuark;
    pub fn g_dbus_error_register_error(error_domain: glib::GQuark, error_code: c_int, dbus_error_name: *const c_char) -> gboolean;
    pub fn g_dbus_error_register_error_domain(error_domain_quark_name: *const c_char, quark_volatile: *mut Volatile<size_t>, entries: *const GDBusErrorEntry, num_entries: c_uint);
    pub fn g_dbus_error_set_dbus_error(error: *mut *mut glib::GError, dbus_error_name: *const c_char, dbus_error_message: *const c_char, format: *const c_char, ...);
    //pub fn g_dbus_error_set_dbus_error_valist(error: *mut *mut glib::GError, dbus_error_name: *const c_char, dbus_error_message: *const c_char, format: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_dbus_error_strip_remote_error(error: *mut glib::GError) -> gboolean;
    pub fn g_dbus_error_unregister_error(error_domain: glib::GQuark, error_code: c_int, dbus_error_name: *const c_char) -> gboolean;

    //=========================================================================
    // GResolverError
    //=========================================================================
    pub fn g_resolver_error_quark() -> glib::GQuark;

    //=========================================================================
    // GResourceError
    //=========================================================================
    pub fn g_resource_error_quark() -> glib::GQuark;

    //=========================================================================
    // GTlsError
    //=========================================================================
    pub fn g_tls_error_quark() -> glib::GQuark;

    //=========================================================================
    // GDBusAnnotationInfo
    //=========================================================================
    pub fn g_dbus_annotation_info_get_type() -> GType;
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
    pub fn g_dbus_annotation_info_lookup(annotations: *mut *mut GDBusAnnotationInfo, name: *const c_char) -> *const c_char;

    //=========================================================================
    // GDBusArgInfo
    //=========================================================================
    pub fn g_dbus_arg_info_get_type() -> GType;
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);

    //=========================================================================
    // GDBusInterfaceInfo
    //=========================================================================
    pub fn g_dbus_interface_info_get_type() -> GType;
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_generate_xml(info: *mut GDBusInterfaceInfo, indent: c_uint, string_builder: *mut glib::GString);
    pub fn g_dbus_interface_info_lookup_method(info: *mut GDBusInterfaceInfo, name: *const c_char) -> *mut GDBusMethodInfo;
    pub fn g_dbus_interface_info_lookup_property(info: *mut GDBusInterfaceInfo, name: *const c_char) -> *mut GDBusPropertyInfo;
    pub fn g_dbus_interface_info_lookup_signal(info: *mut GDBusInterfaceInfo, name: *const c_char) -> *mut GDBusSignalInfo;
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);

    //=========================================================================
    // GDBusMethodInfo
    //=========================================================================
    pub fn g_dbus_method_info_get_type() -> GType;
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);

    //=========================================================================
    // GDBusNodeInfo
    //=========================================================================
    pub fn g_dbus_node_info_get_type() -> GType;
    pub fn g_dbus_node_info_new_for_xml(xml_data: *const c_char, error: *mut *mut glib::GError) -> *mut GDBusNodeInfo;
    pub fn g_dbus_node_info_generate_xml(info: *mut GDBusNodeInfo, indent: c_uint, string_builder: *mut glib::GString);
    pub fn g_dbus_node_info_lookup_interface(info: *mut GDBusNodeInfo, name: *const c_char) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);

    //=========================================================================
    // GDBusPropertyInfo
    //=========================================================================
    pub fn g_dbus_property_info_get_type() -> GType;
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);

    //=========================================================================
    // GDBusSignalInfo
    //=========================================================================
    pub fn g_dbus_signal_info_get_type() -> GType;
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);

    //=========================================================================
    // GFileAttributeInfoList
    //=========================================================================
    pub fn g_file_attribute_info_list_get_type() -> GType;
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_add(list: *mut GFileAttributeInfoList, name: *const c_char, type_: GFileAttributeType, flags: GFileAttributeInfoFlags);
    pub fn g_file_attribute_info_list_dup(list: *mut GFileAttributeInfoList) -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_lookup(list: *mut GFileAttributeInfoList, name: *const c_char) -> *const GFileAttributeInfo;
    pub fn g_file_attribute_info_list_ref(list: *mut GFileAttributeInfoList) -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);

    //=========================================================================
    // GFileAttributeMatcher
    //=========================================================================
    pub fn g_file_attribute_matcher_get_type() -> GType;
    pub fn g_file_attribute_matcher_new(attributes: *const c_char) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_enumerate_namespace(matcher: *mut GFileAttributeMatcher, ns: *const c_char) -> gboolean;
    pub fn g_file_attribute_matcher_enumerate_next(matcher: *mut GFileAttributeMatcher) -> *const c_char;
    pub fn g_file_attribute_matcher_matches(matcher: *mut GFileAttributeMatcher, attribute: *const c_char) -> gboolean;
    pub fn g_file_attribute_matcher_matches_only(matcher: *mut GFileAttributeMatcher, attribute: *const c_char) -> gboolean;
    pub fn g_file_attribute_matcher_ref(matcher: *mut GFileAttributeMatcher) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_subtract(matcher: *mut GFileAttributeMatcher, subtract: *mut GFileAttributeMatcher) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_to_string(matcher: *mut GFileAttributeMatcher) -> *mut c_char;
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);

    //=========================================================================
    // GIOExtension
    //=========================================================================
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const c_char;
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> c_int;
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut gobject::GTypeClass;

    //=========================================================================
    // GIOExtensionPoint
    //=========================================================================
    pub fn g_io_extension_point_get_extension_by_name(extension_point: *mut GIOExtensionPoint, name: *const c_char) -> *mut GIOExtension;
    pub fn g_io_extension_point_get_extensions(extension_point: *mut GIOExtensionPoint) -> *mut glib::GList;
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint) -> GType;
    pub fn g_io_extension_point_set_required_type(extension_point: *mut GIOExtensionPoint, type_: GType);
    pub fn g_io_extension_point_implement(extension_point_name: *const c_char, type_: GType, extension_name: *const c_char, priority: c_int) -> *mut GIOExtension;
    pub fn g_io_extension_point_lookup(name: *const c_char) -> *mut GIOExtensionPoint;
    pub fn g_io_extension_point_register(name: *const c_char) -> *mut GIOExtensionPoint;

    //=========================================================================
    // GIOModuleScope
    //=========================================================================
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const c_char);
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;

    //=========================================================================
    // GIOSchedulerJob
    //=========================================================================
    pub fn g_io_scheduler_job_send_to_mainloop(job: *mut GIOSchedulerJob, func: glib::GSourceFunc, user_data: gpointer, notify: glib::GDestroyNotify) -> gboolean;
    pub fn g_io_scheduler_job_send_to_mainloop_async(job: *mut GIOSchedulerJob, func: glib::GSourceFunc, user_data: gpointer, notify: glib::GDestroyNotify);

    //=========================================================================
    // GResource
    //=========================================================================
    pub fn g_resource_get_type() -> GType;
    pub fn g_resource_new_from_data(data: *mut glib::GBytes, error: *mut *mut glib::GError) -> *mut GResource;
    pub fn g_resource_enumerate_children(resource: *mut GResource, path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut *mut c_char;
    pub fn g_resource_get_info(resource: *mut GResource, path: *const c_char, lookup_flags: GResourceLookupFlags, size: *mut size_t, flags: *mut u32, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_resource_lookup_data(resource: *mut GResource, path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut glib::GBytes;
    pub fn g_resource_open_stream(resource: *mut GResource, path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut GInputStream;
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
    pub fn g_resource_unref(resource: *mut GResource);
    pub fn g_resource_load(filename: *mut c_char, error: *mut *mut glib::GError) -> *mut GResource;

    //=========================================================================
    // GSettingsSchema
    //=========================================================================
    pub fn g_settings_schema_get_type() -> GType;
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_get_key(schema: *mut GSettingsSchema, name: *const c_char) -> *mut GSettingsSchemaKey;
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const c_char) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut c_char;
    #[cfg(feature = "v2_46")]
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut c_char;
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);

    //=========================================================================
    // GSettingsSchemaKey
    //=========================================================================
    pub fn g_settings_schema_key_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut glib::GVariant;
    #[cfg(feature = "v2_34")]
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const c_char;
    #[cfg(feature = "v2_44")]
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut glib::GVariant;
    #[cfg(feature = "v2_34")]
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_get_value_type(key: *mut GSettingsSchemaKey) -> *const glib::GVariantType;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_range_check(key: *mut GSettingsSchemaKey, value: *mut glib::GVariant) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);

    //=========================================================================
    // GSettingsSchemaSource
    //=========================================================================
    pub fn g_settings_schema_source_get_type() -> GType;
    pub fn g_settings_schema_source_new_from_directory(directory: *mut c_char, parent: *mut GSettingsSchemaSource, trusted: gboolean, error: *mut *mut glib::GError) -> *mut GSettingsSchemaSource;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_schema_source_list_schemas(source: *mut GSettingsSchemaSource, recursive: gboolean, non_relocatable: *mut *mut *mut c_char, relocatable: *mut *mut *mut c_char);
    pub fn g_settings_schema_source_lookup(source: *mut GSettingsSchemaSource, schema_id: *const c_char, recursive: gboolean) -> *mut GSettingsSchema;
    pub fn g_settings_schema_source_ref(source: *mut GSettingsSchemaSource) -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;

    //=========================================================================
    // GSrvTarget
    //=========================================================================
    pub fn g_srv_target_get_type() -> GType;
    pub fn g_srv_target_new(hostname: *const c_char, port: u16, priority: u16, weight: u16) -> *mut GSrvTarget;
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
    pub fn g_srv_target_free(target: *mut GSrvTarget);
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const c_char;
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_list_sort(targets: *mut glib::GList) -> *mut glib::GList;

    //=========================================================================
    // GStaticResource
    //=========================================================================
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);

    //=========================================================================
    // GUnixMountPoint
    //=========================================================================
    pub fn g_unix_mount_point_compare(mount1: *mut GUnixMountPoint, mount2: *mut GUnixMountPoint) -> c_int;
    pub fn g_unix_mount_point_free(mount_point: *mut GUnixMountPoint);
    pub fn g_unix_mount_point_get_device_path(mount_point: *mut GUnixMountPoint) -> *mut c_char;
    pub fn g_unix_mount_point_get_fs_type(mount_point: *mut GUnixMountPoint) -> *const c_char;
    pub fn g_unix_mount_point_get_mount_path(mount_point: *mut GUnixMountPoint) -> *mut c_char;
    pub fn g_unix_mount_point_get_options(mount_point: *mut GUnixMountPoint) -> *const c_char;
    pub fn g_unix_mount_point_guess_can_eject(mount_point: *mut GUnixMountPoint) -> gboolean;
    pub fn g_unix_mount_point_guess_icon(mount_point: *mut GUnixMountPoint) -> *mut GIcon;
    pub fn g_unix_mount_point_guess_name(mount_point: *mut GUnixMountPoint) -> *mut c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_unix_mount_point_guess_symbolic_icon(mount_point: *mut GUnixMountPoint) -> *mut GIcon;
    pub fn g_unix_mount_point_is_loopback(mount_point: *mut GUnixMountPoint) -> gboolean;
    pub fn g_unix_mount_point_is_readonly(mount_point: *mut GUnixMountPoint) -> gboolean;
    pub fn g_unix_mount_point_is_user_mountable(mount_point: *mut GUnixMountPoint) -> gboolean;

    //=========================================================================
    // GAppInfoMonitor
    //=========================================================================
    pub fn g_app_info_monitor_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;

    //=========================================================================
    // GAppLaunchContext
    //=========================================================================
    pub fn g_app_launch_context_get_type() -> GType;
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
    pub fn g_app_launch_context_get_display(context: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut c_char;
    pub fn g_app_launch_context_get_environment(context: *mut GAppLaunchContext) -> *mut *mut c_char;
    pub fn g_app_launch_context_get_startup_notify_id(context: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut c_char;
    pub fn g_app_launch_context_launch_failed(context: *mut GAppLaunchContext, startup_notify_id: *const c_char);
    pub fn g_app_launch_context_setenv(context: *mut GAppLaunchContext, variable: *const c_char, value: *const c_char);
    pub fn g_app_launch_context_unsetenv(context: *mut GAppLaunchContext, variable: *const c_char);

    //=========================================================================
    // GApplication
    //=========================================================================
    pub fn g_application_get_type() -> GType;
    pub fn g_application_new(application_id: *const c_char, flags: GApplicationFlags) -> *mut GApplication;
    pub fn g_application_get_default() -> *mut GApplication;
    pub fn g_application_id_is_valid(application_id: *const c_char) -> gboolean;
    pub fn g_application_activate(application: *mut GApplication);
    #[cfg(feature = "v2_42")]
    pub fn g_application_add_main_option(application: *mut GApplication, long_name: *const c_char, short_name: c_char, flags: glib::GOptionFlags, arg: glib::GOptionArg, description: *const c_char, arg_description: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_application_add_main_option_entries(application: *mut GApplication, entries: *mut glib::GOptionEntry);
    #[cfg(feature = "v2_40")]
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut glib::GOptionGroup);
    #[cfg(feature = "v2_44")]
    pub fn g_application_bind_busy_property(application: *mut GApplication, object: *mut gobject::GObject, property: *const c_char);
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_application_get_dbus_connection(application: *mut GApplication) -> *mut GDBusConnection;
    #[cfg(feature = "v2_34")]
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const c_char;
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> c_uint;
    #[cfg(feature = "v2_44")]
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
    #[cfg(feature = "v2_42")]
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const c_char;
    pub fn g_application_hold(application: *mut GApplication);
    #[cfg(feature = "v2_38")]
    pub fn g_application_mark_busy(application: *mut GApplication);
    pub fn g_application_open(application: *mut GApplication, files: *mut *mut GFile, n_files: c_int, hint: *const c_char);
    pub fn g_application_quit(application: *mut GApplication);
    pub fn g_application_register(application: *mut GApplication, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_application_release(application: *mut GApplication);
    pub fn g_application_run(application: *mut GApplication, argc: c_int, argv: *mut *mut c_char) -> c_int;
    #[cfg(feature = "v2_40")]
    pub fn g_application_send_notification(application: *mut GApplication, id: *const c_char, notification: *mut GNotification);
    pub fn g_application_set_action_group(application: *mut GApplication, action_group: *mut GActionGroup);
    pub fn g_application_set_application_id(application: *mut GApplication, application_id: *const c_char);
    pub fn g_application_set_default(application: *mut GApplication);
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
    pub fn g_application_set_inactivity_timeout(application: *mut GApplication, inactivity_timeout: c_uint);
    #[cfg(feature = "v2_42")]
    pub fn g_application_set_resource_base_path(application: *mut GApplication, resource_path: *const c_char);
    #[cfg(feature = "v2_44")]
    pub fn g_application_unbind_busy_property(application: *mut GApplication, object: *mut gobject::GObject, property: *const c_char);
    #[cfg(feature = "v2_38")]
    pub fn g_application_unmark_busy(application: *mut GApplication);
    #[cfg(feature = "v2_40")]
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const c_char);

    //=========================================================================
    // GApplicationCommandLine
    //=========================================================================
    pub fn g_application_command_line_get_type() -> GType;
    #[cfg(feature = "v2_36")]
    pub fn g_application_command_line_create_file_for_arg(cmdline: *mut GApplicationCommandLine, arg: *const c_char) -> *mut GFile;
    pub fn g_application_command_line_get_arguments(cmdline: *mut GApplicationCommandLine, argc: *mut c_int) -> *mut *mut c_char;
    pub fn g_application_command_line_get_cwd(cmdline: *mut GApplicationCommandLine) -> *mut c_char;
    pub fn g_application_command_line_get_environ(cmdline: *mut GApplicationCommandLine) -> *mut *mut c_char;
    pub fn g_application_command_line_get_exit_status(cmdline: *mut GApplicationCommandLine) -> c_int;
    pub fn g_application_command_line_get_is_remote(cmdline: *mut GApplicationCommandLine) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_application_command_line_get_options_dict(cmdline: *mut GApplicationCommandLine) -> *mut glib::GVariantDict;
    pub fn g_application_command_line_get_platform_data(cmdline: *mut GApplicationCommandLine) -> *mut glib::GVariant;
    #[cfg(feature = "v2_34")]
    pub fn g_application_command_line_get_stdin(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream;
    pub fn g_application_command_line_getenv(cmdline: *mut GApplicationCommandLine, name: *const c_char) -> *const c_char;
    pub fn g_application_command_line_print(cmdline: *mut GApplicationCommandLine, format: *const c_char, ...);
    pub fn g_application_command_line_printerr(cmdline: *mut GApplicationCommandLine, format: *const c_char, ...);
    pub fn g_application_command_line_set_exit_status(cmdline: *mut GApplicationCommandLine, exit_status: c_int);

    //=========================================================================
    // GBufferedInputStream
    //=========================================================================
    pub fn g_buffered_input_stream_get_type() -> GType;
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
    pub fn g_buffered_input_stream_new_sized(base_stream: *mut GInputStream, size: size_t) -> *mut GInputStream;
    pub fn g_buffered_input_stream_fill(stream: *mut GBufferedInputStream, count: ssize_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_buffered_input_stream_fill_async(stream: *mut GBufferedInputStream, count: ssize_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_buffered_input_stream_fill_finish(stream: *mut GBufferedInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> size_t;
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> size_t;
    pub fn g_buffered_input_stream_peek(stream: *mut GBufferedInputStream, buffer: *mut u8, offset: size_t, count: size_t) -> size_t;
    pub fn g_buffered_input_stream_peek_buffer(stream: *mut GBufferedInputStream, count: *mut size_t) -> *mut u8;
    pub fn g_buffered_input_stream_read_byte(stream: *mut GBufferedInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: size_t);

    //=========================================================================
    // GBufferedOutputStream
    //=========================================================================
    pub fn g_buffered_output_stream_get_type() -> GType;
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
    pub fn g_buffered_output_stream_new_sized(base_stream: *mut GOutputStream, size: size_t) -> *mut GOutputStream;
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> size_t;
    pub fn g_buffered_output_stream_set_auto_grow(stream: *mut GBufferedOutputStream, auto_grow: gboolean);
    pub fn g_buffered_output_stream_set_buffer_size(stream: *mut GBufferedOutputStream, size: size_t);

    //=========================================================================
    // GBytesIcon
    //=========================================================================
    pub fn g_bytes_icon_get_type() -> GType;
    #[cfg(feature = "v2_38")]
    pub fn g_bytes_icon_new(bytes: *mut glib::GBytes) -> *mut GBytesIcon;
    #[cfg(feature = "v2_38")]
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut glib::GBytes;

    //=========================================================================
    // GCancellable
    //=========================================================================
    pub fn g_cancellable_get_type() -> GType;
    pub fn g_cancellable_new() -> *mut GCancellable;
    pub fn g_cancellable_get_current() -> *mut GCancellable;
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
    pub fn g_cancellable_connect(cancellable: *mut GCancellable, callback: gobject::GCallback, data: gpointer, data_destroy_func: glib::GDestroyNotify) -> c_ulong;
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: c_ulong);
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> c_int;
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
    pub fn g_cancellable_make_pollfd(cancellable: *mut GCancellable, pollfd: *mut glib::GPollFD) -> gboolean;
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
    pub fn g_cancellable_set_error_if_cancelled(cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut glib::GSource;

    //=========================================================================
    // GCharsetConverter
    //=========================================================================
    pub fn g_charset_converter_get_type() -> GType;
    pub fn g_charset_converter_new(to_charset: *const c_char, from_charset: *const c_char, error: *mut *mut glib::GError) -> *mut GCharsetConverter;
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> c_uint;
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
    pub fn g_charset_converter_set_use_fallback(converter: *mut GCharsetConverter, use_fallback: gboolean);

    //=========================================================================
    // GConverterInputStream
    //=========================================================================
    pub fn g_converter_input_stream_get_type() -> GType;
    pub fn g_converter_input_stream_new(base_stream: *mut GInputStream, converter: *mut GConverter) -> *mut GInputStream;
    pub fn g_converter_input_stream_get_converter(converter_stream: *mut GConverterInputStream) -> *mut GConverter;

    //=========================================================================
    // GConverterOutputStream
    //=========================================================================
    pub fn g_converter_output_stream_get_type() -> GType;
    pub fn g_converter_output_stream_new(base_stream: *mut GOutputStream, converter: *mut GConverter) -> *mut GOutputStream;
    pub fn g_converter_output_stream_get_converter(converter_stream: *mut GConverterOutputStream) -> *mut GConverter;

    //=========================================================================
    // GCredentials
    //=========================================================================
    pub fn g_credentials_get_type() -> GType;
    pub fn g_credentials_new() -> *mut GCredentials;
    pub fn g_credentials_get_native(credentials: *mut GCredentials, native_type: GCredentialsType) -> gpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_credentials_get_unix_pid(credentials: *mut GCredentials, error: *mut *mut glib::GError) -> c_int;
    pub fn g_credentials_get_unix_user(credentials: *mut GCredentials, error: *mut *mut glib::GError) -> c_uint;
    pub fn g_credentials_is_same_user(credentials: *mut GCredentials, other_credentials: *mut GCredentials, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_credentials_set_native(credentials: *mut GCredentials, native_type: GCredentialsType, native: gpointer);
    pub fn g_credentials_set_unix_user(credentials: *mut GCredentials, uid: c_uint, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut c_char;

    //=========================================================================
    // GDBusActionGroup
    //=========================================================================
    pub fn g_dbus_action_group_get_type() -> GType;
    pub fn g_dbus_action_group_get(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char) -> *mut GDBusActionGroup;

    //=========================================================================
    // GDBusAuthObserver
    //=========================================================================
    pub fn g_dbus_auth_observer_get_type() -> GType;
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
    #[cfg(feature = "v2_34")]
    pub fn g_dbus_auth_observer_allow_mechanism(observer: *mut GDBusAuthObserver, mechanism: *const c_char) -> gboolean;
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(observer: *mut GDBusAuthObserver, stream: *mut GIOStream, credentials: *mut GCredentials) -> gboolean;

    //=========================================================================
    // GDBusConnection
    //=========================================================================
    pub fn g_dbus_connection_get_type() -> GType;
    pub fn g_dbus_connection_new_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address_sync(address: *const c_char, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_sync(stream: *mut GIOStream, guid: *const c_char, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new(stream: *mut GIOStream, guid: *const c_char, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_new_for_address(address: *const c_char, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_add_filter(connection: *mut GDBusConnection, filter_function: GDBusMessageFilterFunction, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_dbus_connection_call(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_call_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_sync(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: c_int, fd_list: *mut GUnixFDList, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(connection: *mut GDBusConnection, out_fd_list: *mut *mut GUnixFDList, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char, interface_name: *const c_char, method_name: *const c_char, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: c_int, fd_list: *mut GUnixFDList, out_fd_list: *mut *mut GUnixFDList, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_connection_close(connection: *mut GDBusConnection, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_close_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_close_sync(connection: *mut GDBusConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_emit_signal(connection: *mut GDBusConnection, destination_bus_name: *const c_char, object_path: *const c_char, interface_name: *const c_char, signal_name: *const c_char, parameters: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_export_action_group(connection: *mut GDBusConnection, object_path: *const c_char, action_group: *mut GActionGroup, error: *mut *mut glib::GError) -> c_uint;
    pub fn g_dbus_connection_export_menu_model(connection: *mut GDBusConnection, object_path: *const c_char, menu: *mut GMenuModel, error: *mut *mut glib::GError) -> c_uint;
    pub fn g_dbus_connection_flush(connection: *mut GDBusConnection, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_flush_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_flush_sync(connection: *mut GDBusConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_get_capabilities(connection: *mut GDBusConnection) -> GDBusCapabilityFlags;
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> u32;
    pub fn g_dbus_connection_get_peer_credentials(connection: *mut GDBusConnection) -> *mut GCredentials;
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const c_char;
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_connection_register_object(connection: *mut GDBusConnection, object_path: *const c_char, interface_info: *mut GDBusInterfaceInfo, vtable: *const GDBusInterfaceVTable, user_data: gpointer, user_data_free_func: glib::GDestroyNotify, error: *mut *mut glib::GError) -> c_uint;
    #[cfg(feature = "v2_46")]
    pub fn g_dbus_connection_register_object_with_closures(connection: *mut GDBusConnection, object_path: *const c_char, interface_info: *mut GDBusInterfaceInfo, method_call_closure: *mut gobject::GClosure, get_property_closure: *mut gobject::GClosure, set_property_closure: *mut gobject::GClosure, error: *mut *mut glib::GError) -> c_uint;
    pub fn g_dbus_connection_register_subtree(connection: *mut GDBusConnection, object_path: *const c_char, vtable: *const GDBusSubtreeVTable, flags: GDBusSubtreeFlags, user_data: gpointer, user_data_free_func: glib::GDestroyNotify, error: *mut *mut glib::GError) -> c_uint;
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: c_uint);
    pub fn g_dbus_connection_send_message(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, out_serial: *mut Volatile<u32>, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_connection_send_message_with_reply(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: c_int, out_serial: *mut Volatile<u32>, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_connection_send_message_with_reply_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusMessage;
    pub fn g_dbus_connection_send_message_with_reply_sync(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: c_int, out_serial: *mut Volatile<u32>, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusMessage;
    pub fn g_dbus_connection_set_exit_on_close(connection: *mut GDBusConnection, exit_on_close: gboolean);
    pub fn g_dbus_connection_signal_subscribe(connection: *mut GDBusConnection, sender: *const c_char, interface_name: *const c_char, member: *const c_char, object_path: *const c_char, arg0: *const c_char, flags: GDBusSignalFlags, callback: GDBusSignalCallback, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_dbus_connection_signal_unsubscribe(connection: *mut GDBusConnection, subscription_id: c_uint);
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
    pub fn g_dbus_connection_unexport_action_group(connection: *mut GDBusConnection, export_id: c_uint);
    pub fn g_dbus_connection_unexport_menu_model(connection: *mut GDBusConnection, export_id: c_uint);
    pub fn g_dbus_connection_unregister_object(connection: *mut GDBusConnection, registration_id: c_uint) -> gboolean;
    pub fn g_dbus_connection_unregister_subtree(connection: *mut GDBusConnection, registration_id: c_uint) -> gboolean;

    //=========================================================================
    // GDBusInterfaceSkeleton
    //=========================================================================
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
    pub fn g_dbus_interface_skeleton_export(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection, object_path: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_get_connection(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusConnection;
    pub fn g_dbus_interface_skeleton_get_connections(interface_: *mut GDBusInterfaceSkeleton) -> *mut glib::GList;
    pub fn g_dbus_interface_skeleton_get_flags(interface_: *mut GDBusInterfaceSkeleton) -> GDBusInterfaceSkeletonFlags;
    pub fn g_dbus_interface_skeleton_get_info(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_skeleton_get_object_path(interface_: *mut GDBusInterfaceSkeleton) -> *const c_char;
    pub fn g_dbus_interface_skeleton_get_properties(interface_: *mut GDBusInterfaceSkeleton) -> *mut glib::GVariant;
    pub fn g_dbus_interface_skeleton_get_vtable(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable;
    pub fn g_dbus_interface_skeleton_has_connection(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_interface_skeleton_set_flags(interface_: *mut GDBusInterfaceSkeleton, flags: GDBusInterfaceSkeletonFlags);
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_unexport_from_connection(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection);

    //=========================================================================
    // GDBusMenuModel
    //=========================================================================
    pub fn g_dbus_menu_model_get_type() -> GType;
    pub fn g_dbus_menu_model_get(connection: *mut GDBusConnection, bus_name: *const c_char, object_path: *const c_char) -> *mut GDBusMenuModel;

    //=========================================================================
    // GDBusMessage
    //=========================================================================
    pub fn g_dbus_message_get_type() -> GType;
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
    pub fn g_dbus_message_new_from_blob(blob: *mut u8, blob_len: size_t, capabilities: GDBusCapabilityFlags, error: *mut *mut glib::GError) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_call(name: *const c_char, path: *const c_char, interface_: *const c_char, method: *const c_char) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_signal(path: *const c_char, interface_: *const c_char, signal: *const c_char) -> *mut GDBusMessage;
    pub fn g_dbus_message_bytes_needed(blob: *mut u8, blob_len: size_t, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_dbus_message_copy(message: *mut GDBusMessage, error: *mut *mut glib::GError) -> *mut GDBusMessage;
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut glib::GVariant;
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
    pub fn g_dbus_message_get_header(message: *mut GDBusMessage, header_field: GDBusMessageHeaderField) -> *mut glib::GVariant;
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut u8;
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const c_char;
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
    pub fn g_dbus_message_new_method_error(method_call_message: *mut GDBusMessage, error_name: *const c_char, error_message_format: *const c_char, ...) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error_literal(method_call_message: *mut GDBusMessage, error_name: *const c_char, error_message: *const c_char) -> *mut GDBusMessage;
    //pub fn g_dbus_message_new_method_error_valist(method_call_message: *mut GDBusMessage, error_name: *const c_char, error_message_format: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_reply(method_call_message: *mut GDBusMessage) -> *mut GDBusMessage;
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: c_uint) -> *mut c_char;
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut glib::GVariant);
    pub fn g_dbus_message_set_byte_order(message: *mut GDBusMessage, byte_order: GDBusMessageByteOrder);
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
    pub fn g_dbus_message_set_header(message: *mut GDBusMessage, header_field: GDBusMessageHeaderField, value: *mut glib::GVariant);
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: u32);
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: u32);
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: u32);
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const c_char);
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
    pub fn g_dbus_message_to_blob(message: *mut GDBusMessage, out_size: *mut size_t, capabilities: GDBusCapabilityFlags, error: *mut *mut glib::GError) -> *mut u8;
    pub fn g_dbus_message_to_gerror(message: *mut GDBusMessage, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GDBusMethodInvocation
    //=========================================================================
    pub fn g_dbus_method_invocation_get_type() -> GType;
    pub fn g_dbus_method_invocation_get_connection(invocation: *mut GDBusMethodInvocation) -> *mut GDBusConnection;
    pub fn g_dbus_method_invocation_get_interface_name(invocation: *mut GDBusMethodInvocation) -> *const c_char;
    pub fn g_dbus_method_invocation_get_message(invocation: *mut GDBusMethodInvocation) -> *mut GDBusMessage;
    pub fn g_dbus_method_invocation_get_method_info(invocation: *mut GDBusMethodInvocation) -> *const GDBusMethodInfo;
    pub fn g_dbus_method_invocation_get_method_name(invocation: *mut GDBusMethodInvocation) -> *const c_char;
    pub fn g_dbus_method_invocation_get_object_path(invocation: *mut GDBusMethodInvocation) -> *const c_char;
    pub fn g_dbus_method_invocation_get_parameters(invocation: *mut GDBusMethodInvocation) -> *mut glib::GVariant;
    #[cfg(feature = "v2_38")]
    pub fn g_dbus_method_invocation_get_property_info(invocation: *mut GDBusMethodInvocation) -> *const GDBusPropertyInfo;
    pub fn g_dbus_method_invocation_get_sender(invocation: *mut GDBusMethodInvocation) -> *const c_char;
    pub fn g_dbus_method_invocation_get_user_data(invocation: *mut GDBusMethodInvocation) -> gpointer;
    pub fn g_dbus_method_invocation_return_dbus_error(invocation: *mut GDBusMethodInvocation, error_name: *const c_char, error_message: *const c_char);
    pub fn g_dbus_method_invocation_return_error(invocation: *mut GDBusMethodInvocation, domain: glib::GQuark, code: c_int, format: *const c_char, ...);
    pub fn g_dbus_method_invocation_return_error_literal(invocation: *mut GDBusMethodInvocation, domain: glib::GQuark, code: c_int, message: *const c_char);
    //pub fn g_dbus_method_invocation_return_error_valist(invocation: *mut GDBusMethodInvocation, domain: glib::GQuark, code: c_int, format: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn g_dbus_method_invocation_return_gerror(invocation: *mut GDBusMethodInvocation, error: *const glib::GError);
    pub fn g_dbus_method_invocation_return_value(invocation: *mut GDBusMethodInvocation, parameters: *mut glib::GVariant);
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(invocation: *mut GDBusMethodInvocation, parameters: *mut glib::GVariant, fd_list: *mut GUnixFDList);
    pub fn g_dbus_method_invocation_take_error(invocation: *mut GDBusMethodInvocation, error: *mut glib::GError);

    //=========================================================================
    // GDBusObjectManagerClient
    //=========================================================================
    pub fn g_dbus_object_manager_client_get_type() -> GType;
    pub fn g_dbus_object_manager_client_new_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusObjectManagerClient;
    pub fn g_dbus_object_manager_client_new_for_bus_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusObjectManagerClient;
    pub fn g_dbus_object_manager_client_new_for_bus_sync(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: glib::GDestroyNotify, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusObjectManagerClient;
    pub fn g_dbus_object_manager_client_new_sync(connection: *mut GDBusConnection, flags: GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: glib::GDestroyNotify, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusObjectManagerClient;
    pub fn g_dbus_object_manager_client_new(connection: *mut GDBusConnection, flags: GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: glib::GDestroyNotify, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_object_manager_client_new_for_bus(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: glib::GDestroyNotify, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_object_manager_client_get_connection(manager: *mut GDBusObjectManagerClient) -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_client_get_flags(manager: *mut GDBusObjectManagerClient) -> GDBusObjectManagerClientFlags;
    pub fn g_dbus_object_manager_client_get_name(manager: *mut GDBusObjectManagerClient) -> *const c_char;
    pub fn g_dbus_object_manager_client_get_name_owner(manager: *mut GDBusObjectManagerClient) -> *mut c_char;

    //=========================================================================
    // GDBusObjectManagerServer
    //=========================================================================
    pub fn g_dbus_object_manager_server_get_type() -> GType;
    pub fn g_dbus_object_manager_server_new(object_path: *const c_char) -> *mut GDBusObjectManagerServer;
    pub fn g_dbus_object_manager_server_export(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_export_uniquely(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_get_connection(manager: *mut GDBusObjectManagerServer) -> *mut GDBusConnection;
    #[cfg(feature = "v2_34")]
    pub fn g_dbus_object_manager_server_is_exported(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton) -> gboolean;
    pub fn g_dbus_object_manager_server_set_connection(manager: *mut GDBusObjectManagerServer, connection: *mut GDBusConnection);
    pub fn g_dbus_object_manager_server_unexport(manager: *mut GDBusObjectManagerServer, object_path: *const c_char) -> gboolean;

    //=========================================================================
    // GDBusObjectProxy
    //=========================================================================
    pub fn g_dbus_object_proxy_get_type() -> GType;
    pub fn g_dbus_object_proxy_new(connection: *mut GDBusConnection, object_path: *const c_char) -> *mut GDBusObjectProxy;
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy) -> *mut GDBusConnection;

    //=========================================================================
    // GDBusObjectSkeleton
    //=========================================================================
    pub fn g_dbus_object_skeleton_get_type() -> GType;
    pub fn g_dbus_object_skeleton_new(object_path: *const c_char) -> *mut GDBusObjectSkeleton;
    pub fn g_dbus_object_skeleton_add_interface(object: *mut GDBusObjectSkeleton, interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_skeleton_remove_interface(object: *mut GDBusObjectSkeleton, interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_remove_interface_by_name(object: *mut GDBusObjectSkeleton, interface_name: *const c_char);
    pub fn g_dbus_object_skeleton_set_object_path(object: *mut GDBusObjectSkeleton, object_path: *const c_char);

    //=========================================================================
    // GDBusProxy
    //=========================================================================
    pub fn g_dbus_proxy_get_type() -> GType;
    pub fn g_dbus_proxy_new_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus_sync(bus_type: GBusType, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const c_char, object_path: *const c_char, interface_name: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_sync(connection: *mut GDBusConnection, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const c_char, object_path: *const c_char, interface_name: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new(connection: *mut GDBusConnection, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const c_char, object_path: *const c_char, interface_name: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_proxy_new_for_bus(bus_type: GBusType, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const c_char, object_path: *const c_char, interface_name: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_proxy_call(proxy: *mut GDBusProxy, method_name: *const c_char, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_proxy_call_finish(proxy: *mut GDBusProxy, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_sync(proxy: *mut GDBusProxy, method_name: *const c_char, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list(proxy: *mut GDBusProxy, method_name: *const c_char, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: c_int, fd_list: *mut GUnixFDList, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(proxy: *mut GDBusProxy, out_fd_list: *mut *mut GUnixFDList, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(proxy: *mut GDBusProxy, method_name: *const c_char, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: c_int, fd_list: *mut GUnixFDList, out_fd_list: *mut *mut GUnixFDList, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_get_cached_property(proxy: *mut GDBusProxy, property_name: *const c_char) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut c_char;
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> c_int;
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const c_char;
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const c_char;
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut c_char;
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const c_char;
    pub fn g_dbus_proxy_set_cached_property(proxy: *mut GDBusProxy, property_name: *const c_char, value: *mut glib::GVariant);
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: c_int);
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);

    //=========================================================================
    // GDBusServer
    //=========================================================================
    pub fn g_dbus_server_get_type() -> GType;
    pub fn g_dbus_server_new_sync(address: *const c_char, flags: GDBusServerFlags, guid: *const c_char, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusServer;
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const c_char;
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const c_char;
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
    pub fn g_dbus_server_start(server: *mut GDBusServer);
    pub fn g_dbus_server_stop(server: *mut GDBusServer);

    //=========================================================================
    // GDataInputStream
    //=========================================================================
    pub fn g_data_input_stream_get_type() -> GType;
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
    pub fn g_data_input_stream_get_byte_order(stream: *mut GDataInputStream) -> GDataStreamByteOrder;
    pub fn g_data_input_stream_get_newline_type(stream: *mut GDataInputStream) -> GDataStreamNewlineType;
    pub fn g_data_input_stream_read_byte(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_uchar;
    pub fn g_data_input_stream_read_int16(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> i16;
    pub fn g_data_input_stream_read_int32(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> i32;
    pub fn g_data_input_stream_read_int64(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> i64;
    pub fn g_data_input_stream_read_line(stream: *mut GDataInputStream, length: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut u8;
    pub fn g_data_input_stream_read_line_async(stream: *mut GDataInputStream, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_data_input_stream_read_line_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut size_t, error: *mut *mut glib::GError) -> *mut u8;
    pub fn g_data_input_stream_read_line_finish_utf8(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut size_t, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_read_line_utf8(stream: *mut GDataInputStream, length: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_read_uint16(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> u16;
    pub fn g_data_input_stream_read_uint32(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> u32;
    pub fn g_data_input_stream_read_uint64(stream: *mut GDataInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> u64;
    pub fn g_data_input_stream_read_until(stream: *mut GDataInputStream, stop_chars: *const c_char, length: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_read_until_async(stream: *mut GDataInputStream, stop_chars: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_data_input_stream_read_until_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut size_t, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_read_upto(stream: *mut GDataInputStream, stop_chars: *const c_char, stop_chars_len: ssize_t, length: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_read_upto_async(stream: *mut GDataInputStream, stop_chars: *const c_char, stop_chars_len: ssize_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_data_input_stream_read_upto_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut size_t, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_data_input_stream_set_byte_order(stream: *mut GDataInputStream, order: GDataStreamByteOrder);
    pub fn g_data_input_stream_set_newline_type(stream: *mut GDataInputStream, type_: GDataStreamNewlineType);

    //=========================================================================
    // GDataOutputStream
    //=========================================================================
    pub fn g_data_output_stream_get_type() -> GType;
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
    pub fn g_data_output_stream_get_byte_order(stream: *mut GDataOutputStream) -> GDataStreamByteOrder;
    pub fn g_data_output_stream_put_byte(stream: *mut GDataOutputStream, data: c_uchar, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_int16(stream: *mut GDataOutputStream, data: i16, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_int32(stream: *mut GDataOutputStream, data: i32, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_int64(stream: *mut GDataOutputStream, data: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_string(stream: *mut GDataOutputStream, str: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_uint16(stream: *mut GDataOutputStream, data: u16, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_uint32(stream: *mut GDataOutputStream, data: u32, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_put_uint64(stream: *mut GDataOutputStream, data: u64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_data_output_stream_set_byte_order(stream: *mut GDataOutputStream, order: GDataStreamByteOrder);

    //=========================================================================
    // GDesktopAppInfo
    //=========================================================================
    pub fn g_desktop_app_info_get_type() -> GType;
    pub fn g_desktop_app_info_new(desktop_id: *const c_char) -> *mut GDesktopAppInfo;
    pub fn g_desktop_app_info_new_from_filename(filename: *mut c_char) -> *mut GDesktopAppInfo;
    pub fn g_desktop_app_info_new_from_keyfile(key_file: *mut glib::GKeyFile) -> *mut GDesktopAppInfo;
    #[cfg(feature = "v2_42")]
    pub fn g_desktop_app_info_get_implementations(interface: *const c_char) -> *mut glib::GList;
    pub fn g_desktop_app_info_search(search_string: *const c_char) -> *mut *mut *mut c_char;
    pub fn g_desktop_app_info_set_desktop_env(desktop_env: *const c_char);
    #[cfg(feature = "v2_38")]
    pub fn g_desktop_app_info_get_action_name(info: *mut GDesktopAppInfo, action_name: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_36")]
    pub fn g_desktop_app_info_get_boolean(info: *mut GDesktopAppInfo, key: *const c_char) -> gboolean;
    pub fn g_desktop_app_info_get_categories(info: *mut GDesktopAppInfo) -> *const c_char;
    pub fn g_desktop_app_info_get_filename(info: *mut GDesktopAppInfo) -> *mut c_char;
    pub fn g_desktop_app_info_get_generic_name(info: *mut GDesktopAppInfo) -> *const c_char;
    pub fn g_desktop_app_info_get_is_hidden(info: *mut GDesktopAppInfo) -> gboolean;
    pub fn g_desktop_app_info_get_keywords(info: *mut GDesktopAppInfo) -> *const *const c_char;
    pub fn g_desktop_app_info_get_nodisplay(info: *mut GDesktopAppInfo) -> gboolean;
    pub fn g_desktop_app_info_get_show_in(info: *mut GDesktopAppInfo, desktop_env: *const c_char) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_desktop_app_info_get_startup_wm_class(info: *mut GDesktopAppInfo) -> *const c_char;
    #[cfg(feature = "v2_36")]
    pub fn g_desktop_app_info_get_string(info: *mut GDesktopAppInfo, key: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_36")]
    pub fn g_desktop_app_info_has_key(info: *mut GDesktopAppInfo, key: *const c_char) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_desktop_app_info_launch_action(info: *mut GDesktopAppInfo, action_name: *const c_char, launch_context: *mut GAppLaunchContext);
    pub fn g_desktop_app_info_launch_uris_as_manager(appinfo: *mut GDesktopAppInfo, uris: *mut glib::GList, launch_context: *mut GAppLaunchContext, spawn_flags: glib::GSpawnFlags, user_setup: glib::GSpawnChildSetupFunc, user_setup_data: gpointer, pid_callback: GDesktopAppLaunchCallback, pid_callback_data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_desktop_app_info_list_actions(info: *mut GDesktopAppInfo) -> *mut *mut c_char;

    //=========================================================================
    // GEmblem
    //=========================================================================
    pub fn g_emblem_get_type() -> GType;
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;

    //=========================================================================
    // GEmblemedIcon
    //=========================================================================
    pub fn g_emblemed_icon_get_type() -> GType;
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GEmblemedIcon;
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut glib::GList;
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;

    //=========================================================================
    // GFileEnumerator
    //=========================================================================
    pub fn g_file_enumerator_get_type() -> GType;
    pub fn g_file_enumerator_close(enumerator: *mut GFileEnumerator, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_enumerator_close_async(enumerator: *mut GFileEnumerator, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_enumerator_close_finish(enumerator: *mut GFileEnumerator, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_file_enumerator_get_child(enumerator: *mut GFileEnumerator, info: *mut GFileInfo) -> *mut GFile;
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_file_enumerator_iterate(direnum: *mut GFileEnumerator, out_info: *mut *mut GFileInfo, out_child: *mut *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_enumerator_next_file(enumerator: *mut GFileEnumerator, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_enumerator_next_files_async(enumerator: *mut GFileEnumerator, num_files: c_int, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_enumerator_next_files_finish(enumerator: *mut GFileEnumerator, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);

    //=========================================================================
    // GFileIOStream
    //=========================================================================
    pub fn g_file_io_stream_get_type() -> GType;
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut c_char;
    pub fn g_file_io_stream_query_info(stream: *mut GFileIOStream, attributes: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_io_stream_query_info_async(stream: *mut GFileIOStream, attributes: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_io_stream_query_info_finish(stream: *mut GFileIOStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInfo;

    //=========================================================================
    // GFileIcon
    //=========================================================================
    pub fn g_file_icon_get_type() -> GType;
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GFileIcon;
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;

    //=========================================================================
    // GFileInfo
    //=========================================================================
    pub fn g_file_info_get_type() -> GType;
    pub fn g_file_info_new() -> *mut GFileInfo;
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
    pub fn g_file_info_get_attribute_as_string(info: *mut GFileInfo, attribute: *const c_char) -> *mut c_char;
    pub fn g_file_info_get_attribute_boolean(info: *mut GFileInfo, attribute: *const c_char) -> gboolean;
    pub fn g_file_info_get_attribute_byte_string(info: *mut GFileInfo, attribute: *const c_char) -> *const c_char;
    pub fn g_file_info_get_attribute_data(info: *mut GFileInfo, attribute: *const c_char, type_: *mut GFileAttributeType, value_pp: *mut gpointer, status: *mut GFileAttributeStatus) -> gboolean;
    pub fn g_file_info_get_attribute_int32(info: *mut GFileInfo, attribute: *const c_char) -> i32;
    pub fn g_file_info_get_attribute_int64(info: *mut GFileInfo, attribute: *const c_char) -> i64;
    pub fn g_file_info_get_attribute_object(info: *mut GFileInfo, attribute: *const c_char) -> *mut gobject::GObject;
    pub fn g_file_info_get_attribute_status(info: *mut GFileInfo, attribute: *const c_char) -> GFileAttributeStatus;
    pub fn g_file_info_get_attribute_string(info: *mut GFileInfo, attribute: *const c_char) -> *const c_char;
    pub fn g_file_info_get_attribute_stringv(info: *mut GFileInfo, attribute: *const c_char) -> *mut *mut c_char;
    pub fn g_file_info_get_attribute_type(info: *mut GFileInfo, attribute: *const c_char) -> GFileAttributeType;
    pub fn g_file_info_get_attribute_uint32(info: *mut GFileInfo, attribute: *const c_char) -> u32;
    pub fn g_file_info_get_attribute_uint64(info: *mut GFileInfo, attribute: *const c_char) -> u64;
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const c_char;
    #[cfg(feature = "v2_36")]
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut glib::GDateTime;
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const c_char;
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const c_char;
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const c_char;
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut glib::GTimeVal);
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *mut c_char;
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> i64;
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> i32;
    #[cfg(feature = "v2_34")]
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const c_char;
    pub fn g_file_info_has_attribute(info: *mut GFileInfo, attribute: *const c_char) -> gboolean;
    pub fn g_file_info_has_namespace(info: *mut GFileInfo, name_space: *const c_char) -> gboolean;
    pub fn g_file_info_list_attributes(info: *mut GFileInfo, name_space: *const c_char) -> *mut *mut c_char;
    pub fn g_file_info_remove_attribute(info: *mut GFileInfo, attribute: *const c_char);
    pub fn g_file_info_set_attribute(info: *mut GFileInfo, attribute: *const c_char, type_: GFileAttributeType, value_p: gpointer);
    pub fn g_file_info_set_attribute_boolean(info: *mut GFileInfo, attribute: *const c_char, attr_value: gboolean);
    pub fn g_file_info_set_attribute_byte_string(info: *mut GFileInfo, attribute: *const c_char, attr_value: *const c_char);
    pub fn g_file_info_set_attribute_int32(info: *mut GFileInfo, attribute: *const c_char, attr_value: i32);
    pub fn g_file_info_set_attribute_int64(info: *mut GFileInfo, attribute: *const c_char, attr_value: i64);
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
    pub fn g_file_info_set_attribute_object(info: *mut GFileInfo, attribute: *const c_char, attr_value: *mut gobject::GObject);
    pub fn g_file_info_set_attribute_status(info: *mut GFileInfo, attribute: *const c_char, status: GFileAttributeStatus) -> gboolean;
    pub fn g_file_info_set_attribute_string(info: *mut GFileInfo, attribute: *const c_char, attr_value: *const c_char);
    pub fn g_file_info_set_attribute_stringv(info: *mut GFileInfo, attribute: *const c_char, attr_value: *mut *mut c_char);
    pub fn g_file_info_set_attribute_uint32(info: *mut GFileInfo, attribute: *const c_char, attr_value: u32);
    pub fn g_file_info_set_attribute_uint64(info: *mut GFileInfo, attribute: *const c_char, attr_value: u64);
    pub fn g_file_info_set_content_type(info: *mut GFileInfo, content_type: *const c_char);
    pub fn g_file_info_set_display_name(info: *mut GFileInfo, display_name: *const c_char);
    pub fn g_file_info_set_edit_name(info: *mut GFileInfo, edit_name: *const c_char);
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut glib::GTimeVal);
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *mut c_char);
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: i64);
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: i32);
    #[cfg(feature = "v2_34")]
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
    pub fn g_file_info_set_symlink_target(info: *mut GFileInfo, symlink_target: *const c_char);
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);

    //=========================================================================
    // GFileInputStream
    //=========================================================================
    pub fn g_file_input_stream_get_type() -> GType;
    pub fn g_file_input_stream_query_info(stream: *mut GFileInputStream, attributes: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_input_stream_query_info_async(stream: *mut GFileInputStream, attributes: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_input_stream_query_info_finish(stream: *mut GFileInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInfo;

    //=========================================================================
    // GFileMonitor
    //=========================================================================
    pub fn g_file_monitor_get_type() -> GType;
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
    pub fn g_file_monitor_emit_event(monitor: *mut GFileMonitor, child: *mut GFile, other_file: *mut GFile, event_type: GFileMonitorEvent);
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: c_int);

    //=========================================================================
    // GFileOutputStream
    //=========================================================================
    pub fn g_file_output_stream_get_type() -> GType;
    pub fn g_file_output_stream_get_etag(stream: *mut GFileOutputStream) -> *mut c_char;
    pub fn g_file_output_stream_query_info(stream: *mut GFileOutputStream, attributes: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_output_stream_query_info_async(stream: *mut GFileOutputStream, attributes: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_output_stream_query_info_finish(stream: *mut GFileOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInfo;

    //=========================================================================
    // GFilenameCompleter
    //=========================================================================
    pub fn g_filename_completer_get_type() -> GType;
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
    pub fn g_filename_completer_get_completion_suffix(completer: *mut GFilenameCompleter, initial_text: *const c_char) -> *mut c_char;
    pub fn g_filename_completer_get_completions(completer: *mut GFilenameCompleter, initial_text: *const c_char) -> *mut *mut c_char;
    pub fn g_filename_completer_set_dirs_only(completer: *mut GFilenameCompleter, dirs_only: gboolean);

    //=========================================================================
    // GFilterInputStream
    //=========================================================================
    pub fn g_filter_input_stream_get_type() -> GType;
    pub fn g_filter_input_stream_get_base_stream(stream: *mut GFilterInputStream) -> *mut GInputStream;
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream) -> gboolean;
    pub fn g_filter_input_stream_set_close_base_stream(stream: *mut GFilterInputStream, close_base: gboolean);

    //=========================================================================
    // GFilterOutputStream
    //=========================================================================
    pub fn g_filter_output_stream_get_type() -> GType;
    pub fn g_filter_output_stream_get_base_stream(stream: *mut GFilterOutputStream) -> *mut GOutputStream;
    pub fn g_filter_output_stream_get_close_base_stream(stream: *mut GFilterOutputStream) -> gboolean;
    pub fn g_filter_output_stream_set_close_base_stream(stream: *mut GFilterOutputStream, close_base: gboolean);

    //=========================================================================
    // GIOModule
    //=========================================================================
    pub fn g_io_module_get_type() -> GType;
    pub fn g_io_module_new(filename: *mut c_char) -> *mut GIOModule;
    pub fn g_io_module_query() -> *mut *mut c_char;
    pub fn g_io_module_load(module: *mut GIOModule);
    pub fn g_io_module_unload(module: *mut GIOModule);

    //=========================================================================
    // GIOStream
    //=========================================================================
    pub fn g_io_stream_get_type() -> GType;
    pub fn g_io_stream_splice_finish(result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
    pub fn g_io_stream_close(stream: *mut GIOStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_io_stream_close_async(stream: *mut GIOStream, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_io_stream_close_finish(stream: *mut GIOStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_set_pending(stream: *mut GIOStream, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_io_stream_splice_async(stream1: *mut GIOStream, stream2: *mut GIOStream, flags: GIOStreamSpliceFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // GInetAddress
    //=========================================================================
    pub fn g_inet_address_get_type() -> GType;
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_new_from_bytes(bytes: *mut u8, family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_new_from_string(string: *const c_char) -> *mut GInetAddress;
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_equal(address: *mut GInetAddress, other_address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> size_t;
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> *const u8;
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut c_char;

    //=========================================================================
    // GInetAddressMask
    //=========================================================================
    pub fn g_inet_address_mask_get_type() -> GType;
    pub fn g_inet_address_mask_new(addr: *mut GInetAddress, length: c_uint, error: *mut *mut glib::GError) -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_new_from_string(mask_string: *const c_char, error: *mut *mut glib::GError) -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_equal(mask: *mut GInetAddressMask, mask2: *mut GInetAddressMask) -> gboolean;
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> c_uint;
    pub fn g_inet_address_mask_matches(mask: *mut GInetAddressMask, address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut c_char;

    //=========================================================================
    // GInetSocketAddress
    //=========================================================================
    pub fn g_inet_socket_address_get_type() -> GType;
    pub fn g_inet_socket_address_new(address: *mut GInetAddress, port: u16) -> *mut GSocketAddress;
    #[cfg(feature = "v2_40")]
    pub fn g_inet_socket_address_new_from_string(address: *const c_char, port: c_uint) -> *mut GSocketAddress;
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress) -> *mut GInetAddress;
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> u32;
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> u16;
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> u32;

    //=========================================================================
    // GInputStream
    //=========================================================================
    pub fn g_input_stream_get_type() -> GType;
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
    pub fn g_input_stream_close(stream: *mut GInputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_input_stream_close_async(stream: *mut GInputStream, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_input_stream_close_finish(stream: *mut GInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_read(stream: *mut GInputStream, buffer: *mut u8, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_input_stream_read_all(stream: *mut GInputStream, buffer: *mut u8, count: size_t, bytes_read: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_input_stream_read_all_async(stream: *mut GInputStream, buffer: *mut u8, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_44")]
    pub fn g_input_stream_read_all_finish(stream: *mut GInputStream, result: *mut GAsyncResult, bytes_read: *mut size_t, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_input_stream_read_async(stream: *mut GInputStream, buffer: *mut u8, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_34")]
    pub fn g_input_stream_read_bytes(stream: *mut GInputStream, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GBytes;
    #[cfg(feature = "v2_34")]
    pub fn g_input_stream_read_bytes_async(stream: *mut GInputStream, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_34")]
    pub fn g_input_stream_read_bytes_finish(stream: *mut GInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GBytes;
    pub fn g_input_stream_read_finish(stream: *mut GInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_input_stream_set_pending(stream: *mut GInputStream, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_input_stream_skip(stream: *mut GInputStream, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_input_stream_skip_async(stream: *mut GInputStream, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_input_stream_skip_finish(stream: *mut GInputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;

    //=========================================================================
    // GListStore
    //=========================================================================
    pub fn g_list_store_get_type() -> GType;
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_append(store: *mut GListStore, item: *mut gobject::GObject);
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_insert(store: *mut GListStore, position: c_uint, item: *mut gobject::GObject);
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_insert_sorted(store: *mut GListStore, item: *mut gobject::GObject, compare_func: glib::GCompareDataFunc, user_data: gpointer) -> c_uint;
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_remove(store: *mut GListStore, position: c_uint);
    #[cfg(feature = "v2_44")]
    pub fn g_list_store_remove_all(store: *mut GListStore);
    #[cfg(feature = "v2_46")]
    pub fn g_list_store_sort(store: *mut GListStore, compare_func: glib::GCompareDataFunc, user_data: gpointer);
    //#[cfg(feature = "v2_44")]
    //pub fn g_list_store_splice(store: *mut GListStore, position: c_uint, n_removals: c_uint, additions: /*Metadata mismatch*/*mut [c:type mismatch gpointer != GObject of Object], n_additions: c_uint);

    //=========================================================================
    // GMemoryInputStream
    //=========================================================================
    pub fn g_memory_input_stream_get_type() -> GType;
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
    #[cfg(feature = "v2_34")]
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut glib::GBytes) -> *mut GInputStream;
    pub fn g_memory_input_stream_new_from_data(data: *mut u8, len: ssize_t, destroy: glib::GDestroyNotify) -> *mut GInputStream;
    #[cfg(feature = "v2_34")]
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut glib::GBytes);
    pub fn g_memory_input_stream_add_data(stream: *mut GMemoryInputStream, data: *mut u8, len: ssize_t, destroy: glib::GDestroyNotify);

    //=========================================================================
    // GMemoryOutputStream
    //=========================================================================
    pub fn g_memory_output_stream_get_type() -> GType;
    pub fn g_memory_output_stream_new(data: gpointer, size: size_t, realloc_function: GReallocFunc, destroy_function: glib::GDestroyNotify) -> *mut GOutputStream;
    #[cfg(feature = "v2_36")]
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> size_t;
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> size_t;
    #[cfg(feature = "v2_34")]
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut glib::GBytes;
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;

    //=========================================================================
    // GMenu
    //=========================================================================
    pub fn g_menu_get_type() -> GType;
    pub fn g_menu_new() -> *mut GMenu;
    pub fn g_menu_append(menu: *mut GMenu, label: *const c_char, detailed_action: *const c_char);
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const c_char, section: *mut GMenuModel);
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const c_char, submenu: *mut GMenuModel);
    pub fn g_menu_freeze(menu: *mut GMenu);
    pub fn g_menu_insert(menu: *mut GMenu, position: c_int, label: *const c_char, detailed_action: *const c_char);
    pub fn g_menu_insert_item(menu: *mut GMenu, position: c_int, item: *mut GMenuItem);
    pub fn g_menu_insert_section(menu: *mut GMenu, position: c_int, label: *const c_char, section: *mut GMenuModel);
    pub fn g_menu_insert_submenu(menu: *mut GMenu, position: c_int, label: *const c_char, submenu: *mut GMenuModel);
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const c_char, detailed_action: *const c_char);
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const c_char, section: *mut GMenuModel);
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const c_char, submenu: *mut GMenuModel);
    pub fn g_menu_remove(menu: *mut GMenu, position: c_int);
    #[cfg(feature = "v2_38")]
    pub fn g_menu_remove_all(menu: *mut GMenu);

    //=========================================================================
    // GMenuAttributeIter
    //=========================================================================
    pub fn g_menu_attribute_iter_get_type() -> GType;
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const c_char;
    pub fn g_menu_attribute_iter_get_next(iter: *mut GMenuAttributeIter, out_name: *mut *const c_char, value: *mut *mut glib::GVariant) -> gboolean;
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut glib::GVariant;
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;

    //=========================================================================
    // GMenuItem
    //=========================================================================
    pub fn g_menu_item_get_type() -> GType;
    pub fn g_menu_item_new(label: *const c_char, detailed_action: *const c_char) -> *mut GMenuItem;
    #[cfg(feature = "v2_34")]
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: c_int) -> *mut GMenuItem;
    pub fn g_menu_item_new_section(label: *const c_char, section: *mut GMenuModel) -> *mut GMenuItem;
    pub fn g_menu_item_new_submenu(label: *const c_char, submenu: *mut GMenuModel) -> *mut GMenuItem;
    #[cfg(feature = "v2_34")]
    pub fn g_menu_item_get_attribute(menu_item: *mut GMenuItem, attribute: *const c_char, format_string: *const c_char, ...) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_menu_item_get_attribute_value(menu_item: *mut GMenuItem, attribute: *const c_char, expected_type: *const glib::GVariantType) -> *mut glib::GVariant;
    #[cfg(feature = "v2_34")]
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const c_char) -> *mut GMenuModel;
    pub fn g_menu_item_set_action_and_target(menu_item: *mut GMenuItem, action: *const c_char, format_string: *const c_char, ...);
    pub fn g_menu_item_set_action_and_target_value(menu_item: *mut GMenuItem, action: *const c_char, target_value: *mut glib::GVariant);
    pub fn g_menu_item_set_attribute(menu_item: *mut GMenuItem, attribute: *const c_char, format_string: *const c_char, ...);
    pub fn g_menu_item_set_attribute_value(menu_item: *mut GMenuItem, attribute: *const c_char, value: *mut glib::GVariant);
    pub fn g_menu_item_set_detailed_action(menu_item: *mut GMenuItem, detailed_action: *const c_char);
    #[cfg(feature = "v2_38")]
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const c_char);
    pub fn g_menu_item_set_link(menu_item: *mut GMenuItem, link: *const c_char, model: *mut GMenuModel);
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);

    //=========================================================================
    // GMenuLinkIter
    //=========================================================================
    pub fn g_menu_link_iter_get_type() -> GType;
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const c_char;
    pub fn g_menu_link_iter_get_next(iter: *mut GMenuLinkIter, out_link: *mut *const c_char, value: *mut *mut GMenuModel) -> gboolean;
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;

    //=========================================================================
    // GMenuModel
    //=========================================================================
    pub fn g_menu_model_get_type() -> GType;
    pub fn g_menu_model_get_item_attribute(model: *mut GMenuModel, item_index: c_int, attribute: *const c_char, format_string: *const c_char, ...) -> gboolean;
    pub fn g_menu_model_get_item_attribute_value(model: *mut GMenuModel, item_index: c_int, attribute: *const c_char, expected_type: *const glib::GVariantType) -> *mut glib::GVariant;
    pub fn g_menu_model_get_item_link(model: *mut GMenuModel, item_index: c_int, link: *const c_char) -> *mut GMenuModel;
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> c_int;
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
    pub fn g_menu_model_items_changed(model: *mut GMenuModel, position: c_int, removed: c_int, added: c_int);
    pub fn g_menu_model_iterate_item_attributes(model: *mut GMenuModel, item_index: c_int) -> *mut GMenuAttributeIter;
    pub fn g_menu_model_iterate_item_links(model: *mut GMenuModel, item_index: c_int) -> *mut GMenuLinkIter;

    //=========================================================================
    // GMountOperation
    //=========================================================================
    pub fn g_mount_operation_get_type() -> GType;
    pub fn g_mount_operation_new() -> *mut GMountOperation;
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> c_int;
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const c_char;
    pub fn g_mount_operation_get_password(op: *mut GMountOperation) -> *const c_char;
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
    pub fn g_mount_operation_get_username(op: *mut GMountOperation) -> *const c_char;
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: c_int);
    pub fn g_mount_operation_set_domain(op: *mut GMountOperation, domain: *const c_char);
    pub fn g_mount_operation_set_password(op: *mut GMountOperation, password: *const c_char);
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
    pub fn g_mount_operation_set_username(op: *mut GMountOperation, username: *const c_char);

    //=========================================================================
    // GNativeVolumeMonitor
    //=========================================================================
    pub fn g_native_volume_monitor_get_type() -> GType;

    //=========================================================================
    // GNetworkAddress
    //=========================================================================
    pub fn g_network_address_get_type() -> GType;
    pub fn g_network_address_new(hostname: *const c_char, port: u16) -> *mut GNetworkAddress;
    #[cfg(feature = "v2_44")]
    pub fn g_network_address_new_loopback(port: u16) -> *mut GNetworkAddress;
    pub fn g_network_address_parse(host_and_port: *const c_char, default_port: u16, error: *mut *mut glib::GError) -> *mut GNetworkAddress;
    pub fn g_network_address_parse_uri(uri: *const c_char, default_port: u16, error: *mut *mut glib::GError) -> *mut GNetworkAddress;
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const c_char;
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> u16;
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const c_char;

    //=========================================================================
    // GNetworkService
    //=========================================================================
    pub fn g_network_service_get_type() -> GType;
    pub fn g_network_service_new(service: *const c_char, protocol: *const c_char, domain: *const c_char) -> *mut GNetworkService;
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const c_char;
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const c_char;
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const c_char;
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const c_char;
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const c_char);

    //=========================================================================
    // GNotification
    //=========================================================================
    pub fn g_notification_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_notification_new(title: *const c_char) -> *mut GNotification;
    #[cfg(feature = "v2_40")]
    pub fn g_notification_add_button(notification: *mut GNotification, label: *const c_char, detailed_action: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_add_button_with_target(notification: *mut GNotification, label: *const c_char, action: *const c_char, target_format: *const c_char, ...);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_add_button_with_target_value(notification: *mut GNotification, label: *const c_char, action: *const c_char, target: *mut glib::GVariant);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_default_action(notification: *mut GNotification, detailed_action: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_default_action_and_target(notification: *mut GNotification, action: *const c_char, target_format: *const c_char, ...);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_default_action_and_target_value(notification: *mut GNotification, action: *const c_char, target: *mut glib::GVariant);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
    pub fn g_notification_set_priority(notification: *mut GNotification, priority: GNotificationPriority);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);

    //=========================================================================
    // GOutputStream
    //=========================================================================
    pub fn g_output_stream_get_type() -> GType;
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
    pub fn g_output_stream_close(stream: *mut GOutputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_close_async(stream: *mut GOutputStream, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_output_stream_close_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_flush(stream: *mut GOutputStream, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_flush_async(stream: *mut GOutputStream, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_output_stream_flush_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_output_stream_printf(stream: *mut GOutputStream, bytes_written: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError, format: *const c_char, ...) -> gboolean;
    pub fn g_output_stream_set_pending(stream: *mut GOutputStream, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_splice(stream: *mut GOutputStream, source: *mut GInputStream, flags: GOutputStreamSpliceFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_output_stream_splice_async(stream: *mut GOutputStream, source: *mut GInputStream, flags: GOutputStreamSpliceFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_output_stream_splice_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;
    //#[cfg(feature = "v2_40")]
    //pub fn g_output_stream_vprintf(stream: *mut GOutputStream, bytes_written: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError, format: *const c_char, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn g_output_stream_write(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_output_stream_write_all(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, bytes_written: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_output_stream_write_all_async(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_44")]
    pub fn g_output_stream_write_all_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, bytes_written: *mut size_t, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_output_stream_write_async(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_output_stream_write_bytes(stream: *mut GOutputStream, bytes: *mut glib::GBytes, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_output_stream_write_bytes_async(stream: *mut GOutputStream, bytes: *mut glib::GBytes, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_output_stream_write_bytes_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_output_stream_write_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> ssize_t;

    //=========================================================================
    // GPermission
    //=========================================================================
    pub fn g_permission_get_type() -> GType;
    pub fn g_permission_acquire(permission: *mut GPermission, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_permission_acquire_async(permission: *mut GPermission, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_permission_acquire_finish(permission: *mut GPermission, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_impl_update(permission: *mut GPermission, allowed: gboolean, can_acquire: gboolean, can_release: gboolean);
    pub fn g_permission_release(permission: *mut GPermission, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_permission_release_async(permission: *mut GPermission, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_permission_release_finish(permission: *mut GPermission, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GPropertyAction
    //=========================================================================
    pub fn g_property_action_get_type() -> GType;
    #[cfg(feature = "v2_38")]
    pub fn g_property_action_new(name: *const c_char, object: *mut gobject::GObject, property_name: *const c_char) -> *mut GPropertyAction;

    //=========================================================================
    // GProxyAddress
    //=========================================================================
    pub fn g_proxy_address_get_type() -> GType;
    pub fn g_proxy_address_new(inetaddr: *mut GInetAddress, port: u16, protocol: *const c_char, dest_hostname: *const c_char, dest_port: u16, username: *const c_char, password: *const c_char) -> *mut GSocketAddress;
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const c_char;
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> u16;
    #[cfg(feature = "v2_34")]
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const c_char;
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const c_char;
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const c_char;
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const c_char;

    //=========================================================================
    // GProxyAddressEnumerator
    //=========================================================================
    pub fn g_proxy_address_enumerator_get_type() -> GType;

    //=========================================================================
    // GResolver
    //=========================================================================
    pub fn g_resolver_get_type() -> GType;
    pub fn g_resolver_free_addresses(addresses: *mut glib::GList);
    pub fn g_resolver_free_targets(targets: *mut glib::GList);
    pub fn g_resolver_get_default() -> *mut GResolver;
    pub fn g_resolver_lookup_by_address(resolver: *mut GResolver, address: *mut GInetAddress, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_resolver_lookup_by_address_async(resolver: *mut GResolver, address: *mut GInetAddress, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_resolver_lookup_by_address_finish(resolver: *mut GResolver, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_resolver_lookup_by_name(resolver: *mut GResolver, hostname: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_resolver_lookup_by_name_async(resolver: *mut GResolver, hostname: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_resolver_lookup_by_name_finish(resolver: *mut GResolver, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GList;
    #[cfg(feature = "v2_34")]
    pub fn g_resolver_lookup_records(resolver: *mut GResolver, rrname: *const c_char, record_type: GResolverRecordType, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GList;
    #[cfg(feature = "v2_34")]
    pub fn g_resolver_lookup_records_async(resolver: *mut GResolver, rrname: *const c_char, record_type: GResolverRecordType, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_34")]
    pub fn g_resolver_lookup_records_finish(resolver: *mut GResolver, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_resolver_lookup_service(resolver: *mut GResolver, service: *const c_char, protocol: *const c_char, domain: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_resolver_lookup_service_async(resolver: *mut GResolver, service: *const c_char, protocol: *const c_char, domain: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_resolver_lookup_service_finish(resolver: *mut GResolver, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_resolver_set_default(resolver: *mut GResolver);

    //=========================================================================
    // GSettings
    //=========================================================================
    pub fn g_settings_get_type() -> GType;
    pub fn g_settings_new(schema_id: *const c_char) -> *mut GSettings;
    pub fn g_settings_new_full(schema: *mut GSettingsSchema, backend: *mut GSettingsBackend, path: *const c_char) -> *mut GSettings;
    pub fn g_settings_new_with_backend(schema_id: *const c_char, backend: *mut GSettingsBackend) -> *mut GSettings;
    pub fn g_settings_new_with_backend_and_path(schema_id: *const c_char, backend: *mut GSettingsBackend, path: *const c_char) -> *mut GSettings;
    pub fn g_settings_new_with_path(schema_id: *const c_char, path: *const c_char) -> *mut GSettings;
    pub fn g_settings_list_relocatable_schemas() -> *const *const c_char;
    pub fn g_settings_list_schemas() -> *const *const c_char;
    pub fn g_settings_sync();
    pub fn g_settings_unbind(object: *mut gobject::GObject, property: *const c_char);
    pub fn g_settings_apply(settings: *mut GSettings);
    pub fn g_settings_bind(settings: *mut GSettings, key: *const c_char, object: *mut gobject::GObject, property: *const c_char, flags: GSettingsBindFlags);
    pub fn g_settings_bind_with_mapping(settings: *mut GSettings, key: *const c_char, object: *mut gobject::GObject, property: *const c_char, flags: GSettingsBindFlags, get_mapping: GSettingsBindGetMapping, set_mapping: GSettingsBindSetMapping, user_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn g_settings_bind_writable(settings: *mut GSettings, key: *const c_char, object: *mut gobject::GObject, property: *const c_char, inverted: gboolean);
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const c_char) -> *mut GAction;
    pub fn g_settings_delay(settings: *mut GSettings);
    pub fn g_settings_get(settings: *mut GSettings, key: *const c_char, format: *const c_char, ...);
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const c_char) -> gboolean;
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const c_char) -> *mut GSettings;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_get_default_value(settings: *mut GSettings, key: *const c_char) -> *mut glib::GVariant;
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const c_char) -> c_double;
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const c_char) -> c_int;
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const c_char) -> c_uint;
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const c_char) -> c_int;
    #[cfg(feature = "v2_50")]
    pub fn g_settings_get_int64(settings: *mut GSettings, key: *const c_char) -> i64;
    pub fn g_settings_get_mapped(settings: *mut GSettings, key: *const c_char, mapping: GSettingsGetMapping, user_data: gpointer) -> gpointer;
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const c_char) -> *mut glib::GVariant;
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const c_char) -> *mut c_char;
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const c_char) -> *mut *mut c_char;
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const c_char) -> c_uint;
    #[cfg(feature = "v2_50")]
    pub fn g_settings_get_uint64(settings: *mut GSettings, key: *const c_char) -> u64;
    #[cfg(feature = "v2_40")]
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const c_char) -> *mut glib::GVariant;
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const c_char) -> *mut glib::GVariant;
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const c_char) -> gboolean;
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut c_char;
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut c_char;
    pub fn g_settings_range_check(settings: *mut GSettings, key: *const c_char, value: *mut glib::GVariant) -> gboolean;
    pub fn g_settings_reset(settings: *mut GSettings, key: *const c_char);
    pub fn g_settings_revert(settings: *mut GSettings);
    pub fn g_settings_set(settings: *mut GSettings, key: *const c_char, format: *const c_char, ...) -> gboolean;
    pub fn g_settings_set_boolean(settings: *mut GSettings, key: *const c_char, value: gboolean) -> gboolean;
    pub fn g_settings_set_double(settings: *mut GSettings, key: *const c_char, value: c_double) -> gboolean;
    pub fn g_settings_set_enum(settings: *mut GSettings, key: *const c_char, value: c_int) -> gboolean;
    pub fn g_settings_set_flags(settings: *mut GSettings, key: *const c_char, value: c_uint) -> gboolean;
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const c_char, value: c_int) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_settings_set_int64(settings: *mut GSettings, key: *const c_char, value: i64) -> gboolean;
    pub fn g_settings_set_string(settings: *mut GSettings, key: *const c_char, value: *const c_char) -> gboolean;
    pub fn g_settings_set_strv(settings: *mut GSettings, key: *const c_char, value: *mut *mut c_char) -> gboolean;
    pub fn g_settings_set_uint(settings: *mut GSettings, key: *const c_char, value: c_uint) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_settings_set_uint64(settings: *mut GSettings, key: *const c_char, value: u64) -> gboolean;
    pub fn g_settings_set_value(settings: *mut GSettings, key: *const c_char, value: *mut glib::GVariant) -> gboolean;

    //=========================================================================
    // GSimpleAction
    //=========================================================================
    pub fn g_simple_action_get_type() -> GType;
    pub fn g_simple_action_new(name: *const c_char, parameter_type: *const glib::GVariantType) -> *mut GSimpleAction;
    pub fn g_simple_action_new_stateful(name: *const c_char, parameter_type: *const glib::GVariantType, state: *mut glib::GVariant) -> *mut GSimpleAction;
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut glib::GVariant);
    #[cfg(feature = "v2_44")]
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut glib::GVariant);

    //=========================================================================
    // GSimpleActionGroup
    //=========================================================================
    pub fn g_simple_action_group_get_type() -> GType;
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
    pub fn g_simple_action_group_add_entries(simple: *mut GSimpleActionGroup, entries: *mut GActionEntry, n_entries: c_int, user_data: gpointer);
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
    pub fn g_simple_action_group_lookup(simple: *mut GSimpleActionGroup, action_name: *const c_char) -> *mut GAction;
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const c_char);

    //=========================================================================
    // GSimpleAsyncResult
    //=========================================================================
    pub fn g_simple_async_result_get_type() -> GType;
    pub fn g_simple_async_result_new(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, source_tag: gpointer) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_error(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: glib::GQuark, code: c_int, format: *const c_char, ...) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_from_error(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, error: *const glib::GError) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_take_error(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, error: *mut glib::GError) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_is_valid(result: *mut GAsyncResult, source: *mut gobject::GObject, source_tag: gpointer) -> gboolean;
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> ssize_t;
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
    pub fn g_simple_async_result_propagate_error(simple: *mut GSimpleAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_simple_async_result_run_in_thread(simple: *mut GSimpleAsyncResult, func: GSimpleAsyncThreadFunc, io_priority: c_int, cancellable: *mut GCancellable);
    pub fn g_simple_async_result_set_check_cancellable(simple: *mut GSimpleAsyncResult, check_cancellable: *mut GCancellable);
    pub fn g_simple_async_result_set_error(simple: *mut GSimpleAsyncResult, domain: glib::GQuark, code: c_int, format: *const c_char, ...);
    //pub fn g_simple_async_result_set_error_va(simple: *mut GSimpleAsyncResult, domain: glib::GQuark, code: c_int, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn g_simple_async_result_set_from_error(simple: *mut GSimpleAsyncResult, error: *const glib::GError);
    pub fn g_simple_async_result_set_handle_cancellation(simple: *mut GSimpleAsyncResult, handle_cancellation: gboolean);
    pub fn g_simple_async_result_set_op_res_gboolean(simple: *mut GSimpleAsyncResult, op_res: gboolean);
    pub fn g_simple_async_result_set_op_res_gpointer(simple: *mut GSimpleAsyncResult, op_res: gpointer, destroy_op_res: glib::GDestroyNotify);
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: ssize_t);
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut glib::GError);

    //=========================================================================
    // GSimpleIOStream
    //=========================================================================
    pub fn g_simple_io_stream_get_type() -> GType;
    #[cfg(feature = "v2_44")]
    pub fn g_simple_io_stream_new(input_stream: *mut GInputStream, output_stream: *mut GOutputStream) -> *mut GIOStream;

    //=========================================================================
    // GSimplePermission
    //=========================================================================
    pub fn g_simple_permission_get_type() -> GType;
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;

    //=========================================================================
    // GSimpleProxyResolver
    //=========================================================================
    pub fn g_simple_proxy_resolver_get_type() -> GType;
    #[cfg(feature = "v2_36")]
    pub fn g_simple_proxy_resolver_new(default_proxy: *const c_char, ignore_hosts: *mut *mut c_char) -> *mut GProxyResolver;
    #[cfg(feature = "v2_36")]
    pub fn g_simple_proxy_resolver_set_default_proxy(resolver: *mut GSimpleProxyResolver, default_proxy: *const c_char);
    #[cfg(feature = "v2_36")]
    pub fn g_simple_proxy_resolver_set_ignore_hosts(resolver: *mut GSimpleProxyResolver, ignore_hosts: *mut *mut c_char);
    #[cfg(feature = "v2_36")]
    pub fn g_simple_proxy_resolver_set_uri_proxy(resolver: *mut GSimpleProxyResolver, uri_scheme: *const c_char, proxy: *const c_char);

    //=========================================================================
    // GSocket
    //=========================================================================
    pub fn g_socket_get_type() -> GType;
    pub fn g_socket_new(family: GSocketFamily, type_: GSocketType, protocol: GSocketProtocol, error: *mut *mut glib::GError) -> *mut GSocket;
    pub fn g_socket_new_from_fd(fd: c_int, error: *mut *mut glib::GError) -> *mut GSocket;
    pub fn g_socket_accept(socket: *mut GSocket, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocket;
    pub fn g_socket_bind(socket: *mut GSocket, address: *mut GSocketAddress, allow_reuse: gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_check_connect_result(socket: *mut GSocket, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: glib::GIOCondition) -> glib::GIOCondition;
    pub fn g_socket_condition_timed_wait(socket: *mut GSocket, condition: glib::GIOCondition, timeout: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_condition_wait(socket: *mut GSocket, condition: glib::GIOCondition, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_connect(socket: *mut GSocket, address: *mut GSocketAddress, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_connection_factory_create_connection(socket: *mut GSocket) -> *mut GSocketConnection;
    pub fn g_socket_create_source(socket: *mut GSocket, condition: glib::GIOCondition, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> ssize_t;
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_credentials(socket: *mut GSocket, error: *mut *mut glib::GError) -> *mut GCredentials;
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
    pub fn g_socket_get_fd(socket: *mut GSocket) -> c_int;
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> c_int;
    pub fn g_socket_get_local_address(socket: *mut GSocket, error: *mut *mut glib::GError) -> *mut GSocketAddress;
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> c_uint;
    #[cfg(feature = "v2_36")]
    pub fn g_socket_get_option(socket: *mut GSocket, level: c_int, optname: c_int, value: *mut c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
    pub fn g_socket_get_remote_address(socket: *mut GSocket, error: *mut *mut glib::GError) -> *mut GSocketAddress;
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> c_uint;
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> c_uint;
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_join_multicast_group(socket: *mut GSocket, group: *mut GInetAddress, source_specific: gboolean, iface: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_leave_multicast_group(socket: *mut GSocket, group: *mut GInetAddress, source_specific: gboolean, iface: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_receive(socket: *mut GSocket, buffer: *mut u8, size: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_receive_from(socket: *mut GSocket, address: *mut *mut GSocketAddress, buffer: *mut u8, size: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_receive_message(socket: *mut GSocket, address: *mut *mut GSocketAddress, vectors: *mut GInputVector, num_vectors: c_int, messages: *mut *mut *mut GSocketControlMessage, num_messages: *mut c_int, flags: *mut c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    #[cfg(feature = "v2_48")]
    pub fn g_socket_receive_messages(socket: *mut GSocket, messages: *mut GInputMessage, num_messages: c_uint, flags: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;
    pub fn g_socket_receive_with_blocking(socket: *mut GSocket, buffer: *mut u8, size: size_t, blocking: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_send(socket: *mut GSocket, buffer: *mut u8, size: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_send_message(socket: *mut GSocket, address: *mut GSocketAddress, vectors: *mut GOutputVector, num_vectors: c_int, messages: *mut *mut GSocketControlMessage, num_messages: c_int, flags: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    #[cfg(feature = "v2_44")]
    pub fn g_socket_send_messages(socket: *mut GSocket, messages: *mut GOutputMessage, num_messages: c_uint, flags: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;
    pub fn g_socket_send_to(socket: *mut GSocket, address: *mut GSocketAddress, buffer: *mut u8, size: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_send_with_blocking(socket: *mut GSocket, buffer: *mut u8, size: size_t, blocking: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: c_int);
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: c_uint);
    #[cfg(feature = "v2_36")]
    pub fn g_socket_set_option(socket: *mut GSocket, level: c_int, optname: c_int, value: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: c_uint);
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: c_uint);
    pub fn g_socket_shutdown(socket: *mut GSocket, shutdown_read: gboolean, shutdown_write: gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;

    //=========================================================================
    // GSocketAddress
    //=========================================================================
    pub fn g_socket_address_get_type() -> GType;
    pub fn g_socket_address_new_from_native(native: gpointer, len: size_t) -> *mut GSocketAddress;
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> ssize_t;
    pub fn g_socket_address_to_native(address: *mut GSocketAddress, dest: gpointer, destlen: size_t, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GSocketAddressEnumerator
    //=========================================================================
    pub fn g_socket_address_enumerator_get_type() -> GType;
    pub fn g_socket_address_enumerator_next(enumerator: *mut GSocketAddressEnumerator, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketAddress;
    pub fn g_socket_address_enumerator_next_async(enumerator: *mut GSocketAddressEnumerator, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_address_enumerator_next_finish(enumerator: *mut GSocketAddressEnumerator, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GSocketAddress;

    //=========================================================================
    // GSocketClient
    //=========================================================================
    pub fn g_socket_client_get_type() -> GType;
    pub fn g_socket_client_new() -> *mut GSocketClient;
    pub fn g_socket_client_add_application_proxy(client: *mut GSocketClient, protocol: *const c_char);
    pub fn g_socket_client_connect(client: *mut GSocketClient, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_async(client: *mut GSocketClient, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_client_connect_finish(client: *mut GSocketClient, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host(client: *mut GSocketClient, host_and_port: *const c_char, default_port: u16, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host_async(client: *mut GSocketClient, host_and_port: *const c_char, default_port: u16, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_client_connect_to_host_finish(client: *mut GSocketClient, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service(client: *mut GSocketClient, domain: *const c_char, service: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service_async(client: *mut GSocketClient, domain: *const c_char, service: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_client_connect_to_service_finish(client: *mut GSocketClient, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri(client: *mut GSocketClient, uri: *const c_char, default_port: u16, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri_async(client: *mut GSocketClient, uri: *const c_char, default_port: u16, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_client_connect_to_uri_finish(client: *mut GSocketClient, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
    #[cfg(feature = "v2_36")]
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> c_uint;
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
    pub fn g_socket_client_get_tls_validation_flags(client: *mut GSocketClient) -> GTlsCertificateFlags;
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
    pub fn g_socket_client_set_local_address(client: *mut GSocketClient, address: *mut GSocketAddress);
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
    #[cfg(feature = "v2_36")]
    pub fn g_socket_client_set_proxy_resolver(client: *mut GSocketClient, proxy_resolver: *mut GProxyResolver);
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: c_uint);
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
    pub fn g_socket_client_set_tls_validation_flags(client: *mut GSocketClient, flags: GTlsCertificateFlags);

    //=========================================================================
    // GSocketConnection
    //=========================================================================
    pub fn g_socket_connection_get_type() -> GType;
    pub fn g_socket_connection_factory_lookup_type(family: GSocketFamily, type_: GSocketType, protocol_id: c_int) -> GType;
    pub fn g_socket_connection_factory_register_type(g_type: GType, family: GSocketFamily, type_: GSocketType, protocol: c_int);
    pub fn g_socket_connection_connect(connection: *mut GSocketConnection, address: *mut GSocketAddress, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_connection_connect_async(connection: *mut GSocketConnection, address: *mut GSocketAddress, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_connection_connect_finish(connection: *mut GSocketConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_connection_get_local_address(connection: *mut GSocketConnection, error: *mut *mut glib::GError) -> *mut GSocketAddress;
    pub fn g_socket_connection_get_remote_address(connection: *mut GSocketConnection, error: *mut *mut glib::GError) -> *mut GSocketAddress;
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;

    //=========================================================================
    // GSocketControlMessage
    //=========================================================================
    pub fn g_socket_control_message_get_type() -> GType;
    pub fn g_socket_control_message_deserialize(level: c_int, type_: c_int, size: size_t, data: gpointer) -> *mut GSocketControlMessage;
    pub fn g_socket_control_message_get_level(message: *mut GSocketControlMessage) -> c_int;
    pub fn g_socket_control_message_get_msg_type(message: *mut GSocketControlMessage) -> c_int;
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> size_t;
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);

    //=========================================================================
    // GSocketListener
    //=========================================================================
    pub fn g_socket_listener_get_type() -> GType;
    pub fn g_socket_listener_new() -> *mut GSocketListener;
    pub fn g_socket_listener_accept(listener: *mut GSocketListener, source_object: *mut *mut gobject::GObject, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_listener_accept_async(listener: *mut GSocketListener, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_listener_accept_finish(listener: *mut GSocketListener, result: *mut GAsyncResult, source_object: *mut *mut gobject::GObject, error: *mut *mut glib::GError) -> *mut GSocketConnection;
    pub fn g_socket_listener_accept_socket(listener: *mut GSocketListener, source_object: *mut *mut gobject::GObject, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GSocket;
    pub fn g_socket_listener_accept_socket_async(listener: *mut GSocketListener, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_socket_listener_accept_socket_finish(listener: *mut GSocketListener, result: *mut GAsyncResult, source_object: *mut *mut gobject::GObject, error: *mut *mut glib::GError) -> *mut GSocket;
    pub fn g_socket_listener_add_address(listener: *mut GSocketListener, address: *mut GSocketAddress, type_: GSocketType, protocol: GSocketProtocol, source_object: *mut gobject::GObject, effective_address: *mut *mut GSocketAddress, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_listener_add_any_inet_port(listener: *mut GSocketListener, source_object: *mut gobject::GObject, error: *mut *mut glib::GError) -> u16;
    pub fn g_socket_listener_add_inet_port(listener: *mut GSocketListener, port: u16, source_object: *mut gobject::GObject, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_listener_add_socket(listener: *mut GSocketListener, socket: *mut GSocket, source_object: *mut gobject::GObject, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
    pub fn g_socket_listener_set_backlog(listener: *mut GSocketListener, listen_backlog: c_int);

    //=========================================================================
    // GSocketService
    //=========================================================================
    pub fn g_socket_service_get_type() -> GType;
    pub fn g_socket_service_new() -> *mut GSocketService;
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
    pub fn g_socket_service_start(service: *mut GSocketService);
    pub fn g_socket_service_stop(service: *mut GSocketService);

    //=========================================================================
    // GSubprocess
    //=========================================================================
    pub fn g_subprocess_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_new(flags: GSubprocessFlags, error: *mut *mut glib::GError, argv0: *const c_char, ...) -> *mut GSubprocess;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_newv(argv: *mut *mut c_char, flags: GSubprocessFlags, error: *mut *mut glib::GError) -> *mut GSubprocess;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_communicate(subprocess: *mut GSubprocess, stdin_buf: *mut glib::GBytes, cancellable: *mut GCancellable, stdout_buf: *mut *mut glib::GBytes, stderr_buf: *mut *mut glib::GBytes, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_subprocess_communicate_async(subprocess: *mut GSubprocess, stdin_buf: *mut glib::GBytes, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_subprocess_communicate_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, stdout_buf: *mut *mut glib::GBytes, stderr_buf: *mut *mut glib::GBytes, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_subprocess_communicate_utf8(subprocess: *mut GSubprocess, stdin_buf: *const c_char, cancellable: *mut GCancellable, stdout_buf: *mut *mut c_char, stderr_buf: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_subprocess_communicate_utf8_async(subprocess: *mut GSubprocess, stdin_buf: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_subprocess_communicate_utf8_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, stdout_buf: *mut *mut c_char, stderr_buf: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> c_int;
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> c_int;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> c_int;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: c_int);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait_async(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait_check(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait_check_async(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait_check_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_wait_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GSubprocessLauncher
    //=========================================================================
    pub fn g_subprocess_launcher_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_getenv(self_: *mut GSubprocessLauncher, variable: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_child_setup(self_: *mut GSubprocessLauncher, child_setup: glib::GSpawnChildSetupFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *mut c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_flags(self_: *mut GSubprocessLauncher, flags: GSubprocessFlags);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_stderr_file_path(self_: *mut GSubprocessLauncher, path: *mut c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_stdin_file_path(self_: *mut GSubprocessLauncher, path: *const c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_set_stdout_file_path(self_: *mut GSubprocessLauncher, path: *mut c_char);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_setenv(self_: *mut GSubprocessLauncher, variable: *const c_char, value: *const c_char, overwrite: gboolean);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_spawn(self_: *mut GSubprocessLauncher, error: *mut *mut glib::GError, argv0: *const c_char, ...) -> *mut GSubprocess;
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_spawnv(self_: *mut GSubprocessLauncher, argv: *mut *mut c_char, error: *mut *mut glib::GError) -> *mut GSubprocess;
    pub fn g_subprocess_launcher_take_fd(self_: *mut GSubprocessLauncher, source_fd: c_int, target_fd: c_int);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: c_int);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: c_int);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: c_int);
    #[cfg(feature = "v2_40")]
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const c_char);

    //=========================================================================
    // GTask
    //=========================================================================
    pub fn g_task_get_type() -> GType;
    #[cfg(feature = "v2_36")]
    pub fn g_task_new(source_object: *mut gobject::GObject, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, callback_data: gpointer) -> *mut GTask;
    #[cfg(feature = "v2_36")]
    pub fn g_task_is_valid(result: *mut GAsyncResult, source_object: *mut gobject::GObject) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_report_error(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, error: *mut glib::GError);
    #[cfg(feature = "v2_36")]
    pub fn g_task_report_new_error(source_object: *mut gobject::GObject, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, domain: glib::GQuark, code: c_int, format: *const c_char, ...);
    #[cfg(feature = "v2_36")]
    pub fn g_task_attach_source(task: *mut GTask, source: *mut glib::GSource, callback: glib::GSourceFunc);
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_context(task: *mut GTask) -> *mut glib::GMainContext;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_priority(task: *mut GTask) -> c_int;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_source_object(task: *mut GTask) -> *mut gobject::GObject;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut glib::GError) -> ssize_t;
    #[cfg(feature = "v2_36")]
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut glib::GError) -> gpointer;
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_error(task: *mut GTask, error: *mut glib::GError);
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_int(task: *mut GTask, result: ssize_t);
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_new_error(task: *mut GTask, domain: glib::GQuark, code: c_int, format: *const c_char, ...);
    #[cfg(feature = "v2_36")]
    pub fn g_task_return_pointer(task: *mut GTask, result: gpointer, result_destroy: glib::GDestroyNotify);
    #[cfg(feature = "v2_36")]
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
    #[cfg(feature = "v2_36")]
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
    #[cfg(feature = "v2_36")]
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
    #[cfg(feature = "v2_36")]
    pub fn g_task_set_priority(task: *mut GTask, priority: c_int);
    #[cfg(feature = "v2_36")]
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
    #[cfg(feature = "v2_36")]
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
    #[cfg(feature = "v2_36")]
    pub fn g_task_set_task_data(task: *mut GTask, task_data: gpointer, task_data_destroy: glib::GDestroyNotify);

    //=========================================================================
    // GTcpConnection
    //=========================================================================
    pub fn g_tcp_connection_get_type() -> GType;
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
    pub fn g_tcp_connection_set_graceful_disconnect(connection: *mut GTcpConnection, graceful_disconnect: gboolean);

    //=========================================================================
    // GTcpWrapperConnection
    //=========================================================================
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
    pub fn g_tcp_wrapper_connection_new(base_io_stream: *mut GIOStream, socket: *mut GSocket) -> *mut GSocketConnection;
    pub fn g_tcp_wrapper_connection_get_base_io_stream(conn: *mut GTcpWrapperConnection) -> *mut GIOStream;

    //=========================================================================
    // GTestDBus
    //=========================================================================
    pub fn g_test_dbus_get_type() -> GType;
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
    pub fn g_test_dbus_unset();
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const c_char);
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const c_char;
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
    pub fn g_test_dbus_up(self_: *mut GTestDBus);

    //=========================================================================
    // GThemedIcon
    //=========================================================================
    pub fn g_themed_icon_get_type() -> GType;
    pub fn g_themed_icon_new(iconname: *const c_char) -> *mut GThemedIcon;
    pub fn g_themed_icon_new_from_names(iconnames: *mut *mut c_char, len: c_int) -> *mut GThemedIcon;
    pub fn g_themed_icon_new_with_default_fallbacks(iconname: *const c_char) -> *mut GThemedIcon;
    pub fn g_themed_icon_append_name(icon: *mut GThemedIcon, iconname: *const c_char);
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const c_char;
    pub fn g_themed_icon_prepend_name(icon: *mut GThemedIcon, iconname: *const c_char);

    //=========================================================================
    // GThreadedSocketService
    //=========================================================================
    pub fn g_threaded_socket_service_get_type() -> GType;
    pub fn g_threaded_socket_service_new(max_threads: c_int) -> *mut GSocketService;

    //=========================================================================
    // GTlsCertificate
    //=========================================================================
    pub fn g_tls_certificate_get_type() -> GType;
    pub fn g_tls_certificate_new_from_file(file: *mut c_char, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_files(cert_file: *mut c_char, key_file: *mut c_char, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_pem(data: *const c_char, length: ssize_t, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_list_new_from_file(file: *mut c_char, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
    #[cfg(feature = "v2_34")]
    pub fn g_tls_certificate_is_same(cert_one: *mut GTlsCertificate, cert_two: *mut GTlsCertificate) -> gboolean;
    pub fn g_tls_certificate_verify(cert: *mut GTlsCertificate, identity: *mut GSocketConnectable, trusted_ca: *mut GTlsCertificate) -> GTlsCertificateFlags;

    //=========================================================================
    // GTlsConnection
    //=========================================================================
    pub fn g_tls_connection_get_type() -> GType;
    pub fn g_tls_connection_emit_accept_certificate(conn: *mut GTlsConnection, peer_cert: *mut GTlsCertificate, errors: GTlsCertificateFlags) -> gboolean;
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
    pub fn g_tls_connection_get_peer_certificate_errors(conn: *mut GTlsConnection) -> GTlsCertificateFlags;
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
    pub fn g_tls_connection_handshake(conn: *mut GTlsConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_tls_connection_handshake_async(conn: *mut GTlsConnection, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_connection_handshake_finish(conn: *mut GTlsConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_tls_connection_set_certificate(conn: *mut GTlsConnection, certificate: *mut GTlsCertificate);
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
    pub fn g_tls_connection_set_interaction(conn: *mut GTlsConnection, interaction: *mut GTlsInteraction);
    pub fn g_tls_connection_set_rehandshake_mode(conn: *mut GTlsConnection, mode: GTlsRehandshakeMode);
    pub fn g_tls_connection_set_require_close_notify(conn: *mut GTlsConnection, require_close_notify: gboolean);
    pub fn g_tls_connection_set_use_system_certdb(conn: *mut GTlsConnection, use_system_certdb: gboolean);

    //=========================================================================
    // GTlsDatabase
    //=========================================================================
    pub fn g_tls_database_get_type() -> GType;
    pub fn g_tls_database_create_certificate_handle(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate) -> *mut c_char;
    pub fn g_tls_database_lookup_certificate_for_handle(self_: *mut GTlsDatabase, handle: *const c_char, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_for_handle_async(self_: *mut GTlsDatabase, handle: *const c_char, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_database_lookup_certificate_for_handle_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer_async(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_database_lookup_certificate_issuer_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificates_issued_by(self_: *mut GTlsDatabase, issuer_raw_dn: *mut glib::GByteArray, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_tls_database_lookup_certificates_issued_by_async(self_: *mut GTlsDatabase, issuer_raw_dn: *mut glib::GByteArray, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_database_lookup_certificates_issued_by_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn g_tls_database_verify_chain(self_: *mut GTlsDatabase, chain: *mut GTlsCertificate, purpose: *const c_char, identity: *mut GSocketConnectable, interaction: *mut GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> GTlsCertificateFlags;
    pub fn g_tls_database_verify_chain_async(self_: *mut GTlsDatabase, chain: *mut GTlsCertificate, purpose: *const c_char, identity: *mut GSocketConnectable, interaction: *mut GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_database_verify_chain_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> GTlsCertificateFlags;

    //=========================================================================
    // GTlsInteraction
    //=========================================================================
    pub fn g_tls_interaction_get_type() -> GType;
    pub fn g_tls_interaction_ask_password(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> GTlsInteractionResult;
    pub fn g_tls_interaction_ask_password_async(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_tls_interaction_ask_password_finish(interaction: *mut GTlsInteraction, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> GTlsInteractionResult;
    pub fn g_tls_interaction_invoke_ask_password(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> GTlsInteractionResult;
    #[cfg(feature = "v2_40")]
    pub fn g_tls_interaction_invoke_request_certificate(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> GTlsInteractionResult;
    #[cfg(feature = "v2_40")]
    pub fn g_tls_interaction_request_certificate(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> GTlsInteractionResult;
    #[cfg(feature = "v2_40")]
    pub fn g_tls_interaction_request_certificate_async(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_40")]
    pub fn g_tls_interaction_request_certificate_finish(interaction: *mut GTlsInteraction, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> GTlsInteractionResult;

    //=========================================================================
    // GTlsPassword
    //=========================================================================
    pub fn g_tls_password_get_type() -> GType;
    pub fn g_tls_password_new(flags: GTlsPasswordFlags, description: *const c_char) -> *mut GTlsPassword;
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const c_char;
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
    pub fn g_tls_password_get_value(password: *mut GTlsPassword, length: *mut size_t) -> *const u8;
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const c_char;
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const c_char);
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
    pub fn g_tls_password_set_value(password: *mut GTlsPassword, value: *const u8, length: ssize_t);
    pub fn g_tls_password_set_value_full(password: *mut GTlsPassword, value: *mut u8, length: ssize_t, destroy: glib::GDestroyNotify);
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const c_char);

    //=========================================================================
    // GUnixConnection
    //=========================================================================
    pub fn g_unix_connection_get_type() -> GType;
    pub fn g_unix_connection_receive_credentials(connection: *mut GUnixConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GCredentials;
    pub fn g_unix_connection_receive_credentials_async(connection: *mut GUnixConnection, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_unix_connection_receive_credentials_finish(connection: *mut GUnixConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GCredentials;
    pub fn g_unix_connection_receive_fd(connection: *mut GUnixConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;
    pub fn g_unix_connection_send_credentials(connection: *mut GUnixConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_unix_connection_send_credentials_async(connection: *mut GUnixConnection, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_unix_connection_send_credentials_finish(connection: *mut GUnixConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_unix_connection_send_fd(connection: *mut GUnixConnection, fd: c_int, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GUnixCredentialsMessage
    //=========================================================================
    pub fn g_unix_credentials_message_get_type() -> GType;
    pub fn g_unix_credentials_message_new() -> *mut GSocketControlMessage;
    pub fn g_unix_credentials_message_new_with_credentials(credentials: *mut GCredentials) -> *mut GSocketControlMessage;
    pub fn g_unix_credentials_message_is_supported() -> gboolean;
    pub fn g_unix_credentials_message_get_credentials(message: *mut GUnixCredentialsMessage) -> *mut GCredentials;

    //=========================================================================
    // GUnixFDList
    //=========================================================================
    pub fn g_unix_fd_list_get_type() -> GType;
    pub fn g_unix_fd_list_new() -> *mut GUnixFDList;
    pub fn g_unix_fd_list_new_from_array(fds: *mut c_int, n_fds: c_int) -> *mut GUnixFDList;
    pub fn g_unix_fd_list_append(list: *mut GUnixFDList, fd: c_int, error: *mut *mut glib::GError) -> c_int;
    pub fn g_unix_fd_list_get(list: *mut GUnixFDList, index_: c_int, error: *mut *mut glib::GError) -> c_int;
    pub fn g_unix_fd_list_get_length(list: *mut GUnixFDList) -> c_int;
    pub fn g_unix_fd_list_peek_fds(list: *mut GUnixFDList, length: *mut c_int) -> *mut c_int;
    pub fn g_unix_fd_list_steal_fds(list: *mut GUnixFDList, length: *mut c_int) -> *mut c_int;

    //=========================================================================
    // GUnixFDMessage
    //=========================================================================
    pub fn g_unix_fd_message_get_type() -> GType;
    pub fn g_unix_fd_message_new() -> *mut GSocketControlMessage;
    pub fn g_unix_fd_message_new_with_fd_list(fd_list: *mut GUnixFDList) -> *mut GSocketControlMessage;
    pub fn g_unix_fd_message_append_fd(message: *mut GUnixFDMessage, fd: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_unix_fd_message_get_fd_list(message: *mut GUnixFDMessage) -> *mut GUnixFDList;
    pub fn g_unix_fd_message_steal_fds(message: *mut GUnixFDMessage, length: *mut c_int) -> *mut c_int;

    //=========================================================================
    // GUnixInputStream
    //=========================================================================
    pub fn g_unix_input_stream_get_type() -> GType;
    pub fn g_unix_input_stream_new(fd: c_int, close_fd: gboolean) -> *mut GInputStream;
    pub fn g_unix_input_stream_get_close_fd(stream: *mut GUnixInputStream) -> gboolean;
    pub fn g_unix_input_stream_get_fd(stream: *mut GUnixInputStream) -> c_int;
    pub fn g_unix_input_stream_set_close_fd(stream: *mut GUnixInputStream, close_fd: gboolean);

    //=========================================================================
    // GUnixMountMonitor
    //=========================================================================
    pub fn g_unix_mount_monitor_get_type() -> GType;
    pub fn g_unix_mount_monitor_new() -> *mut GUnixMountMonitor;
    #[cfg(feature = "v2_44")]
    pub fn g_unix_mount_monitor_get() -> *mut GUnixMountMonitor;
    pub fn g_unix_mount_monitor_set_rate_limit(mount_monitor: *mut GUnixMountMonitor, limit_msec: c_int);

    //=========================================================================
    // GUnixOutputStream
    //=========================================================================
    pub fn g_unix_output_stream_get_type() -> GType;
    pub fn g_unix_output_stream_new(fd: c_int, close_fd: gboolean) -> *mut GOutputStream;
    pub fn g_unix_output_stream_get_close_fd(stream: *mut GUnixOutputStream) -> gboolean;
    pub fn g_unix_output_stream_get_fd(stream: *mut GUnixOutputStream) -> c_int;
    pub fn g_unix_output_stream_set_close_fd(stream: *mut GUnixOutputStream, close_fd: gboolean);

    //=========================================================================
    // GUnixSocketAddress
    //=========================================================================
    pub fn g_unix_socket_address_get_type() -> GType;
    pub fn g_unix_socket_address_new(path: *const c_char) -> *mut GSocketAddress;
    pub fn g_unix_socket_address_new_abstract(path: *mut c_char, path_len: c_int) -> *mut GSocketAddress;
    pub fn g_unix_socket_address_new_with_type(path: *mut c_char, path_len: c_int, type_: GUnixSocketAddressType) -> *mut GSocketAddress;
    pub fn g_unix_socket_address_abstract_names_supported() -> gboolean;
    pub fn g_unix_socket_address_get_address_type(address: *mut GUnixSocketAddress) -> GUnixSocketAddressType;
    pub fn g_unix_socket_address_get_is_abstract(address: *mut GUnixSocketAddress) -> gboolean;
    pub fn g_unix_socket_address_get_path(address: *mut GUnixSocketAddress) -> *const c_char;
    pub fn g_unix_socket_address_get_path_len(address: *mut GUnixSocketAddress) -> size_t;

    //=========================================================================
    // GVfs
    //=========================================================================
    pub fn g_vfs_get_type() -> GType;
    pub fn g_vfs_get_default() -> *mut GVfs;
    pub fn g_vfs_get_local() -> *mut GVfs;
    pub fn g_vfs_get_file_for_path(vfs: *mut GVfs, path: *const c_char) -> *mut GFile;
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const c_char) -> *mut GFile;
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const c_char;
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
    pub fn g_vfs_parse_name(vfs: *mut GVfs, parse_name: *const c_char) -> *mut GFile;
    #[cfg(feature = "v2_50")]
    pub fn g_vfs_register_uri_scheme(vfs: *mut GVfs, scheme: *const c_char, uri_func: GVfsFileLookupFunc, uri_data: gpointer, uri_destroy: glib::GDestroyNotify, parse_name_func: GVfsFileLookupFunc, parse_name_data: gpointer, parse_name_destroy: glib::GDestroyNotify) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_vfs_unregister_uri_scheme(vfs: *mut GVfs, scheme: *const c_char) -> gboolean;

    //=========================================================================
    // GVolumeMonitor
    //=========================================================================
    pub fn g_volume_monitor_get_type() -> GType;
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;
    pub fn g_volume_monitor_get_mount_for_uuid(volume_monitor: *mut GVolumeMonitor, uuid: *const c_char) -> *mut GMount;
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;
    pub fn g_volume_monitor_get_volume_for_uuid(volume_monitor: *mut GVolumeMonitor, uuid: *const c_char) -> *mut GVolume;
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;

    //=========================================================================
    // GZlibCompressor
    //=========================================================================
    pub fn g_zlib_compressor_get_type() -> GType;
    pub fn g_zlib_compressor_new(format: GZlibCompressorFormat, level: c_int) -> *mut GZlibCompressor;
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
    pub fn g_zlib_compressor_set_file_info(compressor: *mut GZlibCompressor, file_info: *mut GFileInfo);

    //=========================================================================
    // GZlibDecompressor
    //=========================================================================
    pub fn g_zlib_decompressor_get_type() -> GType;
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
    pub fn g_zlib_decompressor_get_file_info(decompressor: *mut GZlibDecompressor) -> *mut GFileInfo;

    //=========================================================================
    // GAction
    //=========================================================================
    pub fn g_action_get_type() -> GType;
    #[cfg(feature = "v2_38")]
    pub fn g_action_name_is_valid(action_name: *const c_char) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_action_parse_detailed_name(detailed_name: *const c_char, action_name: *mut *mut c_char, target_value: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_action_print_detailed_name(action_name: *const c_char, target_value: *mut glib::GVariant) -> *mut c_char;
    pub fn g_action_activate(action: *mut GAction, parameter: *mut glib::GVariant);
    pub fn g_action_change_state(action: *mut GAction, value: *mut glib::GVariant);
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
    pub fn g_action_get_name(action: *mut GAction) -> *const c_char;
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const glib::GVariantType;
    pub fn g_action_get_state(action: *mut GAction) -> *mut glib::GVariant;
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut glib::GVariant;
    pub fn g_action_get_state_type(action: *mut GAction) -> *const glib::GVariantType;

    //=========================================================================
    // GActionGroup
    //=========================================================================
    pub fn g_action_group_get_type() -> GType;
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const c_char);
    pub fn g_action_group_action_enabled_changed(action_group: *mut GActionGroup, action_name: *const c_char, enabled: gboolean);
    pub fn g_action_group_action_removed(action_group: *mut GActionGroup, action_name: *const c_char);
    pub fn g_action_group_action_state_changed(action_group: *mut GActionGroup, action_name: *const c_char, state: *mut glib::GVariant);
    pub fn g_action_group_activate_action(action_group: *mut GActionGroup, action_name: *const c_char, parameter: *mut glib::GVariant);
    pub fn g_action_group_change_action_state(action_group: *mut GActionGroup, action_name: *const c_char, value: *mut glib::GVariant);
    pub fn g_action_group_get_action_enabled(action_group: *mut GActionGroup, action_name: *const c_char) -> gboolean;
    pub fn g_action_group_get_action_parameter_type(action_group: *mut GActionGroup, action_name: *const c_char) -> *const glib::GVariantType;
    pub fn g_action_group_get_action_state(action_group: *mut GActionGroup, action_name: *const c_char) -> *mut glib::GVariant;
    pub fn g_action_group_get_action_state_hint(action_group: *mut GActionGroup, action_name: *const c_char) -> *mut glib::GVariant;
    pub fn g_action_group_get_action_state_type(action_group: *mut GActionGroup, action_name: *const c_char) -> *const glib::GVariantType;
    pub fn g_action_group_has_action(action_group: *mut GActionGroup, action_name: *const c_char) -> gboolean;
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut c_char;
    pub fn g_action_group_query_action(action_group: *mut GActionGroup, action_name: *const c_char, enabled: *mut gboolean, parameter_type: *mut *const glib::GVariantType, state_type: *mut *const glib::GVariantType, state_hint: *mut *mut glib::GVariant, state: *mut *mut glib::GVariant) -> gboolean;

    //=========================================================================
    // GActionMap
    //=========================================================================
    pub fn g_action_map_get_type() -> GType;
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
    pub fn g_action_map_add_action_entries(action_map: *mut GActionMap, entries: *mut GActionEntry, n_entries: c_int, user_data: gpointer);
    pub fn g_action_map_lookup_action(action_map: *mut GActionMap, action_name: *const c_char) -> *mut GAction;
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const c_char);

    //=========================================================================
    // GAppInfo
    //=========================================================================
    pub fn g_app_info_get_type() -> GType;
    pub fn g_app_info_create_from_commandline(commandline: *const c_char, application_name: *const c_char, flags: GAppInfoCreateFlags, error: *mut *mut glib::GError) -> *mut GAppInfo;
    pub fn g_app_info_get_all() -> *mut glib::GList;
    pub fn g_app_info_get_all_for_type(content_type: *const c_char) -> *mut glib::GList;
    pub fn g_app_info_get_default_for_type(content_type: *const c_char, must_support_uris: gboolean) -> *mut GAppInfo;
    pub fn g_app_info_get_default_for_uri_scheme(uri_scheme: *const c_char) -> *mut GAppInfo;
    pub fn g_app_info_get_fallback_for_type(content_type: *const c_char) -> *mut glib::GList;
    pub fn g_app_info_get_recommended_for_type(content_type: *const c_char) -> *mut glib::GList;
    pub fn g_app_info_launch_default_for_uri(uri: *const c_char, launch_context: *mut GAppLaunchContext, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_app_info_launch_default_for_uri_async(uri: *const c_char, launch_context: *mut GAppLaunchContext, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_50")]
    pub fn g_app_info_launch_default_for_uri_finish(result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_reset_type_associations(content_type: *const c_char);
    pub fn g_app_info_add_supports_type(appinfo: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *mut c_char;
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const c_char;
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const c_char;
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *mut c_char;
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const c_char;
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_app_info_get_supported_types(appinfo: *mut GAppInfo) -> *mut *mut c_char;
    pub fn g_app_info_launch(appinfo: *mut GAppInfo, files: *mut glib::GList, launch_context: *mut GAppLaunchContext, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_launch_uris(appinfo: *mut GAppInfo, uris: *mut glib::GList, launch_context: *mut GAppLaunchContext, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_remove_supports_type(appinfo: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_set_as_default_for_extension(appinfo: *mut GAppInfo, extension: *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_set_as_default_for_type(appinfo: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_set_as_last_used_for_type(appinfo: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;

    //=========================================================================
    // GAsyncInitable
    //=========================================================================
    pub fn g_async_initable_get_type() -> GType;
    pub fn g_async_initable_new_async(object_type: GType, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer, first_property_name: *const c_char, ...);
    //pub fn g_async_initable_new_valist_async(object_type: GType, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_async_initable_newv_async(object_type: GType, n_parameters: c_uint, parameters: *mut gobject::GParameter, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_async_initable_init_async(initable: *mut GAsyncInitable, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_async_initable_init_finish(initable: *mut GAsyncInitable, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_async_initable_new_finish(initable: *mut GAsyncInitable, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut gobject::GObject;

    //=========================================================================
    // GAsyncResult
    //=========================================================================
    pub fn g_async_result_get_type() -> GType;
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut gobject::GObject;
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
    #[cfg(feature = "v2_34")]
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_async_result_legacy_propagate_error(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GConverter
    //=========================================================================
    pub fn g_converter_get_type() -> GType;
    pub fn g_converter_convert(converter: *mut GConverter, inbuf: *mut u8, inbuf_size: size_t, outbuf: *mut u8, outbuf_size: size_t, flags: GConverterFlags, bytes_read: *mut size_t, bytes_written: *mut size_t, error: *mut *mut glib::GError) -> GConverterResult;
    pub fn g_converter_reset(converter: *mut GConverter);

    //=========================================================================
    // GDBusInterface
    //=========================================================================
    pub fn g_dbus_interface_get_type() -> GType;
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);

    //=========================================================================
    // GDBusObject
    //=========================================================================
    pub fn g_dbus_object_get_type() -> GType;
    pub fn g_dbus_object_get_interface(object: *mut GDBusObject, interface_name: *const c_char) -> *mut GDBusInterface;
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut glib::GList;
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const c_char;

    //=========================================================================
    // GDBusObjectManager
    //=========================================================================
    pub fn g_dbus_object_manager_get_type() -> GType;
    pub fn g_dbus_object_manager_get_interface(manager: *mut GDBusObjectManager, object_path: *const c_char, interface_name: *const c_char) -> *mut GDBusInterface;
    pub fn g_dbus_object_manager_get_object(manager: *mut GDBusObjectManager, object_path: *const c_char) -> *mut GDBusObject;
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const c_char;
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut glib::GList;

    //=========================================================================
    // GDatagramBased
    //=========================================================================
    pub fn g_datagram_based_get_type() -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_datagram_based_condition_check(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition) -> glib::GIOCondition;
    #[cfg(feature = "v2_48")]
    pub fn g_datagram_based_condition_wait(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition, timeout: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_datagram_based_create_source(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition, cancellable: *mut GCancellable) -> *mut glib::GSource;
    #[cfg(feature = "v2_48")]
    pub fn g_datagram_based_receive_messages(datagram_based: *mut GDatagramBased, messages: *mut GInputMessage, num_messages: c_uint, flags: c_int, timeout: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;
    #[cfg(feature = "v2_48")]
    pub fn g_datagram_based_send_messages(datagram_based: *mut GDatagramBased, messages: *mut GOutputMessage, num_messages: c_uint, flags: c_int, timeout: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> c_int;

    //=========================================================================
    // GDesktopAppInfoLookup
    //=========================================================================
    pub fn g_desktop_app_info_lookup_get_type() -> GType;
    pub fn g_desktop_app_info_lookup_get_default_for_uri_scheme(lookup: *mut GDesktopAppInfoLookup, uri_scheme: *const c_char) -> *mut GAppInfo;

    //=========================================================================
    // GDrive
    //=========================================================================
    pub fn g_drive_get_type() -> GType;
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_eject(drive: *mut GDrive, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_eject_finish(drive: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_drive_eject_with_operation(drive: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_eject_with_operation_finish(drive: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut c_char;
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_get_identifier(drive: *mut GDrive, kind: *const c_char) -> *mut c_char;
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut c_char;
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const c_char;
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
    #[cfg(feature = "v2_34")]
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut glib::GList;
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn g_drive_is_removable(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_poll_for_media(drive: *mut GDrive, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_poll_for_media_finish(drive: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_drive_start(drive: *mut GDrive, flags: GDriveStartFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_start_finish(drive: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_drive_stop(drive: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_stop_finish(drive: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GDtlsClientConnection
    //=========================================================================
    pub fn g_dtls_client_connection_get_type() -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_new(base_socket: *mut GDatagramBased, server_identity: *mut GSocketConnectable, error: *mut *mut glib::GError) -> *mut GDtlsClientConnection;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_get_accepted_cas(conn: *mut GDtlsClientConnection) -> *mut glib::GList;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_get_server_identity(conn: *mut GDtlsClientConnection) -> *mut GSocketConnectable;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_get_validation_flags(conn: *mut GDtlsClientConnection) -> GTlsCertificateFlags;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_set_server_identity(conn: *mut GDtlsClientConnection, identity: *mut GSocketConnectable);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_client_connection_set_validation_flags(conn: *mut GDtlsClientConnection, flags: GTlsCertificateFlags);

    //=========================================================================
    // GDtlsConnection
    //=========================================================================
    pub fn g_dtls_connection_get_type() -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_close(conn: *mut GDtlsConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_close_async(conn: *mut GDtlsConnection, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_close_finish(conn: *mut GDtlsConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_emit_accept_certificate(conn: *mut GDtlsConnection, peer_cert: *mut GTlsCertificate, errors: GTlsCertificateFlags) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_database(conn: *mut GDtlsConnection) -> *mut GTlsDatabase;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_interaction(conn: *mut GDtlsConnection) -> *mut GTlsInteraction;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_peer_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_peer_certificate_errors(conn: *mut GDtlsConnection) -> GTlsCertificateFlags;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_rehandshake_mode(conn: *mut GDtlsConnection) -> GTlsRehandshakeMode;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_get_require_close_notify(conn: *mut GDtlsConnection) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_handshake(conn: *mut GDtlsConnection, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_handshake_async(conn: *mut GDtlsConnection, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_handshake_finish(conn: *mut GDtlsConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_set_certificate(conn: *mut GDtlsConnection, certificate: *mut GTlsCertificate);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_set_database(conn: *mut GDtlsConnection, database: *mut GTlsDatabase);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_set_interaction(conn: *mut GDtlsConnection, interaction: *mut GTlsInteraction);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_set_rehandshake_mode(conn: *mut GDtlsConnection, mode: GTlsRehandshakeMode);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_set_require_close_notify(conn: *mut GDtlsConnection, require_close_notify: gboolean);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_shutdown(conn: *mut GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_shutdown_async(conn: *mut GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_connection_shutdown_finish(conn: *mut GDtlsConnection, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GDtlsServerConnection
    //=========================================================================
    pub fn g_dtls_server_connection_get_type() -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_dtls_server_connection_new(base_socket: *mut GDatagramBased, certificate: *mut GTlsCertificate, error: *mut *mut glib::GError) -> *mut GDtlsServerConnection;

    //=========================================================================
    // GFile
    //=========================================================================
    pub fn g_file_get_type() -> GType;
    pub fn g_file_new_for_commandline_arg(arg: *const c_char) -> *mut GFile;
    #[cfg(feature = "v2_36")]
    pub fn g_file_new_for_commandline_arg_and_cwd(arg: *const c_char, cwd: *mut c_char) -> *mut GFile;
    pub fn g_file_new_for_path(path: *mut c_char) -> *mut GFile;
    pub fn g_file_new_for_uri(uri: *const c_char) -> *mut GFile;
    pub fn g_file_new_tmp(tmpl: *mut c_char, iostream: *mut *mut GFileIOStream, error: *mut *mut glib::GError) -> *mut GFile;
    pub fn g_file_parse_name(parse_name: *const c_char) -> *mut GFile;
    pub fn g_file_append_to(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_append_to_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_append_to_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_copy(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_copy_async(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, io_priority: c_int, cancellable: *mut GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_copy_attributes(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_copy_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_create(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_create_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_create_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_create_readwrite(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_create_readwrite_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_create_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_delete(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_file_delete_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_34")]
    pub fn g_file_delete_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
    pub fn g_file_eject_mountable(file: *mut GFile, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_eject_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_eject_mountable_with_operation(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_eject_mountable_with_operation_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_enumerate_children(file: *mut GFile, attributes: *const c_char, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileEnumerator;
    pub fn g_file_enumerate_children_async(file: *mut GFile, attributes: *const c_char, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_enumerate_children_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileEnumerator;
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
    pub fn g_file_find_enclosing_mount(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GMount;
    pub fn g_file_find_enclosing_mount_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_find_enclosing_mount_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GMount;
    pub fn g_file_get_basename(file: *mut GFile) -> *mut c_char;
    pub fn g_file_get_child(file: *mut GFile, name: *mut c_char) -> *mut GFile;
    pub fn g_file_get_child_for_display_name(file: *mut GFile, display_name: *const c_char, error: *mut *mut glib::GError) -> *mut GFile;
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut c_char;
    pub fn g_file_get_path(file: *mut GFile) -> *mut c_char;
    pub fn g_file_get_relative_path(parent: *mut GFile, descendant: *mut GFile) -> *mut c_char;
    pub fn g_file_get_uri(file: *mut GFile) -> *mut c_char;
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut c_char;
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
    pub fn g_file_has_uri_scheme(file: *mut GFile, uri_scheme: *const c_char) -> gboolean;
    pub fn g_file_hash(file: gconstpointer) -> c_uint;
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
    pub fn g_file_load_contents(file: *mut GFile, cancellable: *mut GCancellable, contents: *mut *mut u8, length: *mut size_t, etag_out: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_load_contents_async(file: *mut GFile, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_load_contents_finish(file: *mut GFile, res: *mut GAsyncResult, contents: *mut *mut u8, length: *mut size_t, etag_out: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_load_partial_contents_async(file: *mut GFile, cancellable: *mut GCancellable, read_more_callback: GFileReadMoreCallback, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_load_partial_contents_finish(file: *mut GFile, res: *mut GAsyncResult, contents: *mut *mut u8, length: *mut size_t, etag_out: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_make_directory(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_file_make_directory_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_38")]
    pub fn g_file_make_directory_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_make_directory_with_parents(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_make_symbolic_link(file: *mut GFile, symlink_value: *mut c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_file_measure_disk_usage(file: *mut GFile, flags: GFileMeasureFlags, cancellable: *mut GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, disk_usage: *mut u64, num_dirs: *mut u64, num_files: *mut u64, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_file_measure_disk_usage_async(file: *mut GFile, flags: GFileMeasureFlags, io_priority: c_int, cancellable: *mut GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_38")]
    pub fn g_file_measure_disk_usage_finish(file: *mut GFile, result: *mut GAsyncResult, disk_usage: *mut u64, num_dirs: *mut u64, num_files: *mut u64, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_monitor(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileMonitor;
    pub fn g_file_monitor_directory(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileMonitor;
    pub fn g_file_monitor_file(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileMonitor;
    pub fn g_file_mount_enclosing_volume(location: *mut GFile, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_mount_enclosing_volume_finish(location: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_mount_mountable(file: *mut GFile, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_mount_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFile;
    pub fn g_file_move(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_open_readwrite(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_open_readwrite_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_open_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_poll_mountable(file: *mut GFile, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_poll_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_query_default_handler(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GAppInfo;
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_query_file_type(file: *mut GFile, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> GFileType;
    pub fn g_file_query_filesystem_info(file: *mut GFile, attributes: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_query_filesystem_info_async(file: *mut GFile, attributes: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_query_filesystem_info_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_query_info(file: *mut GFile, attributes: *const c_char, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_query_info_async(file: *mut GFile, attributes: *const c_char, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_query_info_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInfo;
    pub fn g_file_query_settable_attributes(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileAttributeInfoList;
    pub fn g_file_query_writable_namespaces(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileAttributeInfoList;
    pub fn g_file_read(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileInputStream;
    pub fn g_file_read_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_read_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileInputStream;
    pub fn g_file_replace(file: *mut GFile, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_replace_async(file: *mut GFile, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_replace_contents(file: *mut GFile, contents: *mut u8, length: size_t, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, new_etag: *mut *mut c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_replace_contents_async(file: *mut GFile, contents: *mut u8, length: size_t, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_40")]
    pub fn g_file_replace_contents_bytes_async(file: *mut GFile, contents: *mut glib::GBytes, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_replace_contents_finish(file: *mut GFile, res: *mut GAsyncResult, new_etag: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_replace_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileOutputStream;
    pub fn g_file_replace_readwrite(file: *mut GFile, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_replace_readwrite_async(file: *mut GFile, etag: *const c_char, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_replace_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFileIOStream;
    pub fn g_file_resolve_relative_path(file: *mut GFile, relative_path: *mut c_char) -> *mut GFile;
    pub fn g_file_set_attribute(file: *mut GFile, attribute: *const c_char, type_: GFileAttributeType, value_p: gpointer, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_byte_string(file: *mut GFile, attribute: *const c_char, value: *const c_char, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_int32(file: *mut GFile, attribute: *const c_char, value: i32, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_int64(file: *mut GFile, attribute: *const c_char, value: i64, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_string(file: *mut GFile, attribute: *const c_char, value: *const c_char, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_uint32(file: *mut GFile, attribute: *const c_char, value: u32, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attribute_uint64(file: *mut GFile, attribute: *const c_char, value: u64, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attributes_async(file: *mut GFile, info: *mut GFileInfo, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_set_attributes_finish(file: *mut GFile, result: *mut GAsyncResult, info: *mut *mut GFileInfo, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_attributes_from_info(file: *mut GFile, info: *mut GFileInfo, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_set_display_name(file: *mut GFile, display_name: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GFile;
    pub fn g_file_set_display_name_async(file: *mut GFile, display_name: *const c_char, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_set_display_name_finish(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GFile;
    pub fn g_file_start_mountable(file: *mut GFile, flags: GDriveStartFlags, start_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_start_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_stop_mountable(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_stop_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
    pub fn g_file_trash(file: *mut GFile, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_file_trash_async(file: *mut GFile, io_priority: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_38")]
    pub fn g_file_trash_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_unmount_mountable(file: *mut GFile, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_unmount_mountable_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_file_unmount_mountable_with_operation(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_file_unmount_mountable_with_operation_finish(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GFileDescriptorBased
    //=========================================================================
    pub fn g_file_descriptor_based_get_type() -> GType;
    pub fn g_file_descriptor_based_get_fd(fd_based: *mut GFileDescriptorBased) -> c_int;

    //=========================================================================
    // GIcon
    //=========================================================================
    pub fn g_icon_get_type() -> GType;
    #[cfg(feature = "v2_38")]
    pub fn g_icon_deserialize(value: *mut glib::GVariant) -> *mut GIcon;
    pub fn g_icon_hash(icon: gconstpointer) -> c_uint;
    pub fn g_icon_new_for_string(str: *const c_char, error: *mut *mut glib::GError) -> *mut GIcon;
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
    #[cfg(feature = "v2_38")]
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut glib::GVariant;
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut c_char;

    //=========================================================================
    // GInitable
    //=========================================================================
    pub fn g_initable_get_type() -> GType;
    pub fn g_initable_new(object_type: GType, cancellable: *mut GCancellable, error: *mut *mut glib::GError, first_property_name: *const c_char, ...) -> *mut gobject::GObject;
    //pub fn g_initable_new_valist(object_type: GType, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut gobject::GObject;
    pub fn g_initable_newv(object_type: GType, n_parameters: c_uint, parameters: *mut gobject::GParameter, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut gobject::GObject;
    pub fn g_initable_init(initable: *mut GInitable, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GListModel
    //=========================================================================
    pub fn g_list_model_get_type() -> GType;
    #[cfg(feature = "v2_44")]
    pub fn g_list_model_get_item(list: *mut GListModel, position: c_uint) -> *mut gobject::GObject;
    #[cfg(feature = "v2_44")]
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
    #[cfg(feature = "v2_44")]
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> c_uint;
    #[cfg(feature = "v2_44")]
    pub fn g_list_model_get_object(list: *mut GListModel, position: c_uint) -> *mut gobject::GObject;
    #[cfg(feature = "v2_44")]
    pub fn g_list_model_items_changed(list: *mut GListModel, position: c_uint, removed: c_uint, added: c_uint);

    //=========================================================================
    // GLoadableIcon
    //=========================================================================
    pub fn g_loadable_icon_get_type() -> GType;
    pub fn g_loadable_icon_load(icon: *mut GLoadableIcon, size: c_int, type_: *mut *mut c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GInputStream;
    pub fn g_loadable_icon_load_async(icon: *mut GLoadableIcon, size: c_int, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_loadable_icon_load_finish(icon: *mut GLoadableIcon, res: *mut GAsyncResult, type_: *mut *mut c_char, error: *mut *mut glib::GError) -> *mut GInputStream;

    //=========================================================================
    // GMount
    //=========================================================================
    pub fn g_mount_get_type() -> GType;
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
    pub fn g_mount_eject(mount: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_eject_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mount_eject_with_operation(mount: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_eject_with_operation_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut c_char;
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut c_char;
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
    pub fn g_mount_guess_content_type(mount: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_guess_content_type_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut *mut c_char;
    pub fn g_mount_guess_content_type_sync(mount: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut *mut c_char;
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
    pub fn g_mount_remount(mount: *mut GMount, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_remount_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mount_shadow(mount: *mut GMount);
    pub fn g_mount_unmount(mount: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_unmount_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mount_unmount_with_operation(mount: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_unmount_with_operation_finish(mount: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mount_unshadow(mount: *mut GMount);

    //=========================================================================
    // GNetworkMonitor
    //=========================================================================
    pub fn g_network_monitor_get_type() -> GType;
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
    pub fn g_network_monitor_can_reach(monitor: *mut GNetworkMonitor, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_network_monitor_can_reach_async(monitor: *mut GNetworkMonitor, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_network_monitor_can_reach_finish(monitor: *mut GNetworkMonitor, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn g_network_monitor_get_connectivity(monitor: *mut GNetworkMonitor) -> GNetworkConnectivity;
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
    #[cfg(feature = "v2_46")]
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;

    //=========================================================================
    // GPollableInputStream
    //=========================================================================
    pub fn g_pollable_input_stream_get_type() -> GType;
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
    pub fn g_pollable_input_stream_create_source(stream: *mut GPollableInputStream, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
    pub fn g_pollable_input_stream_read_nonblocking(stream: *mut GPollableInputStream, buffer: *mut u8, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;

    //=========================================================================
    // GPollableOutputStream
    //=========================================================================
    pub fn g_pollable_output_stream_get_type() -> GType;
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
    pub fn g_pollable_output_stream_create_source(stream: *mut GPollableOutputStream, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
    pub fn g_pollable_output_stream_write_nonblocking(stream: *mut GPollableOutputStream, buffer: *mut u8, count: size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;

    //=========================================================================
    // GProxy
    //=========================================================================
    pub fn g_proxy_get_type() -> GType;
    pub fn g_proxy_get_default_for_protocol(protocol: *const c_char) -> *mut GProxy;
    pub fn g_proxy_connect(proxy: *mut GProxy, connection: *mut GIOStream, proxy_address: *mut GProxyAddress, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GIOStream;
    pub fn g_proxy_connect_async(proxy: *mut GProxy, connection: *mut GIOStream, proxy_address: *mut GProxyAddress, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_proxy_connect_finish(proxy: *mut GProxy, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GIOStream;
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;

    //=========================================================================
    // GProxyResolver
    //=========================================================================
    pub fn g_proxy_resolver_get_type() -> GType;
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
    pub fn g_proxy_resolver_lookup(resolver: *mut GProxyResolver, uri: *const c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut *mut c_char;
    pub fn g_proxy_resolver_lookup_async(resolver: *mut GProxyResolver, uri: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_proxy_resolver_lookup_finish(resolver: *mut GProxyResolver, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut *mut c_char;

    //=========================================================================
    // GRemoteActionGroup
    //=========================================================================
    pub fn g_remote_action_group_get_type() -> GType;
    pub fn g_remote_action_group_activate_action_full(remote: *mut GRemoteActionGroup, action_name: *const c_char, parameter: *mut glib::GVariant, platform_data: *mut glib::GVariant);
    pub fn g_remote_action_group_change_action_state_full(remote: *mut GRemoteActionGroup, action_name: *const c_char, value: *mut glib::GVariant, platform_data: *mut glib::GVariant);

    //=========================================================================
    // GSeekable
    //=========================================================================
    pub fn g_seekable_get_type() -> GType;
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_seek(seekable: *mut GSeekable, offset: i64, type_: glib::GSeekType, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> i64;
    pub fn g_seekable_truncate(seekable: *mut GSeekable, offset: i64, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GSocketConnectable
    //=========================================================================
    pub fn g_socket_connectable_get_type() -> GType;
    pub fn g_socket_connectable_enumerate(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator;
    pub fn g_socket_connectable_proxy_enumerate(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator;
    #[cfg(feature = "v2_48")]
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut c_char;

    //=========================================================================
    // GTlsBackend
    //=========================================================================
    pub fn g_tls_backend_get_type() -> GType;
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
    #[cfg(feature = "v2_48")]
    pub fn g_tls_backend_get_dtls_client_connection_type(backend: *mut GTlsBackend) -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_tls_backend_get_dtls_server_connection_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
    #[cfg(feature = "v2_48")]
    pub fn g_tls_backend_supports_dtls(backend: *mut GTlsBackend) -> gboolean;
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;

    //=========================================================================
    // GTlsClientConnection
    //=========================================================================
    pub fn g_tls_client_connection_get_type() -> GType;
    pub fn g_tls_client_connection_new(base_io_stream: *mut GIOStream, server_identity: *mut GSocketConnectable, error: *mut *mut glib::GError) -> *mut GTlsClientConnection;
    #[cfg(feature = "v2_46")]
    pub fn g_tls_client_connection_copy_session_state(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection);
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut glib::GList;
    pub fn g_tls_client_connection_get_server_identity(conn: *mut GTlsClientConnection) -> *mut GSocketConnectable;
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
    pub fn g_tls_client_connection_get_validation_flags(conn: *mut GTlsClientConnection) -> GTlsCertificateFlags;
    pub fn g_tls_client_connection_set_server_identity(conn: *mut GTlsClientConnection, identity: *mut GSocketConnectable);
    pub fn g_tls_client_connection_set_use_ssl3(conn: *mut GTlsClientConnection, use_ssl3: gboolean);
    pub fn g_tls_client_connection_set_validation_flags(conn: *mut GTlsClientConnection, flags: GTlsCertificateFlags);

    //=========================================================================
    // GTlsFileDatabase
    //=========================================================================
    pub fn g_tls_file_database_get_type() -> GType;
    pub fn g_tls_file_database_new(anchors: *mut c_char, error: *mut *mut glib::GError) -> *mut GTlsFileDatabase;

    //=========================================================================
    // GTlsServerConnection
    //=========================================================================
    pub fn g_tls_server_connection_get_type() -> GType;
    pub fn g_tls_server_connection_new(base_io_stream: *mut GIOStream, certificate: *mut GTlsCertificate, error: *mut *mut glib::GError) -> *mut GTlsServerConnection;

    //=========================================================================
    // GVolume
    //=========================================================================
    pub fn g_volume_get_type() -> GType;
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_eject(volume: *mut GVolume, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_volume_eject_finish(volume: *mut GVolume, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_volume_eject_with_operation(volume: *mut GVolume, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_volume_eject_with_operation_finish(volume: *mut GVolume, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume) -> *mut *mut c_char;
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_identifier(volume: *mut GVolume, kind: *const c_char) -> *mut c_char;
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut c_char;
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut c_char;
    pub fn g_volume_mount(volume: *mut GVolume, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_volume_mount_finish(volume: *mut GVolume, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_bus_get(bus_type: GBusType, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_bus_get_finish(res: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_bus_get_sync(bus_type: GBusType, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GDBusConnection;
    pub fn g_bus_own_name(bus_type: GBusType, name: *const c_char, flags: GBusNameOwnerFlags, bus_acquired_handler: GBusAcquiredCallback, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_bus_own_name_on_connection(connection: *mut GDBusConnection, name: *const c_char, flags: GBusNameOwnerFlags, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_bus_own_name_on_connection_with_closures(connection: *mut GDBusConnection, name: *const c_char, flags: GBusNameOwnerFlags, name_acquired_closure: *mut gobject::GClosure, name_lost_closure: *mut gobject::GClosure) -> c_uint;
    pub fn g_bus_own_name_with_closures(bus_type: GBusType, name: *const c_char, flags: GBusNameOwnerFlags, bus_acquired_closure: *mut gobject::GClosure, name_acquired_closure: *mut gobject::GClosure, name_lost_closure: *mut gobject::GClosure) -> c_uint;
    pub fn g_bus_unown_name(owner_id: c_uint);
    pub fn g_bus_unwatch_name(watcher_id: c_uint);
    pub fn g_bus_watch_name(bus_type: GBusType, name: *const c_char, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_bus_watch_name_on_connection(connection: *mut GDBusConnection, name: *const c_char, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> c_uint;
    pub fn g_bus_watch_name_on_connection_with_closures(connection: *mut GDBusConnection, name: *const c_char, flags: GBusNameWatcherFlags, name_appeared_closure: *mut gobject::GClosure, name_vanished_closure: *mut gobject::GClosure) -> c_uint;
    pub fn g_bus_watch_name_with_closures(bus_type: GBusType, name: *const c_char, flags: GBusNameWatcherFlags, name_appeared_closure: *mut gobject::GClosure, name_vanished_closure: *mut gobject::GClosure) -> c_uint;
    pub fn g_content_type_can_be_executable(type_: *const c_char) -> gboolean;
    pub fn g_content_type_equals(type1: *const c_char, type2: *const c_char) -> gboolean;
    pub fn g_content_type_from_mime_type(mime_type: *const c_char) -> *mut c_char;
    pub fn g_content_type_get_description(type_: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_content_type_get_generic_icon_name(type_: *const c_char) -> *mut c_char;
    pub fn g_content_type_get_icon(type_: *const c_char) -> *mut GIcon;
    pub fn g_content_type_get_mime_type(type_: *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_34")]
    pub fn g_content_type_get_symbolic_icon(type_: *const c_char) -> *mut GIcon;
    pub fn g_content_type_guess(filename: *const c_char, data: *mut u8, data_size: size_t, result_uncertain: *mut gboolean) -> *mut c_char;
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut c_char;
    pub fn g_content_type_is_a(type_: *const c_char, supertype: *const c_char) -> gboolean;
    pub fn g_content_type_is_unknown(type_: *const c_char) -> gboolean;
    pub fn g_content_types_get_registered() -> *mut glib::GList;
    #[cfg(feature = "v2_36")]
    pub fn g_dbus_address_escape_value(string: *const c_char) -> *mut c_char;
    pub fn g_dbus_address_get_for_bus_sync(bus_type: GBusType, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn g_dbus_address_get_stream(address: *const c_char, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_dbus_address_get_stream_finish(res: *mut GAsyncResult, out_guid: *mut *mut c_char, error: *mut *mut glib::GError) -> *mut GIOStream;
    pub fn g_dbus_address_get_stream_sync(address: *const c_char, out_guid: *mut *mut c_char, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut GIOStream;
    pub fn g_dbus_generate_guid() -> *mut c_char;
    pub fn g_dbus_gvalue_to_gvariant(gvalue: *const gobject::GValue, type_: *const glib::GVariantType) -> *mut glib::GVariant;
    pub fn g_dbus_gvariant_to_gvalue(value: *mut glib::GVariant, out_gvalue: *mut gobject::GValue);
    pub fn g_dbus_is_address(string: *const c_char) -> gboolean;
    pub fn g_dbus_is_guid(string: *const c_char) -> gboolean;
    pub fn g_dbus_is_interface_name(string: *const c_char) -> gboolean;
    pub fn g_dbus_is_member_name(string: *const c_char) -> gboolean;
    pub fn g_dbus_is_name(string: *const c_char) -> gboolean;
    pub fn g_dbus_is_supported_address(string: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_dbus_is_unique_name(string: *const c_char) -> gboolean;
    pub fn g_io_error_from_errno(err_no: c_int) -> GIOErrorEnum;
    pub fn g_io_error_quark() -> glib::GQuark;
    pub fn g_io_modules_load_all_in_directory(dirname: *mut c_char) -> *mut glib::GList;
    pub fn g_io_modules_load_all_in_directory_with_scope(dirname: *mut c_char, scope: *mut GIOModuleScope) -> *mut glib::GList;
    pub fn g_io_modules_scan_all_in_directory(dirname: *mut c_char);
    pub fn g_io_modules_scan_all_in_directory_with_scope(dirname: *mut c_char, scope: *mut GIOModuleScope);
    pub fn g_io_scheduler_cancel_all_jobs();
    pub fn g_io_scheduler_push_job(job_func: GIOSchedulerJobFunc, user_data: gpointer, notify: glib::GDestroyNotify, io_priority: c_int, cancellable: *mut GCancellable);
    #[cfg(feature = "v2_36")]
    pub fn g_networking_init();
    pub fn g_pollable_source_new(pollable_stream: *mut gobject::GObject) -> *mut glib::GSource;
    #[cfg(feature = "v2_34")]
    pub fn g_pollable_source_new_full(pollable_stream: *mut gobject::GObject, child_source: *mut glib::GSource, cancellable: *mut GCancellable) -> *mut glib::GSource;
    #[cfg(feature = "v2_34")]
    pub fn g_pollable_stream_read(stream: *mut GInputStream, buffer: *mut u8, count: size_t, blocking: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    #[cfg(feature = "v2_34")]
    pub fn g_pollable_stream_write(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, blocking: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> ssize_t;
    #[cfg(feature = "v2_34")]
    pub fn g_pollable_stream_write_all(stream: *mut GOutputStream, buffer: *mut u8, count: size_t, blocking: gboolean, bytes_written: *mut size_t, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_resources_enumerate_children(path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut *mut c_char;
    pub fn g_resources_get_info(path: *const c_char, lookup_flags: GResourceLookupFlags, size: *mut size_t, flags: *mut u32, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_resources_lookup_data(path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut glib::GBytes;
    pub fn g_resources_open_stream(path: *const c_char, lookup_flags: GResourceLookupFlags, error: *mut *mut glib::GError) -> *mut GInputStream;
    pub fn g_resources_register(resource: *mut GResource);
    pub fn g_resources_unregister(resource: *mut GResource);
    pub fn g_simple_async_report_error_in_idle(object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: glib::GQuark, code: c_int, format: *const c_char, ...);
    pub fn g_simple_async_report_gerror_in_idle(object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, error: *const glib::GError);
    pub fn g_simple_async_report_take_gerror_in_idle(object: *mut gobject::GObject, callback: GAsyncReadyCallback, user_data: gpointer, error: *mut glib::GError);
    pub fn g_unix_is_mount_path_system_internal(mount_path: *mut c_char) -> gboolean;
    pub fn g_unix_mount_at(mount_path: *const c_char, time_read: *mut u64) -> *mut GUnixMountEntry;
    pub fn g_unix_mount_compare(mount1: *mut GUnixMountEntry, mount2: *mut GUnixMountEntry) -> c_int;
    pub fn g_unix_mount_free(mount_entry: *mut GUnixMountEntry);
    pub fn g_unix_mount_get_device_path(mount_entry: *mut GUnixMountEntry) -> *mut c_char;
    pub fn g_unix_mount_get_fs_type(mount_entry: *mut GUnixMountEntry) -> *const c_char;
    pub fn g_unix_mount_get_mount_path(mount_entry: *mut GUnixMountEntry) -> *mut c_char;
    pub fn g_unix_mount_guess_can_eject(mount_entry: *mut GUnixMountEntry) -> gboolean;
    pub fn g_unix_mount_guess_icon(mount_entry: *mut GUnixMountEntry) -> *mut GIcon;
    pub fn g_unix_mount_guess_name(mount_entry: *mut GUnixMountEntry) -> *mut c_char;
    pub fn g_unix_mount_guess_should_display(mount_entry: *mut GUnixMountEntry) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn g_unix_mount_guess_symbolic_icon(mount_entry: *mut GUnixMountEntry) -> *mut GIcon;
    pub fn g_unix_mount_is_readonly(mount_entry: *mut GUnixMountEntry) -> gboolean;
    pub fn g_unix_mount_is_system_internal(mount_entry: *mut GUnixMountEntry) -> gboolean;
    pub fn g_unix_mount_points_changed_since(time: u64) -> gboolean;
    pub fn g_unix_mount_points_get(time_read: *mut u64) -> *mut glib::GList;
    pub fn g_unix_mounts_changed_since(time: u64) -> gboolean;
    pub fn g_unix_mounts_get(time_read: *mut u64) -> *mut glib::GList;

}
