// This file was generated by gir (https://github.com/gtk-rs/gir @ 6704a1c)
// from gir-files (https://github.com/gtk-rs/gir-files @ 4740f5e)
// DO NOT EDIT

#[cfg(any(feature = "v2_34", feature = "dox"))]
use Bytes;
use ChecksumType;
use Error;
use FileTest;
use FormatSizeFlags;
use Source;
use UserDirectory;
use ffi;
use libc;
use std;
use std::mem;
use std::ptr;
use translate::*;
use types;


pub fn access<P: AsRef<std::path::Path>>(filename: P, mode: i32) -> i32 {
    unsafe {
        ffi::g_access(filename.as_ref().to_glib_none().0, mode)
    }
}

pub fn assert_warning(log_domain: &str, file: &str, line: i32, pretty_function: &str, expression: &str) {
    unsafe {
        ffi::g_assert_warning(log_domain.to_glib_none().0, file.to_glib_none().0, line, pretty_function.to_glib_none().0, expression.to_glib_none().0);
    }
}

pub fn assertion_message(domain: &str, file: &str, line: i32, func: &str, message: &str) {
    unsafe {
        ffi::g_assertion_message(domain.to_glib_none().0, file.to_glib_none().0, line, func.to_glib_none().0, message.to_glib_none().0);
    }
}

//pub fn assertion_message_cmpnum(domain: &str, file: &str, line: i32, func: &str, expr: &str, arg1: /*Unknown conversion*//*Unimplemented*/Unsupported, cmp: &str, arg2: /*Unknown conversion*//*Unimplemented*/Unsupported, numtype: Char) {
//    unsafe { TODO: call ffi::g_assertion_message_cmpnum() }
//}

pub fn assertion_message_cmpstr(domain: &str, file: &str, line: i32, func: &str, expr: &str, arg1: &str, cmp: &str, arg2: &str) {
    unsafe {
        ffi::g_assertion_message_cmpstr(domain.to_glib_none().0, file.to_glib_none().0, line, func.to_glib_none().0, expr.to_glib_none().0, arg1.to_glib_none().0, cmp.to_glib_none().0, arg2.to_glib_none().0);
    }
}

pub fn assertion_message_expr<'a, 'b, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>>(domain: P, file: &str, line: i32, func: &str, expr: Q) {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    let expr = expr.into();
    let expr = expr.to_glib_none();
    unsafe {
        ffi::g_assertion_message_expr(domain.0, file.to_glib_none().0, line, func.to_glib_none().0, expr.0);
    }
}

//#[deprecated]
//pub fn atexit(func: /*Unknown conversion*//*Unimplemented*/VoidFunc) {
//    unsafe { TODO: call ffi::g_atexit() }
//}

pub fn base64_decode(text: &str) -> Vec<u8> {
    unsafe {
        let mut out_len = mem::uninitialized();
        let ret = FromGlibContainer::from_glib_full_num(ffi::g_base64_decode(text.to_glib_none().0, &mut out_len), out_len as usize);
        ret
    }
}

//pub fn base64_decode_inplace(text: /*Unimplemented*/Vec<u8>) -> u8 {
//    unsafe { TODO: call ffi::g_base64_decode_inplace() }
//}

//pub fn base64_decode_step(in_: &[u8], out: Vec<u8>, state: &mut i32, save: &mut u32) -> usize {
//    unsafe { TODO: call ffi::g_base64_decode_step() }
//}

pub fn base64_encode(data: &[u8]) -> Option<String> {
    let len = data.len() as usize;
    unsafe {
        from_glib_full(ffi::g_base64_encode(data.to_glib_none().0, len))
    }
}

//pub fn base64_encode_close(break_lines: bool, out: Vec<u8>, state: &mut i32, save: &mut i32) -> usize {
//    unsafe { TODO: call ffi::g_base64_encode_close() }
//}

//pub fn base64_encode_step(in_: &[u8], break_lines: bool, out: Vec<u8>, state: &mut i32, save: &mut i32) -> usize {
//    unsafe { TODO: call ffi::g_base64_encode_step() }
//}

#[deprecated]
pub fn basename<P: AsRef<std::path::Path>>(file_name: P) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_basename(file_name.as_ref().to_glib_none().0))
    }
}

pub fn bit_nth_lsf(mask: libc::c_ulong, nth_bit: i32) -> i32 {
    unsafe {
        ffi::g_bit_nth_lsf(mask, nth_bit)
    }
}

pub fn bit_nth_msf(mask: libc::c_ulong, nth_bit: i32) -> i32 {
    unsafe {
        ffi::g_bit_nth_msf(mask, nth_bit)
    }
}

pub fn bit_storage(number: libc::c_ulong) -> u32 {
    unsafe {
        ffi::g_bit_storage(number)
    }
}

//pub fn build_filename<P: AsRef<std::path::Path>>(first_element: P, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<std::path::PathBuf> {
//    unsafe { TODO: call ffi::g_build_filename() }
//}

pub fn build_filenamev(args: &[&std::path::Path]) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_build_filenamev(args.to_glib_none().0))
    }
}

//pub fn build_path<P: AsRef<std::path::Path>, Q: AsRef<std::path::Path>>(separator: P, first_element: Q, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<std::path::PathBuf> {
//    unsafe { TODO: call ffi::g_build_path() }
//}

pub fn build_pathv(separator: &str, args: &[&std::path::Path]) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_build_pathv(separator.to_glib_none().0, args.to_glib_none().0))
    }
}

pub fn chdir<P: AsRef<std::path::Path>>(path: P) -> i32 {
    unsafe {
        ffi::g_chdir(path.as_ref().to_glib_none().0)
    }
}

pub fn check_version(required_major: u32, required_minor: u32, required_micro: u32) -> Option<String> {
    unsafe {
        from_glib_none(ffi::glib_check_version(required_major, required_minor, required_micro))
    }
}

//pub fn child_watch_add<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(pid: Pid, function: /*Unknown conversion*//*Unimplemented*/ChildWatchFunc, data: P) -> u32 {
//    unsafe { TODO: call ffi::g_child_watch_add() }
//}

//pub fn child_watch_add_full<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a /*Unimplemented*/DestroyNotify>>>(priority: i32, pid: Pid, function: /*Unknown conversion*//*Unimplemented*/ChildWatchFunc, data: P, notify: Q) -> u32 {
//    unsafe { TODO: call ffi::g_child_watch_add_full() }
//}

pub fn clear_error() -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_clear_error(&mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

//#[cfg(any(feature = "v2_34", feature = "dox"))]
//pub fn clear_pointer(pp: /*Unimplemented*/Fundamental: Pointer, destroy: /*Unknown conversion*//*Unimplemented*/DestroyNotify) {
//    unsafe { TODO: call ffi::g_clear_pointer() }
//}

#[cfg(any(feature = "v2_36", feature = "dox"))]
pub fn close(fd: i32) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_close(fd, &mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
pub fn compute_checksum_for_bytes(checksum_type: ChecksumType, data: &Bytes) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_compute_checksum_for_bytes(checksum_type.to_glib(), data.to_glib_none().0))
    }
}

pub fn compute_checksum_for_data(checksum_type: ChecksumType, data: &[u8]) -> Option<String> {
    let length = data.len() as usize;
    unsafe {
        from_glib_full(ffi::g_compute_checksum_for_data(checksum_type.to_glib(), data.to_glib_none().0, length))
    }
}

pub fn compute_checksum_for_string(checksum_type: ChecksumType, str: &str) -> Option<String> {
    let length = str.len() as isize;
    unsafe {
        from_glib_full(ffi::g_compute_checksum_for_string(checksum_type.to_glib(), str.to_glib_none().0, length))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
pub fn compute_hmac_for_bytes(digest_type: ChecksumType, key: &Bytes, data: &Bytes) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_compute_hmac_for_bytes(digest_type.to_glib(), key.to_glib_none().0, data.to_glib_none().0))
    }
}

pub fn compute_hmac_for_data(digest_type: ChecksumType, key: &[u8], data: &[u8]) -> Option<String> {
    let key_len = key.len() as usize;
    let length = data.len() as usize;
    unsafe {
        from_glib_full(ffi::g_compute_hmac_for_data(digest_type.to_glib(), key.to_glib_none().0, key_len, data.to_glib_none().0, length))
    }
}

pub fn compute_hmac_for_string(digest_type: ChecksumType, key: &[u8], str: &str) -> Option<String> {
    let key_len = key.len() as usize;
    let length = str.len() as isize;
    unsafe {
        from_glib_full(ffi::g_compute_hmac_for_string(digest_type.to_glib(), key.to_glib_none().0, key_len, str.to_glib_none().0, length))
    }
}

//pub fn convert_with_iconv(str: &str, converter: /*Ignored*/&IConv, bytes_read: usize, bytes_written: usize) -> Result<String, Error> {
//    unsafe { TODO: call ffi::g_convert_with_iconv() }
//}

//pub fn datalist_clear(datalist: /*Ignored*/&mut Data) {
//    unsafe { TODO: call ffi::g_datalist_clear() }
//}

//pub fn datalist_foreach<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(datalist: /*Ignored*/&mut Data, func: /*Unknown conversion*//*Unimplemented*/DataForeachFunc, user_data: P) {
//    unsafe { TODO: call ffi::g_datalist_foreach() }
//}

//pub fn datalist_get_data(datalist: /*Ignored*/&mut Data, key: &str) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_datalist_get_data() }
//}

//pub fn datalist_get_flags(datalist: /*Ignored*/&mut Data) -> u32 {
//    unsafe { TODO: call ffi::g_datalist_get_flags() }
//}

//#[cfg(any(feature = "v2_34", feature = "dox"))]
//pub fn datalist_id_dup_data<'a, P: Into<Option<&'a /*Unimplemented*/DuplicateFunc>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(datalist: /*Ignored*/&mut Data, key_id: Quark, dup_func: P, user_data: Q) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_datalist_id_dup_data() }
//}

//pub fn datalist_id_get_data(datalist: /*Ignored*/&mut Data, key_id: Quark) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_datalist_id_get_data() }
//}

//pub fn datalist_id_remove_no_notify(datalist: /*Ignored*/&mut Data, key_id: Quark) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_datalist_id_remove_no_notify() }
//}

//#[cfg(any(feature = "v2_34", feature = "dox"))]
//pub fn datalist_id_replace_data<'a, 'b, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>, R: Into<Option<&'a /*Unimplemented*/DestroyNotify>>, S: Into<Option<&'b /*Unimplemented*/DestroyNotify>>>(datalist: /*Ignored*/&mut Data, key_id: Quark, oldval: P, newval: Q, destroy: R, old_destroy: S) -> bool {
//    unsafe { TODO: call ffi::g_datalist_id_replace_data() }
//}

//pub fn datalist_id_set_data_full<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(datalist: /*Ignored*/&mut Data, key_id: Quark, data: P, destroy_func: /*Unknown conversion*//*Unimplemented*/DestroyNotify) {
//    unsafe { TODO: call ffi::g_datalist_id_set_data_full() }
//}

//pub fn datalist_init(datalist: /*Ignored*/&mut Data) {
//    unsafe { TODO: call ffi::g_datalist_init() }
//}

//pub fn datalist_set_flags(datalist: /*Ignored*/&mut Data, flags: u32) {
//    unsafe { TODO: call ffi::g_datalist_set_flags() }
//}

//pub fn datalist_unset_flags(datalist: /*Ignored*/&mut Data, flags: u32) {
//    unsafe { TODO: call ffi::g_datalist_unset_flags() }
//}

//pub fn dataset_destroy(dataset_location: /*Unimplemented*/Fundamental: Pointer) {
//    unsafe { TODO: call ffi::g_dataset_destroy() }
//}

//pub fn dataset_foreach<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(dataset_location: /*Unimplemented*/Fundamental: Pointer, func: /*Unknown conversion*//*Unimplemented*/DataForeachFunc, user_data: P) {
//    unsafe { TODO: call ffi::g_dataset_foreach() }
//}

//pub fn dataset_id_get_data(dataset_location: /*Unimplemented*/Fundamental: Pointer, key_id: Quark) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_dataset_id_get_data() }
//}

//pub fn dataset_id_remove_no_notify(dataset_location: /*Unimplemented*/Fundamental: Pointer, key_id: Quark) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_dataset_id_remove_no_notify() }
//}

//pub fn dataset_id_set_data_full<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(dataset_location: /*Unimplemented*/Fundamental: Pointer, key_id: Quark, data: P, destroy_func: /*Unknown conversion*//*Unimplemented*/DestroyNotify) {
//    unsafe { TODO: call ffi::g_dataset_id_set_data_full() }
//}

pub fn dcgettext<'a, P: Into<Option<&'a str>>>(domain: P, msgid: &str, category: i32) -> Option<String> {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_dcgettext(domain.0, msgid.to_glib_none().0, category))
    }
}

pub fn dgettext<'a, P: Into<Option<&'a str>>>(domain: P, msgid: &str) -> Option<String> {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_dgettext(domain.0, msgid.to_glib_none().0))
    }
}

//pub fn direct_equal<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(v1: P, v2: Q) -> bool {
//    unsafe { TODO: call ffi::g_direct_equal() }
//}

//pub fn direct_hash<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(v: P) -> u32 {
//    unsafe { TODO: call ffi::g_direct_hash() }
//}

pub fn dngettext<'a, P: Into<Option<&'a str>>>(domain: P, msgid: &str, msgid_plural: &str, n: libc::c_ulong) -> Option<String> {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_dngettext(domain.0, msgid.to_glib_none().0, msgid_plural.to_glib_none().0, n))
    }
}

//pub fn double_equal(v1: /*Unimplemented*/Fundamental: Pointer, v2: /*Unimplemented*/Fundamental: Pointer) -> bool {
//    unsafe { TODO: call ffi::g_double_equal() }
//}

//pub fn double_hash(v: /*Unimplemented*/Fundamental: Pointer) -> u32 {
//    unsafe { TODO: call ffi::g_double_hash() }
//}

pub fn dpgettext<'a, P: Into<Option<&'a str>>>(domain: P, msgctxtid: &str, msgidoffset: usize) -> Option<String> {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_dpgettext(domain.0, msgctxtid.to_glib_none().0, msgidoffset))
    }
}

pub fn dpgettext2<'a, P: Into<Option<&'a str>>>(domain: P, context: &str, msgid: &str) -> Option<String> {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_dpgettext2(domain.0, context.to_glib_none().0, msgid.to_glib_none().0))
    }
}

pub fn environ_getenv(envp: &[&str], variable: &str) -> Option<String> {
    unsafe {
        from_glib_none(ffi::g_environ_getenv(envp.to_glib_none().0, variable.to_glib_none().0))
    }
}

pub fn environ_setenv(envp: &[&str], variable: &str, value: &str, overwrite: bool) -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_environ_setenv(envp.to_glib_full(), variable.to_glib_none().0, value.to_glib_none().0, overwrite.to_glib()))
    }
}

pub fn environ_unsetenv(envp: &[&str], variable: &str) -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_environ_unsetenv(envp.to_glib_full(), variable.to_glib_none().0))
    }
}

//pub fn file_error_from_errno(err_no: i32) -> /*Ignored*/FileError {
//    unsafe { TODO: call ffi::g_file_error_from_errno() }
//}

pub fn file_get_contents<P: AsRef<std::path::Path>>(filename: P) -> Result<Vec<u8>, Error> {
    unsafe {
        let mut contents = ptr::null_mut();
        let mut length = mem::uninitialized();
        let mut error = ptr::null_mut();
        let _ = ffi::g_file_get_contents(filename.as_ref().to_glib_none().0, &mut contents, &mut length, &mut error);
        if error.is_null() { Ok(FromGlibContainer::from_glib_full_num(contents, length as usize)) } else { Err(from_glib_full(error)) }
    }
}

pub fn file_open_tmp<P: AsRef<std::path::Path>>(tmpl: P) -> Result<(i32, std::path::PathBuf), Error> {
    unsafe {
        let mut name_used = ptr::null_mut();
        let mut error = ptr::null_mut();
        let ret = ffi::g_file_open_tmp(tmpl.as_ref().to_glib_none().0, &mut name_used, &mut error);
        if error.is_null() { Ok((ret, from_glib_full(name_used))) } else { Err(from_glib_full(error)) }
    }
}

pub fn file_read_link<P: AsRef<std::path::Path>>(filename: P) -> Result<std::path::PathBuf, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::g_file_read_link(filename.as_ref().to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

pub fn file_set_contents<P: AsRef<std::path::Path>>(filename: P, contents: &[u8]) -> Result<(), Error> {
    let length = contents.len() as isize;
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_file_set_contents(filename.as_ref().to_glib_none().0, contents.to_glib_none().0, length, &mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

pub fn file_test<P: AsRef<std::path::Path>>(filename: P, test: FileTest) -> bool {
    unsafe {
        from_glib(ffi::g_file_test(filename.as_ref().to_glib_none().0, test.to_glib()))
    }
}

pub fn filename_display_basename<P: AsRef<std::path::Path>>(filename: P) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_filename_display_basename(filename.as_ref().to_glib_none().0))
    }
}

pub fn filename_display_name<P: AsRef<std::path::Path>>(filename: P) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_filename_display_name(filename.as_ref().to_glib_none().0))
    }
}

pub fn format_size(size: u64) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_format_size(size))
    }
}

#[deprecated]
pub fn format_size_for_display(size: i64) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_format_size_for_display(size))
    }
}

pub fn format_size_full(size: u64, flags: FormatSizeFlags) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_format_size_full(size, flags.to_glib()))
    }
}

//pub fn fprintf(file: /*Unimplemented*/Fundamental: Pointer, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> i32 {
//    unsafe { TODO: call ffi::g_fprintf() }
//}

//pub fn free<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P) {
//    unsafe { TODO: call ffi::g_free() }
//}

pub fn get_application_name() -> Option<String> {
    unsafe {
        from_glib_none(ffi::g_get_application_name())
    }
}

pub fn get_charset() -> Option<String> {
    unsafe {
        let mut charset = ptr::null();
        let ret = from_glib(ffi::g_get_charset(&mut charset));
        if ret { Some(from_glib_none(charset)) } else { None }
    }
}

pub fn get_codeset() -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_get_codeset())
    }
}

//pub fn get_current_time(result: /*Ignored*/&mut TimeVal) {
//    unsafe { TODO: call ffi::g_get_current_time() }
//}

pub fn get_environ() -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_get_environ())
    }
}

pub fn get_host_name() -> Option<String> {
    unsafe {
        from_glib_none(ffi::g_get_host_name())
    }
}

pub fn get_language_names() -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_none(ffi::g_get_language_names())
    }
}

pub fn get_locale_variants(locale: &str) -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_get_locale_variants(locale.to_glib_none().0))
    }
}

pub fn get_monotonic_time() -> i64 {
    unsafe {
        ffi::g_get_monotonic_time()
    }
}

#[cfg(any(feature = "v2_36", feature = "dox"))]
pub fn get_num_processors() -> u32 {
    unsafe {
        ffi::g_get_num_processors()
    }
}

pub fn get_real_time() -> i64 {
    unsafe {
        ffi::g_get_real_time()
    }
}

pub fn get_system_config_dirs() -> Vec<std::path::PathBuf> {
    unsafe {
        FromGlibPtrContainer::from_glib_none(ffi::g_get_system_config_dirs())
    }
}

pub fn get_system_data_dirs() -> Vec<std::path::PathBuf> {
    unsafe {
        FromGlibPtrContainer::from_glib_none(ffi::g_get_system_data_dirs())
    }
}

pub fn get_user_cache_dir() -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_get_user_cache_dir())
    }
}

pub fn get_user_config_dir() -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_get_user_config_dir())
    }
}

pub fn get_user_data_dir() -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_get_user_data_dir())
    }
}

pub fn get_user_runtime_dir() -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_get_user_runtime_dir())
    }
}

pub fn get_user_special_dir(directory: UserDirectory) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_get_user_special_dir(directory.to_glib()))
    }
}

pub fn hostname_is_ascii_encoded(hostname: &str) -> bool {
    unsafe {
        from_glib(ffi::g_hostname_is_ascii_encoded(hostname.to_glib_none().0))
    }
}

pub fn hostname_is_ip_address(hostname: &str) -> bool {
    unsafe {
        from_glib(ffi::g_hostname_is_ip_address(hostname.to_glib_none().0))
    }
}

pub fn hostname_is_non_ascii(hostname: &str) -> bool {
    unsafe {
        from_glib(ffi::g_hostname_is_non_ascii(hostname.to_glib_none().0))
    }
}

pub fn hostname_to_ascii(hostname: &str) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_hostname_to_ascii(hostname.to_glib_none().0))
    }
}

pub fn hostname_to_unicode(hostname: &str) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_hostname_to_unicode(hostname.to_glib_none().0))
    }
}

//pub fn iconv(converter: /*Ignored*/&IConv, inbuf: &str, inbytes_left: usize, outbuf: &str, outbytes_left: usize) -> usize {
//    unsafe { TODO: call ffi::g_iconv() }
//}

//pub fn idle_add<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P) -> u32 {
//    unsafe { TODO: call ffi::g_idle_add() }
//}

//pub fn idle_add_full<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a /*Unimplemented*/DestroyNotify>>>(priority: i32, function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P, notify: Q) -> u32 {
//    unsafe { TODO: call ffi::g_idle_add_full() }
//}

//pub fn idle_remove_by_data<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(data: P) -> bool {
//    unsafe { TODO: call ffi::g_idle_remove_by_data() }
//}

//pub fn int64_equal(v1: /*Unimplemented*/Fundamental: Pointer, v2: /*Unimplemented*/Fundamental: Pointer) -> bool {
//    unsafe { TODO: call ffi::g_int64_equal() }
//}

//pub fn int64_hash(v: /*Unimplemented*/Fundamental: Pointer) -> u32 {
//    unsafe { TODO: call ffi::g_int64_hash() }
//}

//pub fn int_equal(v1: /*Unimplemented*/Fundamental: Pointer, v2: /*Unimplemented*/Fundamental: Pointer) -> bool {
//    unsafe { TODO: call ffi::g_int_equal() }
//}

//pub fn int_hash(v: /*Unimplemented*/Fundamental: Pointer) -> u32 {
//    unsafe { TODO: call ffi::g_int_hash() }
//}

pub fn intern_static_string<'a, P: Into<Option<&'a str>>>(string: P) -> Option<String> {
    let string = string.into();
    let string = string.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_intern_static_string(string.0))
    }
}

pub fn intern_string<'a, P: Into<Option<&'a str>>>(string: P) -> Option<String> {
    let string = string.into();
    let string = string.to_glib_none();
    unsafe {
        from_glib_none(ffi::g_intern_string(string.0))
    }
}

//pub fn io_add_watch<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(channel: /*Ignored*/&IOChannel, condition: IOCondition, func: /*Unknown conversion*//*Unimplemented*/IOFunc, user_data: P) -> u32 {
//    unsafe { TODO: call ffi::g_io_add_watch() }
//}

//pub fn io_add_watch_full<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(channel: /*Ignored*/&IOChannel, priority: i32, condition: IOCondition, func: /*Unknown conversion*//*Unimplemented*/IOFunc, user_data: P, notify: /*Unknown conversion*//*Unimplemented*/DestroyNotify) -> u32 {
//    unsafe { TODO: call ffi::g_io_add_watch_full() }
//}

//pub fn io_create_watch(channel: /*Ignored*/&IOChannel, condition: IOCondition) -> Option<Source> {
//    unsafe { TODO: call ffi::g_io_create_watch() }
//}

pub fn listenv() -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_listenv())
    }
}

//pub fn log<'a, P: Into<Option<&'a str>>>(log_domain: P, log_level: /*Ignored*/LogLevelFlags, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_log() }
//}

//pub fn log_default_handler<'a, 'b, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>, R: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_domain: P, log_level: /*Ignored*/LogLevelFlags, message: Q, unused_data: R) {
//    unsafe { TODO: call ffi::g_log_default_handler() }
//}

pub fn log_remove_handler(log_domain: &str, handler_id: u32) {
    unsafe {
        ffi::g_log_remove_handler(log_domain.to_glib_none().0, handler_id);
    }
}

//pub fn log_set_always_fatal(fatal_mask: /*Ignored*/LogLevelFlags) -> /*Ignored*/LogLevelFlags {
//    unsafe { TODO: call ffi::g_log_set_always_fatal() }
//}

//pub fn log_set_default_handler<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_func: /*Unknown conversion*//*Unimplemented*/LogFunc, user_data: P) -> /*Unknown conversion*//*Unimplemented*/LogFunc {
//    unsafe { TODO: call ffi::g_log_set_default_handler() }
//}

//pub fn log_set_fatal_mask(log_domain: &str, fatal_mask: /*Ignored*/LogLevelFlags) -> /*Ignored*/LogLevelFlags {
//    unsafe { TODO: call ffi::g_log_set_fatal_mask() }
//}

//pub fn log_set_handler<'a, P: Into<Option<&'a str>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_domain: P, log_levels: /*Ignored*/LogLevelFlags, log_func: /*Unknown conversion*//*Unimplemented*/LogFunc, user_data: Q) -> u32 {
//    unsafe { TODO: call ffi::g_log_set_handler() }
//}

//#[cfg(any(feature = "v2_46", feature = "dox"))]
//pub fn log_set_handler_full<'a, P: Into<Option<&'a str>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_domain: P, log_levels: /*Ignored*/LogLevelFlags, log_func: /*Unknown conversion*//*Unimplemented*/LogFunc, user_data: Q, destroy: /*Unknown conversion*//*Unimplemented*/DestroyNotify) -> u32 {
//    unsafe { TODO: call ffi::g_log_set_handler_full() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_set_writer_func<'a, P: Into<Option<&'a /*Unimplemented*/LogWriterFunc>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(func: P, user_data: Q, user_data_free: /*Unknown conversion*//*Unimplemented*/DestroyNotify) {
//    unsafe { TODO: call ffi::g_log_set_writer_func() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_structured(log_domain: &str, log_level: /*Ignored*/LogLevelFlags, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_log_structured() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_structured_array(log_level: /*Ignored*/LogLevelFlags, fields: /*Ignored*/&[&LogField]) {
//    unsafe { TODO: call ffi::g_log_structured_array() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_variant<'a, P: Into<Option<&'a str>>>(log_domain: P, log_level: /*Ignored*/LogLevelFlags, fields: &Variant) {
//    unsafe { TODO: call ffi::g_log_variant() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_writer_default<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_level: /*Ignored*/LogLevelFlags, fields: /*Ignored*/&[&LogField], user_data: P) -> /*Ignored*/LogWriterOutput {
//    unsafe { TODO: call ffi::g_log_writer_default() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_writer_format_fields(log_level: /*Ignored*/LogLevelFlags, fields: /*Ignored*/&[&LogField], use_color: bool) -> Option<String> {
//    unsafe { TODO: call ffi::g_log_writer_format_fields() }
//}

#[cfg(any(feature = "v2_50", feature = "dox"))]
pub fn log_writer_is_journald(output_fd: i32) -> bool {
    unsafe {
        from_glib(ffi::g_log_writer_is_journald(output_fd))
    }
}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_writer_journald<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_level: /*Ignored*/LogLevelFlags, fields: /*Ignored*/&[&LogField], user_data: P) -> /*Ignored*/LogWriterOutput {
//    unsafe { TODO: call ffi::g_log_writer_journald() }
//}

//#[cfg(any(feature = "v2_50", feature = "dox"))]
//pub fn log_writer_standard_streams<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_level: /*Ignored*/LogLevelFlags, fields: /*Ignored*/&[&LogField], user_data: P) -> /*Ignored*/LogWriterOutput {
//    unsafe { TODO: call ffi::g_log_writer_standard_streams() }
//}

#[cfg(any(feature = "v2_50", feature = "dox"))]
pub fn log_writer_supports_color(output_fd: i32) -> bool {
    unsafe {
        from_glib(ffi::g_log_writer_supports_color(output_fd))
    }
}

//pub fn logv<'a, P: Into<Option<&'a str>>>(log_domain: P, log_level: /*Ignored*/LogLevelFlags, format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) {
//    unsafe { TODO: call ffi::g_logv() }
//}

pub fn main_current_source() -> Option<Source> {
    unsafe {
        from_glib_none(ffi::g_main_current_source())
    }
}

pub fn main_depth() -> i32 {
    unsafe {
        ffi::g_main_depth()
    }
}

//pub fn malloc(n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_malloc() }
//}

//pub fn malloc0(n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_malloc0() }
//}

//pub fn malloc0_n(n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_malloc0_n() }
//}

//pub fn malloc_n(n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_malloc_n() }
//}

//pub fn markup_collect_attributes(element_name: &str, attribute_names: &str, attribute_values: &str, error: &mut Error, first_type: /*Ignored*/MarkupCollectType, first_attr: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> bool {
//    unsafe { TODO: call ffi::g_markup_collect_attributes() }
//}

pub fn markup_escape_text(text: &str) -> String {
    let length = text.len() as isize;
    unsafe {
        from_glib_full(ffi::g_markup_escape_text(text.to_glib_none().0, length))
    }
}

//pub fn markup_printf_escaped(format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<String> {
//    unsafe { TODO: call ffi::g_markup_printf_escaped() }
//}

//pub fn markup_vprintf_escaped(format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> Option<String> {
//    unsafe { TODO: call ffi::g_markup_vprintf_escaped() }
//}

#[cfg_attr(feature = "v2_46", deprecated)]
pub fn mem_is_system_malloc() -> bool {
    unsafe {
        from_glib(ffi::g_mem_is_system_malloc())
    }
}

#[cfg_attr(feature = "v2_46", deprecated)]
pub fn mem_profile() {
    unsafe {
        ffi::g_mem_profile();
    }
}

//#[cfg_attr(feature = "v2_46", deprecated)]
//pub fn mem_set_vtable(vtable: /*Ignored*/&mut MemVTable) {
//    unsafe { TODO: call ffi::g_mem_set_vtable() }
//}

//pub fn memdup<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P, byte_size: u32) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_memdup() }
//}

pub fn mkdir_with_parents<P: AsRef<std::path::Path>>(pathname: P, mode: i32) -> i32 {
    unsafe {
        ffi::g_mkdir_with_parents(pathname.as_ref().to_glib_none().0, mode)
    }
}

pub fn mkdtemp<P: AsRef<std::path::Path>>(tmpl: P) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_mkdtemp(tmpl.as_ref().to_glib_none().0))
    }
}

pub fn mkdtemp_full<P: AsRef<std::path::Path>>(tmpl: P, mode: i32) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_mkdtemp_full(tmpl.as_ref().to_glib_none().0, mode))
    }
}

pub fn mkstemp_full<P: AsRef<std::path::Path>>(tmpl: P, flags: i32, mode: i32) -> i32 {
    unsafe {
        ffi::g_mkstemp_full(tmpl.as_ref().to_glib_none().0, flags, mode)
    }
}

//pub fn nullify_pointer(nullify_location: /*Unimplemented*/Fundamental: Pointer) {
//    unsafe { TODO: call ffi::g_nullify_pointer() }
//}

pub fn on_error_query(prg_name: &str) {
    unsafe {
        ffi::g_on_error_query(prg_name.to_glib_none().0);
    }
}

pub fn on_error_stack_trace(prg_name: &str) {
    unsafe {
        ffi::g_on_error_stack_trace(prg_name.to_glib_none().0);
    }
}

//pub fn parse_debug_string<'a, P: Into<Option<&'a str>>>(string: P, keys: /*Ignored*/&[&DebugKey]) -> u32 {
//    unsafe { TODO: call ffi::g_parse_debug_string() }
//}

pub fn path_get_basename<P: AsRef<std::path::Path>>(file_name: P) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_path_get_basename(file_name.as_ref().to_glib_none().0))
    }
}

pub fn path_get_dirname<P: AsRef<std::path::Path>>(file_name: P) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_full(ffi::g_path_get_dirname(file_name.as_ref().to_glib_none().0))
    }
}

pub fn path_is_absolute<P: AsRef<std::path::Path>>(file_name: P) -> bool {
    unsafe {
        from_glib(ffi::g_path_is_absolute(file_name.as_ref().to_glib_none().0))
    }
}

pub fn path_skip_root<P: AsRef<std::path::Path>>(file_name: P) -> Option<std::path::PathBuf> {
    unsafe {
        from_glib_none(ffi::g_path_skip_root(file_name.as_ref().to_glib_none().0))
    }
}

//pub fn pattern_match<'a, P: Into<Option<&'a str>>>(pspec: /*Ignored*/&mut PatternSpec, string_length: u32, string: &str, string_reversed: P) -> bool {
//    unsafe { TODO: call ffi::g_pattern_match() }
//}

pub fn pattern_match_simple(pattern: &str, string: &str) -> bool {
    unsafe {
        from_glib(ffi::g_pattern_match_simple(pattern.to_glib_none().0, string.to_glib_none().0))
    }
}

//pub fn pattern_match_string(pspec: /*Ignored*/&mut PatternSpec, string: &str) -> bool {
//    unsafe { TODO: call ffi::g_pattern_match_string() }
//}

//pub fn pointer_bit_lock(address: /*Unimplemented*/Fundamental: Pointer, lock_bit: i32) {
//    unsafe { TODO: call ffi::g_pointer_bit_lock() }
//}

//pub fn pointer_bit_trylock(address: /*Unimplemented*/Fundamental: Pointer, lock_bit: i32) -> bool {
//    unsafe { TODO: call ffi::g_pointer_bit_trylock() }
//}

//pub fn pointer_bit_unlock(address: /*Unimplemented*/Fundamental: Pointer, lock_bit: i32) {
//    unsafe { TODO: call ffi::g_pointer_bit_unlock() }
//}

//pub fn poll(fds: /*Ignored*/&mut PollFD, nfds: u32, timeout: i32) -> i32 {
//    unsafe { TODO: call ffi::g_poll() }
//}

//pub fn prefix_error<'a, P: Into<Option<&'a Error>>>(err: P, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_prefix_error() }
//}

//pub fn print(format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_print() }
//}

//pub fn printerr(format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_printerr() }
//}

//pub fn printf(format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> i32 {
//    unsafe { TODO: call ffi::g_printf() }
//}

//pub fn printf_string_upper_bound(format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> usize {
//    unsafe { TODO: call ffi::g_printf_string_upper_bound() }
//}

//pub fn propagate_prefixed_error(dest: &mut Error, src: &mut Error, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_propagate_prefixed_error() }
//}

//pub fn qsort_with_data<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(pbase: /*Unimplemented*/Fundamental: Pointer, total_elems: i32, size: usize, compare_func: /*Unknown conversion*//*Unimplemented*/CompareDataFunc, user_data: P) {
//    unsafe { TODO: call ffi::g_qsort_with_data() }
//}

pub fn random_double() -> f64 {
    unsafe {
        ffi::g_random_double()
    }
}

pub fn random_double_range(begin: f64, end: f64) -> f64 {
    unsafe {
        ffi::g_random_double_range(begin, end)
    }
}

pub fn random_int() -> u32 {
    unsafe {
        ffi::g_random_int()
    }
}

pub fn random_int_range(begin: i32, end: i32) -> i32 {
    unsafe {
        ffi::g_random_int_range(begin, end)
    }
}

pub fn random_set_seed(seed: u32) {
    unsafe {
        ffi::g_random_set_seed(seed);
    }
}

//pub fn realloc<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P, n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_realloc() }
//}

//pub fn realloc_n<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P, n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_realloc_n() }
//}

pub fn reload_user_special_dirs_cache() {
    unsafe {
        ffi::g_reload_user_special_dirs_cache();
    }
}

pub fn return_if_fail_warning<'a, 'b, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>>(log_domain: P, pretty_function: &str, expression: Q) {
    let log_domain = log_domain.into();
    let log_domain = log_domain.to_glib_none();
    let expression = expression.into();
    let expression = expression.to_glib_none();
    unsafe {
        ffi::g_return_if_fail_warning(log_domain.0, pretty_function.to_glib_none().0, expression.0);
    }
}

pub fn rmdir<P: AsRef<std::path::Path>>(filename: P) -> i32 {
    unsafe {
        ffi::g_rmdir(filename.as_ref().to_glib_none().0)
    }
}

pub fn set_application_name(application_name: &str) {
    unsafe {
        ffi::g_set_application_name(application_name.to_glib_none().0);
    }
}

//pub fn set_error(domain: Quark, code: i32, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Error {
//    unsafe { TODO: call ffi::g_set_error() }
//}

//pub fn set_print_handler(func: /*Unknown conversion*//*Unimplemented*/PrintFunc) -> /*Unknown conversion*//*Unimplemented*/PrintFunc {
//    unsafe { TODO: call ffi::g_set_print_handler() }
//}

//pub fn set_printerr_handler(func: /*Unknown conversion*//*Unimplemented*/PrintFunc) -> /*Unknown conversion*//*Unimplemented*/PrintFunc {
//    unsafe { TODO: call ffi::g_set_printerr_handler() }
//}

pub fn shell_parse_argv(command_line: &str) -> Result<Vec<String>, Error> {
    unsafe {
        let mut argcp = mem::uninitialized();
        let mut argvp = ptr::null_mut();
        let mut error = ptr::null_mut();
        let _ = ffi::g_shell_parse_argv(command_line.to_glib_none().0, &mut argcp, &mut argvp, &mut error);
        if error.is_null() { Ok(FromGlibContainer::from_glib_full_num(argvp, argcp as usize)) } else { Err(from_glib_full(error)) }
    }
}

pub fn shell_quote(unquoted_string: &str) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_shell_quote(unquoted_string.to_glib_none().0))
    }
}

pub fn shell_unquote(quoted_string: &str) -> Result<String, Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let ret = ffi::g_shell_unquote(quoted_string.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

//pub fn slice_alloc(block_size: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_slice_alloc() }
//}

//pub fn slice_alloc0(block_size: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_slice_alloc0() }
//}

//pub fn slice_copy<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(block_size: usize, mem_block: P) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_slice_copy() }
//}

//pub fn slice_free1<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(block_size: usize, mem_block: P) {
//    unsafe { TODO: call ffi::g_slice_free1() }
//}

//pub fn slice_free_chain_with_offset<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(block_size: usize, mem_chain: P, next_offset: usize) {
//    unsafe { TODO: call ffi::g_slice_free_chain_with_offset() }
//}

//pub fn slice_get_config(ckey: /*Ignored*/SliceConfig) -> i64 {
//    unsafe { TODO: call ffi::g_slice_get_config() }
//}

//pub fn slice_get_config_state(ckey: /*Ignored*/SliceConfig, address: i64, n_values: u32) -> i64 {
//    unsafe { TODO: call ffi::g_slice_get_config_state() }
//}

//pub fn slice_set_config(ckey: /*Ignored*/SliceConfig, value: i64) {
//    unsafe { TODO: call ffi::g_slice_set_config() }
//}

//pub fn snprintf(string: &str, n: libc::c_ulong, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> i32 {
//    unsafe { TODO: call ffi::g_snprintf() }
//}

pub fn spaced_primes_closest(num: u32) -> u32 {
    unsafe {
        ffi::g_spaced_primes_closest(num)
    }
}

//pub fn spawn_async<'a, P: AsRef<std::path::Path>, Q: Into<Option<&'a /*Unimplemented*/SpawnChildSetupFunc>>>(working_directory: P, argv: &[&str], envp: &[&str], flags: /*Ignored*/SpawnFlags, child_setup: Q) -> Result<Pid, Error> {
//    unsafe { TODO: call ffi::g_spawn_async() }
//}

//pub fn spawn_async_with_pipes<'a, P: AsRef<std::path::Path>, Q: Into<Option<&'a /*Unimplemented*/SpawnChildSetupFunc>>, R: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(working_directory: P, argv: &[&str], envp: &[&str], flags: /*Ignored*/SpawnFlags, child_setup: Q, user_data: R) -> Result<(Pid, i32, i32, i32), Error> {
//    unsafe { TODO: call ffi::g_spawn_async_with_pipes() }
//}

#[cfg(any(feature = "v2_34", feature = "dox"))]
pub fn spawn_check_exit_status(exit_status: i32) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_spawn_check_exit_status(exit_status, &mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(any(unix, feature = "dox"))]
pub fn spawn_command_line_async(command_line: &str) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_spawn_command_line_async(command_line.to_glib_none().0, &mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

//pub fn spawn_command_line_sync(command_line: &str, standard_output: Vec<u8>, standard_error: Vec<u8>) -> Result<i32, Error> {
//    unsafe { TODO: call ffi::g_spawn_command_line_sync() }
//}

//pub fn spawn_sync<'a, P: AsRef<std::path::Path>, Q: Into<Option<&'a /*Unimplemented*/SpawnChildSetupFunc>>, R: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(working_directory: P, argv: &[&str], envp: &[&str], flags: /*Ignored*/SpawnFlags, child_setup: Q, user_data: R, standard_output: Vec<u8>, standard_error: Vec<u8>) -> Result<i32, Error> {
//    unsafe { TODO: call ffi::g_spawn_sync() }
//}

//pub fn sprintf(string: &str, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> i32 {
//    unsafe { TODO: call ffi::g_sprintf() }
//}

pub fn stpcpy(dest: &str, src: &str) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_stpcpy(dest.to_glib_none().0, src.to_glib_none().0))
    }
}

//pub fn test_add_data_func<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(testpath: &str, test_data: P, test_func: /*Unknown conversion*//*Unimplemented*/TestDataFunc) {
//    unsafe { TODO: call ffi::g_test_add_data_func() }
//}

//#[cfg(any(feature = "v2_34", feature = "dox"))]
//pub fn test_add_data_func_full<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(testpath: &str, test_data: P, test_func: /*Unknown conversion*//*Unimplemented*/TestDataFunc, data_free_func: /*Unknown conversion*//*Unimplemented*/DestroyNotify) {
//    unsafe { TODO: call ffi::g_test_add_data_func_full() }
//}

//pub fn test_add_func(testpath: &str, test_func: /*Unknown conversion*//*Unimplemented*/TestFunc) {
//    unsafe { TODO: call ffi::g_test_add_func() }
//}

//pub fn test_add_vtable<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(testpath: &str, data_size: usize, test_data: P, data_setup: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc, data_test: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc, data_teardown: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc) {
//    unsafe { TODO: call ffi::g_test_add_vtable() }
//}

pub fn test_assert_expected_messages_internal(domain: &str, file: &str, line: i32, func: &str) {
    unsafe {
        ffi::g_test_assert_expected_messages_internal(domain.to_glib_none().0, file.to_glib_none().0, line, func.to_glib_none().0);
    }
}

pub fn test_bug(bug_uri_snippet: &str) {
    unsafe {
        ffi::g_test_bug(bug_uri_snippet.to_glib_none().0);
    }
}

pub fn test_bug_base(uri_pattern: &str) {
    unsafe {
        ffi::g_test_bug_base(uri_pattern.to_glib_none().0);
    }
}

//#[cfg(any(feature = "v2_38", feature = "dox"))]
//pub fn test_build_filename(file_type: /*Ignored*/TestFileType, first_path: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<String> {
//    unsafe { TODO: call ffi::g_test_build_filename() }
//}

//pub fn test_create_case<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(test_name: &str, data_size: usize, test_data: P, data_setup: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc, data_test: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc, data_teardown: /*Unknown conversion*//*Unimplemented*/TestFixtureFunc) -> /*Ignored*/Option<TestCase> {
//    unsafe { TODO: call ffi::g_test_create_case() }
//}

//pub fn test_create_suite(suite_name: &str) -> /*Ignored*/Option<TestSuite> {
//    unsafe { TODO: call ffi::g_test_create_suite() }
//}

//#[cfg(any(feature = "v2_34", feature = "dox"))]
//pub fn test_expect_message<'a, P: Into<Option<&'a str>>>(log_domain: P, log_level: /*Ignored*/LogLevelFlags, pattern: &str) {
//    unsafe { TODO: call ffi::g_test_expect_message() }
//}

pub fn test_fail() {
    unsafe {
        ffi::g_test_fail();
    }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
pub fn test_failed() -> bool {
    unsafe {
        from_glib(ffi::g_test_failed())
    }
}

//#[cfg(any(feature = "v2_38", feature = "dox"))]
//pub fn test_get_dir(file_type: /*Ignored*/TestFileType) -> Option<std::path::PathBuf> {
//    unsafe { TODO: call ffi::g_test_get_dir() }
//}

//#[cfg(any(feature = "v2_38", feature = "dox"))]
//pub fn test_get_filename(file_type: /*Ignored*/TestFileType, first_path: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Option<String> {
//    unsafe { TODO: call ffi::g_test_get_filename() }
//}

//pub fn test_get_root() -> /*Ignored*/Option<TestSuite> {
//    unsafe { TODO: call ffi::g_test_get_root() }
//}

#[cfg(any(feature = "v2_38", feature = "dox"))]
pub fn test_incomplete<'a, P: Into<Option<&'a str>>>(msg: P) {
    let msg = msg.into();
    let msg = msg.to_glib_none();
    unsafe {
        ffi::g_test_incomplete(msg.0);
    }
}

//pub fn test_init(argc: i32, argv: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_test_init() }
//}

//pub fn test_log_set_fatal_handler<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(log_func: /*Unknown conversion*//*Unimplemented*/TestLogFatalFunc, user_data: P) {
//    unsafe { TODO: call ffi::g_test_log_set_fatal_handler() }
//}

//pub fn test_log_type_name(log_type: /*Ignored*/TestLogType) -> Option<String> {
//    unsafe { TODO: call ffi::g_test_log_type_name() }
//}

//pub fn test_maximized_result(maximized_quantity: f64, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_test_maximized_result() }
//}

//pub fn test_message(format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_test_message() }
//}

//pub fn test_minimized_result(minimized_quantity: f64, format: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) {
//    unsafe { TODO: call ffi::g_test_minimized_result() }
//}

//pub fn test_queue_destroy<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(destroy_func: /*Unknown conversion*//*Unimplemented*/DestroyNotify, destroy_data: P) {
//    unsafe { TODO: call ffi::g_test_queue_destroy() }
//}

//pub fn test_queue_free<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(gfree_pointer: P) {
//    unsafe { TODO: call ffi::g_test_queue_free() }
//}

pub fn test_rand_double() -> f64 {
    unsafe {
        ffi::g_test_rand_double()
    }
}

pub fn test_rand_double_range(range_start: f64, range_end: f64) -> f64 {
    unsafe {
        ffi::g_test_rand_double_range(range_start, range_end)
    }
}

pub fn test_rand_int() -> i32 {
    unsafe {
        ffi::g_test_rand_int()
    }
}

pub fn test_rand_int_range(begin: i32, end: i32) -> i32 {
    unsafe {
        ffi::g_test_rand_int_range(begin, end)
    }
}

pub fn test_run() -> i32 {
    unsafe {
        ffi::g_test_run()
    }
}

//pub fn test_run_suite(suite: /*Ignored*/&mut TestSuite) -> i32 {
//    unsafe { TODO: call ffi::g_test_run_suite() }
//}

#[cfg(any(feature = "v2_38", feature = "dox"))]
pub fn test_set_nonfatal_assertions() {
    unsafe {
        ffi::g_test_set_nonfatal_assertions();
    }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
pub fn test_skip<'a, P: Into<Option<&'a str>>>(msg: P) {
    let msg = msg.into();
    let msg = msg.to_glib_none();
    unsafe {
        ffi::g_test_skip(msg.0);
    }
}

#[cfg(any(feature = "v2_38", feature = "dox"))]
pub fn test_subprocess() -> bool {
    unsafe {
        from_glib(ffi::g_test_subprocess())
    }
}

pub fn test_timer_elapsed() -> f64 {
    unsafe {
        ffi::g_test_timer_elapsed()
    }
}

pub fn test_timer_last() -> f64 {
    unsafe {
        ffi::g_test_timer_last()
    }
}

pub fn test_timer_start() {
    unsafe {
        ffi::g_test_timer_start();
    }
}

pub fn test_trap_assertions(domain: &str, file: &str, line: i32, func: &str, assertion_flags: u64, pattern: &str) {
    unsafe {
        ffi::g_test_trap_assertions(domain.to_glib_none().0, file.to_glib_none().0, line, func.to_glib_none().0, assertion_flags, pattern.to_glib_none().0);
    }
}

//pub fn test_trap_fork(usec_timeout: u64, test_trap_flags: /*Ignored*/TestTrapFlags) -> bool {
//    unsafe { TODO: call ffi::g_test_trap_fork() }
//}

pub fn test_trap_has_passed() -> bool {
    unsafe {
        from_glib(ffi::g_test_trap_has_passed())
    }
}

pub fn test_trap_reached_timeout() -> bool {
    unsafe {
        from_glib(ffi::g_test_trap_reached_timeout())
    }
}

//#[cfg(any(feature = "v2_38", feature = "dox"))]
//pub fn test_trap_subprocess<'a, P: Into<Option<&'a str>>>(test_path: P, usec_timeout: u64, test_flags: /*Ignored*/TestSubprocessFlags) {
//    unsafe { TODO: call ffi::g_test_trap_subprocess() }
//}

//pub fn timeout_add<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(interval: u32, function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P) -> u32 {
//    unsafe { TODO: call ffi::g_timeout_add() }
//}

//pub fn timeout_add_full<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a /*Unimplemented*/DestroyNotify>>>(priority: i32, interval: u32, function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P, notify: Q) -> u32 {
//    unsafe { TODO: call ffi::g_timeout_add_full() }
//}

//pub fn timeout_add_seconds<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(interval: u32, function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P) -> u32 {
//    unsafe { TODO: call ffi::g_timeout_add_seconds() }
//}

//pub fn timeout_add_seconds_full<'a, P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: Into<Option<&'a /*Unimplemented*/DestroyNotify>>>(priority: i32, interval: u32, function: /*Unknown conversion*//*Unimplemented*/SourceFunc, data: P, notify: Q) -> u32 {
//    unsafe { TODO: call ffi::g_timeout_add_seconds_full() }
//}

//pub fn try_malloc(n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_malloc() }
//}

//pub fn try_malloc0(n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_malloc0() }
//}

//pub fn try_malloc0_n(n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_malloc0_n() }
//}

//pub fn try_malloc_n(n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_malloc_n() }
//}

//pub fn try_realloc<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P, n_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_realloc() }
//}

//pub fn try_realloc_n<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(mem: P, n_blocks: usize, n_block_bytes: usize) -> /*Unimplemented*/Option<Fundamental: Pointer> {
//    unsafe { TODO: call ffi::g_try_realloc_n() }
//}

//pub fn unicode_script_from_iso15924(iso15924: u32) -> /*Ignored*/UnicodeScript {
//    unsafe { TODO: call ffi::g_unicode_script_from_iso15924() }
//}

//pub fn unicode_script_to_iso15924(script: /*Ignored*/UnicodeScript) -> u32 {
//    unsafe { TODO: call ffi::g_unicode_script_to_iso15924() }
//}

#[cfg(any(unix, feature = "dox"))]
pub fn unix_set_fd_nonblocking(fd: i32, nonblock: bool) -> Result<(), Error> {
    unsafe {
        let mut error = ptr::null_mut();
        let _ = ffi::g_unix_set_fd_nonblocking(fd, nonblock.to_glib(), &mut error);
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

//#[cfg(any(unix, feature = "dox"))]
//pub fn unix_signal_add<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(signum: i32, handler: /*Unknown conversion*//*Unimplemented*/SourceFunc, user_data: P) -> u32 {
//    unsafe { TODO: call ffi::g_unix_signal_add() }
//}

//#[cfg(any(unix, feature = "dox"))]
//pub fn unix_signal_add_full<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(priority: i32, signum: i32, handler: /*Unknown conversion*//*Unimplemented*/SourceFunc, user_data: P, notify: /*Unknown conversion*//*Unimplemented*/DestroyNotify) -> u32 {
//    unsafe { TODO: call ffi::g_unix_signal_add_full() }
//}

pub fn unlink<P: AsRef<std::path::Path>>(filename: P) -> i32 {
    unsafe {
        ffi::g_unlink(filename.as_ref().to_glib_none().0)
    }
}

pub fn uri_escape_string<'a, P: Into<Option<&'a str>>>(unescaped: &str, reserved_chars_allowed: P, allow_utf8: bool) -> Option<String> {
    let reserved_chars_allowed = reserved_chars_allowed.into();
    let reserved_chars_allowed = reserved_chars_allowed.to_glib_none();
    unsafe {
        from_glib_full(ffi::g_uri_escape_string(unescaped.to_glib_none().0, reserved_chars_allowed.0, allow_utf8.to_glib()))
    }
}

pub fn uri_list_extract_uris(uri_list: &str) -> Vec<String> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::g_uri_list_extract_uris(uri_list.to_glib_none().0))
    }
}

pub fn uri_parse_scheme(uri: &str) -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_uri_parse_scheme(uri.to_glib_none().0))
    }
}

pub fn uri_unescape_segment<'a, 'b, 'c, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>, R: Into<Option<&'c str>>>(escaped_string: P, escaped_string_end: Q, illegal_characters: R) -> Option<String> {
    let escaped_string = escaped_string.into();
    let escaped_string = escaped_string.to_glib_none();
    let escaped_string_end = escaped_string_end.into();
    let escaped_string_end = escaped_string_end.to_glib_none();
    let illegal_characters = illegal_characters.into();
    let illegal_characters = illegal_characters.to_glib_none();
    unsafe {
        from_glib_full(ffi::g_uri_unescape_segment(escaped_string.0, escaped_string_end.0, illegal_characters.0))
    }
}

pub fn uri_unescape_string<'a, P: Into<Option<&'a str>>>(escaped_string: &str, illegal_characters: P) -> Option<String> {
    let illegal_characters = illegal_characters.into();
    let illegal_characters = illegal_characters.to_glib_none();
    unsafe {
        from_glib_full(ffi::g_uri_unescape_string(escaped_string.to_glib_none().0, illegal_characters.0))
    }
}

pub fn usleep(microseconds: libc::c_ulong) {
    unsafe {
        ffi::g_usleep(microseconds);
    }
}

#[cfg(any(feature = "v2_52", feature = "dox"))]
pub fn uuid_string_is_valid(str: &str) -> bool {
    unsafe {
        from_glib(ffi::g_uuid_string_is_valid(str.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_52", feature = "dox"))]
pub fn uuid_string_random() -> Option<String> {
    unsafe {
        from_glib_full(ffi::g_uuid_string_random())
    }
}

pub fn variant_get_gtype() -> types::Type {
    unsafe {
        from_glib(ffi::g_variant_get_gtype())
    }
}

//pub fn vasprintf(string: &str, format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> i32 {
//    unsafe { TODO: call ffi::g_vasprintf() }
//}

//pub fn vfprintf(file: /*Unimplemented*/Fundamental: Pointer, format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> i32 {
//    unsafe { TODO: call ffi::g_vfprintf() }
//}

//pub fn vprintf(format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> i32 {
//    unsafe { TODO: call ffi::g_vprintf() }
//}

//pub fn vsnprintf(string: &str, n: libc::c_ulong, format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> i32 {
//    unsafe { TODO: call ffi::g_vsnprintf() }
//}

//pub fn vsprintf(string: &str, format: &str, args: /*Unknown conversion*//*Unimplemented*/Unsupported) -> i32 {
//    unsafe { TODO: call ffi::g_vsprintf() }
//}

pub fn warn_message<'a, 'b, P: Into<Option<&'a str>>, Q: Into<Option<&'b str>>>(domain: P, file: &str, line: i32, func: &str, warnexpr: Q) {
    let domain = domain.into();
    let domain = domain.to_glib_none();
    let warnexpr = warnexpr.into();
    let warnexpr = warnexpr.to_glib_none();
    unsafe {
        ffi::g_warn_message(domain.0, file.to_glib_none().0, line, func.to_glib_none().0, warnexpr.0);
    }
}
