// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GBusType")]
pub enum BusType {
    #[doc(alias = "G_BUS_TYPE_STARTER")]
    Starter,
    #[doc(alias = "G_BUS_TYPE_NONE")]
    None,
    #[doc(alias = "G_BUS_TYPE_SYSTEM")]
    System,
    #[doc(alias = "G_BUS_TYPE_SESSION")]
    Session,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BusType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BusType::{}",
            match *self {
                Self::Starter => "Starter",
                Self::None => "None",
                Self::System => "System",
                Self::Session => "Session",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for BusType {
    type GlibType = ffi::GBusType;

    fn into_glib(self) -> ffi::GBusType {
        match self {
            Self::Starter => ffi::G_BUS_TYPE_STARTER,
            Self::None => ffi::G_BUS_TYPE_NONE,
            Self::System => ffi::G_BUS_TYPE_SYSTEM,
            Self::Session => ffi::G_BUS_TYPE_SESSION,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GBusType> for BusType {
    unsafe fn from_glib(value: ffi::GBusType) -> Self {
        match value {
            -1 => Self::Starter,
            0 => Self::None,
            1 => Self::System,
            2 => Self::Session,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BusType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_bus_type_get_type()) }
    }
}

impl glib::value::ValueType for BusType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BusType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BusType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GConverterResult")]
pub enum ConverterResult {
    #[doc(alias = "G_CONVERTER_ERROR")]
    Error,
    #[doc(alias = "G_CONVERTER_CONVERTED")]
    Converted,
    #[doc(alias = "G_CONVERTER_FINISHED")]
    Finished,
    #[doc(alias = "G_CONVERTER_FLUSHED")]
    Flushed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConverterResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ConverterResult::{}",
            match *self {
                Self::Error => "Error",
                Self::Converted => "Converted",
                Self::Finished => "Finished",
                Self::Flushed => "Flushed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ConverterResult {
    type GlibType = ffi::GConverterResult;

    fn into_glib(self) -> ffi::GConverterResult {
        match self {
            Self::Error => ffi::G_CONVERTER_ERROR,
            Self::Converted => ffi::G_CONVERTER_CONVERTED,
            Self::Finished => ffi::G_CONVERTER_FINISHED,
            Self::Flushed => ffi::G_CONVERTER_FLUSHED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GConverterResult> for ConverterResult {
    unsafe fn from_glib(value: ffi::GConverterResult) -> Self {
        match value {
            0 => Self::Error,
            1 => Self::Converted,
            2 => Self::Finished,
            3 => Self::Flushed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConverterResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_converter_result_get_type()) }
    }
}

impl glib::value::ValueType for ConverterResult {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConverterResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConverterResult {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GCredentialsType")]
pub enum CredentialsType {
    #[doc(alias = "G_CREDENTIALS_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "G_CREDENTIALS_TYPE_LINUX_UCRED")]
    LinuxUcred,
    #[doc(alias = "G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED")]
    FreebsdCmsgcred,
    #[doc(alias = "G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED")]
    OpenbsdSockpeercred,
    #[doc(alias = "G_CREDENTIALS_TYPE_SOLARIS_UCRED")]
    SolarisUcred,
    #[doc(alias = "G_CREDENTIALS_TYPE_NETBSD_UNPCBID")]
    NetbsdUnpcbid,
    #[doc(alias = "G_CREDENTIALS_TYPE_APPLE_XUCRED")]
    AppleXucred,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CredentialsType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CredentialsType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::LinuxUcred => "LinuxUcred",
                Self::FreebsdCmsgcred => "FreebsdCmsgcred",
                Self::OpenbsdSockpeercred => "OpenbsdSockpeercred",
                Self::SolarisUcred => "SolarisUcred",
                Self::NetbsdUnpcbid => "NetbsdUnpcbid",
                Self::AppleXucred => "AppleXucred",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CredentialsType {
    type GlibType = ffi::GCredentialsType;

    fn into_glib(self) -> ffi::GCredentialsType {
        match self {
            Self::Invalid => ffi::G_CREDENTIALS_TYPE_INVALID,
            Self::LinuxUcred => ffi::G_CREDENTIALS_TYPE_LINUX_UCRED,
            Self::FreebsdCmsgcred => ffi::G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED,
            Self::OpenbsdSockpeercred => ffi::G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED,
            Self::SolarisUcred => ffi::G_CREDENTIALS_TYPE_SOLARIS_UCRED,
            Self::NetbsdUnpcbid => ffi::G_CREDENTIALS_TYPE_NETBSD_UNPCBID,
            Self::AppleXucred => ffi::G_CREDENTIALS_TYPE_APPLE_XUCRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GCredentialsType> for CredentialsType {
    unsafe fn from_glib(value: ffi::GCredentialsType) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::LinuxUcred,
            2 => Self::FreebsdCmsgcred,
            3 => Self::OpenbsdSockpeercred,
            4 => Self::SolarisUcred,
            5 => Self::NetbsdUnpcbid,
            6 => Self::AppleXucred,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CredentialsType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_credentials_type_get_type()) }
    }
}

impl glib::value::ValueType for CredentialsType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CredentialsType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CredentialsType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDBusMessageByteOrder")]
pub enum DBusMessageByteOrder {
    #[doc(alias = "G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN")]
    BigEndian,
    #[doc(alias = "G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN")]
    LittleEndian,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DBusMessageByteOrder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DBusMessageByteOrder::{}",
            match *self {
                Self::BigEndian => "BigEndian",
                Self::LittleEndian => "LittleEndian",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DBusMessageByteOrder {
    type GlibType = ffi::GDBusMessageByteOrder;

    fn into_glib(self) -> ffi::GDBusMessageByteOrder {
        match self {
            Self::BigEndian => ffi::G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN,
            Self::LittleEndian => ffi::G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDBusMessageByteOrder> for DBusMessageByteOrder {
    unsafe fn from_glib(value: ffi::GDBusMessageByteOrder) -> Self {
        match value {
            66 => Self::BigEndian,
            108 => Self::LittleEndian,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DBusMessageByteOrder {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_dbus_message_byte_order_get_type()) }
    }
}

impl glib::value::ValueType for DBusMessageByteOrder {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DBusMessageByteOrder {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DBusMessageByteOrder {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDBusMessageHeaderField")]
pub enum DBusMessageHeaderField {
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_INVALID")]
    Invalid,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_PATH")]
    Path,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE")]
    Interface,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_MEMBER")]
    Member,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME")]
    ErrorName,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL")]
    ReplySerial,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION")]
    Destination,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_SENDER")]
    Sender,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE")]
    Signature,
    #[doc(alias = "G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS")]
    NumUnixFds,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DBusMessageHeaderField {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DBusMessageHeaderField::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::Path => "Path",
                Self::Interface => "Interface",
                Self::Member => "Member",
                Self::ErrorName => "ErrorName",
                Self::ReplySerial => "ReplySerial",
                Self::Destination => "Destination",
                Self::Sender => "Sender",
                Self::Signature => "Signature",
                Self::NumUnixFds => "NumUnixFds",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DBusMessageHeaderField {
    type GlibType = ffi::GDBusMessageHeaderField;

    fn into_glib(self) -> ffi::GDBusMessageHeaderField {
        match self {
            Self::Invalid => ffi::G_DBUS_MESSAGE_HEADER_FIELD_INVALID,
            Self::Path => ffi::G_DBUS_MESSAGE_HEADER_FIELD_PATH,
            Self::Interface => ffi::G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE,
            Self::Member => ffi::G_DBUS_MESSAGE_HEADER_FIELD_MEMBER,
            Self::ErrorName => ffi::G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME,
            Self::ReplySerial => ffi::G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL,
            Self::Destination => ffi::G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION,
            Self::Sender => ffi::G_DBUS_MESSAGE_HEADER_FIELD_SENDER,
            Self::Signature => ffi::G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE,
            Self::NumUnixFds => ffi::G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDBusMessageHeaderField> for DBusMessageHeaderField {
    unsafe fn from_glib(value: ffi::GDBusMessageHeaderField) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::Path,
            2 => Self::Interface,
            3 => Self::Member,
            4 => Self::ErrorName,
            5 => Self::ReplySerial,
            6 => Self::Destination,
            7 => Self::Sender,
            8 => Self::Signature,
            9 => Self::NumUnixFds,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DBusMessageHeaderField {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_dbus_message_header_field_get_type()) }
    }
}

impl glib::value::ValueType for DBusMessageHeaderField {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DBusMessageHeaderField {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DBusMessageHeaderField {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDBusMessageType")]
pub enum DBusMessageType {
    #[doc(alias = "G_DBUS_MESSAGE_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "G_DBUS_MESSAGE_TYPE_METHOD_CALL")]
    MethodCall,
    #[doc(alias = "G_DBUS_MESSAGE_TYPE_METHOD_RETURN")]
    MethodReturn,
    #[doc(alias = "G_DBUS_MESSAGE_TYPE_ERROR")]
    Error,
    #[doc(alias = "G_DBUS_MESSAGE_TYPE_SIGNAL")]
    Signal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DBusMessageType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DBusMessageType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::MethodCall => "MethodCall",
                Self::MethodReturn => "MethodReturn",
                Self::Error => "Error",
                Self::Signal => "Signal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DBusMessageType {
    type GlibType = ffi::GDBusMessageType;

    fn into_glib(self) -> ffi::GDBusMessageType {
        match self {
            Self::Invalid => ffi::G_DBUS_MESSAGE_TYPE_INVALID,
            Self::MethodCall => ffi::G_DBUS_MESSAGE_TYPE_METHOD_CALL,
            Self::MethodReturn => ffi::G_DBUS_MESSAGE_TYPE_METHOD_RETURN,
            Self::Error => ffi::G_DBUS_MESSAGE_TYPE_ERROR,
            Self::Signal => ffi::G_DBUS_MESSAGE_TYPE_SIGNAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDBusMessageType> for DBusMessageType {
    unsafe fn from_glib(value: ffi::GDBusMessageType) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::MethodCall,
            2 => Self::MethodReturn,
            3 => Self::Error,
            4 => Self::Signal,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DBusMessageType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_dbus_message_type_get_type()) }
    }
}

impl glib::value::ValueType for DBusMessageType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DBusMessageType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DBusMessageType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDataStreamByteOrder")]
pub enum DataStreamByteOrder {
    #[doc(alias = "G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN")]
    BigEndian,
    #[doc(alias = "G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN")]
    LittleEndian,
    #[doc(alias = "G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN")]
    HostEndian,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DataStreamByteOrder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DataStreamByteOrder::{}",
            match *self {
                Self::BigEndian => "BigEndian",
                Self::LittleEndian => "LittleEndian",
                Self::HostEndian => "HostEndian",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DataStreamByteOrder {
    type GlibType = ffi::GDataStreamByteOrder;

    fn into_glib(self) -> ffi::GDataStreamByteOrder {
        match self {
            Self::BigEndian => ffi::G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
            Self::LittleEndian => ffi::G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
            Self::HostEndian => ffi::G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDataStreamByteOrder> for DataStreamByteOrder {
    unsafe fn from_glib(value: ffi::GDataStreamByteOrder) -> Self {
        match value {
            0 => Self::BigEndian,
            1 => Self::LittleEndian,
            2 => Self::HostEndian,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DataStreamByteOrder {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_data_stream_byte_order_get_type()) }
    }
}

impl glib::value::ValueType for DataStreamByteOrder {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DataStreamByteOrder {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DataStreamByteOrder {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDataStreamNewlineType")]
pub enum DataStreamNewlineType {
    #[doc(alias = "G_DATA_STREAM_NEWLINE_TYPE_LF")]
    Lf,
    #[doc(alias = "G_DATA_STREAM_NEWLINE_TYPE_CR")]
    Cr,
    #[doc(alias = "G_DATA_STREAM_NEWLINE_TYPE_CR_LF")]
    CrLf,
    #[doc(alias = "G_DATA_STREAM_NEWLINE_TYPE_ANY")]
    Any,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DataStreamNewlineType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DataStreamNewlineType::{}",
            match *self {
                Self::Lf => "Lf",
                Self::Cr => "Cr",
                Self::CrLf => "CrLf",
                Self::Any => "Any",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DataStreamNewlineType {
    type GlibType = ffi::GDataStreamNewlineType;

    fn into_glib(self) -> ffi::GDataStreamNewlineType {
        match self {
            Self::Lf => ffi::G_DATA_STREAM_NEWLINE_TYPE_LF,
            Self::Cr => ffi::G_DATA_STREAM_NEWLINE_TYPE_CR,
            Self::CrLf => ffi::G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
            Self::Any => ffi::G_DATA_STREAM_NEWLINE_TYPE_ANY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDataStreamNewlineType> for DataStreamNewlineType {
    unsafe fn from_glib(value: ffi::GDataStreamNewlineType) -> Self {
        match value {
            0 => Self::Lf,
            1 => Self::Cr,
            2 => Self::CrLf,
            3 => Self::Any,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DataStreamNewlineType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_data_stream_newline_type_get_type()) }
    }
}

impl glib::value::ValueType for DataStreamNewlineType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DataStreamNewlineType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DataStreamNewlineType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GDriveStartStopType")]
pub enum DriveStartStopType {
    #[doc(alias = "G_DRIVE_START_STOP_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "G_DRIVE_START_STOP_TYPE_SHUTDOWN")]
    Shutdown,
    #[doc(alias = "G_DRIVE_START_STOP_TYPE_NETWORK")]
    Network,
    #[doc(alias = "G_DRIVE_START_STOP_TYPE_MULTIDISK")]
    Multidisk,
    #[doc(alias = "G_DRIVE_START_STOP_TYPE_PASSWORD")]
    Password,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DriveStartStopType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DriveStartStopType::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Shutdown => "Shutdown",
                Self::Network => "Network",
                Self::Multidisk => "Multidisk",
                Self::Password => "Password",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for DriveStartStopType {
    type GlibType = ffi::GDriveStartStopType;

    fn into_glib(self) -> ffi::GDriveStartStopType {
        match self {
            Self::Unknown => ffi::G_DRIVE_START_STOP_TYPE_UNKNOWN,
            Self::Shutdown => ffi::G_DRIVE_START_STOP_TYPE_SHUTDOWN,
            Self::Network => ffi::G_DRIVE_START_STOP_TYPE_NETWORK,
            Self::Multidisk => ffi::G_DRIVE_START_STOP_TYPE_MULTIDISK,
            Self::Password => ffi::G_DRIVE_START_STOP_TYPE_PASSWORD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDriveStartStopType> for DriveStartStopType {
    unsafe fn from_glib(value: ffi::GDriveStartStopType) -> Self {
        match value {
            0 => Self::Unknown,
            1 => Self::Shutdown,
            2 => Self::Network,
            3 => Self::Multidisk,
            4 => Self::Password,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DriveStartStopType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_drive_start_stop_type_get_type()) }
    }
}

impl glib::value::ValueType for DriveStartStopType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DriveStartStopType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DriveStartStopType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GEmblemOrigin")]
pub enum EmblemOrigin {
    #[doc(alias = "G_EMBLEM_ORIGIN_UNKNOWN")]
    Unknown,
    #[doc(alias = "G_EMBLEM_ORIGIN_DEVICE")]
    Device,
    #[doc(alias = "G_EMBLEM_ORIGIN_LIVEMETADATA")]
    Livemetadata,
    #[doc(alias = "G_EMBLEM_ORIGIN_TAG")]
    Tag,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EmblemOrigin {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EmblemOrigin::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Device => "Device",
                Self::Livemetadata => "Livemetadata",
                Self::Tag => "Tag",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for EmblemOrigin {
    type GlibType = ffi::GEmblemOrigin;

    fn into_glib(self) -> ffi::GEmblemOrigin {
        match self {
            Self::Unknown => ffi::G_EMBLEM_ORIGIN_UNKNOWN,
            Self::Device => ffi::G_EMBLEM_ORIGIN_DEVICE,
            Self::Livemetadata => ffi::G_EMBLEM_ORIGIN_LIVEMETADATA,
            Self::Tag => ffi::G_EMBLEM_ORIGIN_TAG,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GEmblemOrigin> for EmblemOrigin {
    unsafe fn from_glib(value: ffi::GEmblemOrigin) -> Self {
        match value {
            0 => Self::Unknown,
            1 => Self::Device,
            2 => Self::Livemetadata,
            3 => Self::Tag,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EmblemOrigin {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_emblem_origin_get_type()) }
    }
}

impl glib::value::ValueType for EmblemOrigin {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for EmblemOrigin {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EmblemOrigin {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GFileAttributeStatus")]
pub enum FileAttributeStatus {
    #[doc(alias = "G_FILE_ATTRIBUTE_STATUS_UNSET")]
    Unset,
    #[doc(alias = "G_FILE_ATTRIBUTE_STATUS_SET")]
    Set,
    #[doc(alias = "G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING")]
    ErrorSetting,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileAttributeStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileAttributeStatus::{}",
            match *self {
                Self::Unset => "Unset",
                Self::Set => "Set",
                Self::ErrorSetting => "ErrorSetting",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileAttributeStatus {
    type GlibType = ffi::GFileAttributeStatus;

    fn into_glib(self) -> ffi::GFileAttributeStatus {
        match self {
            Self::Unset => ffi::G_FILE_ATTRIBUTE_STATUS_UNSET,
            Self::Set => ffi::G_FILE_ATTRIBUTE_STATUS_SET,
            Self::ErrorSetting => ffi::G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GFileAttributeStatus> for FileAttributeStatus {
    unsafe fn from_glib(value: ffi::GFileAttributeStatus) -> Self {
        match value {
            0 => Self::Unset,
            1 => Self::Set,
            2 => Self::ErrorSetting,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FileAttributeStatus {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_file_attribute_status_get_type()) }
    }
}

impl glib::value::ValueType for FileAttributeStatus {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileAttributeStatus {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileAttributeStatus {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GFileAttributeType")]
pub enum FileAttributeType {
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_STRING")]
    String,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_BYTE_STRING")]
    ByteString,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_BOOLEAN")]
    Boolean,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_UINT32")]
    Uint32,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_INT32")]
    Int32,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_UINT64")]
    Uint64,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_INT64")]
    Int64,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_OBJECT")]
    Object,
    #[doc(alias = "G_FILE_ATTRIBUTE_TYPE_STRINGV")]
    Stringv,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileAttributeType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileAttributeType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::String => "String",
                Self::ByteString => "ByteString",
                Self::Boolean => "Boolean",
                Self::Uint32 => "Uint32",
                Self::Int32 => "Int32",
                Self::Uint64 => "Uint64",
                Self::Int64 => "Int64",
                Self::Object => "Object",
                Self::Stringv => "Stringv",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileAttributeType {
    type GlibType = ffi::GFileAttributeType;

    fn into_glib(self) -> ffi::GFileAttributeType {
        match self {
            Self::Invalid => ffi::G_FILE_ATTRIBUTE_TYPE_INVALID,
            Self::String => ffi::G_FILE_ATTRIBUTE_TYPE_STRING,
            Self::ByteString => ffi::G_FILE_ATTRIBUTE_TYPE_BYTE_STRING,
            Self::Boolean => ffi::G_FILE_ATTRIBUTE_TYPE_BOOLEAN,
            Self::Uint32 => ffi::G_FILE_ATTRIBUTE_TYPE_UINT32,
            Self::Int32 => ffi::G_FILE_ATTRIBUTE_TYPE_INT32,
            Self::Uint64 => ffi::G_FILE_ATTRIBUTE_TYPE_UINT64,
            Self::Int64 => ffi::G_FILE_ATTRIBUTE_TYPE_INT64,
            Self::Object => ffi::G_FILE_ATTRIBUTE_TYPE_OBJECT,
            Self::Stringv => ffi::G_FILE_ATTRIBUTE_TYPE_STRINGV,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GFileAttributeType> for FileAttributeType {
    unsafe fn from_glib(value: ffi::GFileAttributeType) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::String,
            2 => Self::ByteString,
            3 => Self::Boolean,
            4 => Self::Uint32,
            5 => Self::Int32,
            6 => Self::Uint64,
            7 => Self::Int64,
            8 => Self::Object,
            9 => Self::Stringv,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FileAttributeType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_file_attribute_type_get_type()) }
    }
}

impl glib::value::ValueType for FileAttributeType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileAttributeType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileAttributeType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GFileMonitorEvent")]
pub enum FileMonitorEvent {
    #[doc(alias = "G_FILE_MONITOR_EVENT_CHANGED")]
    Changed,
    #[doc(alias = "G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT")]
    ChangesDoneHint,
    #[doc(alias = "G_FILE_MONITOR_EVENT_DELETED")]
    Deleted,
    #[doc(alias = "G_FILE_MONITOR_EVENT_CREATED")]
    Created,
    #[doc(alias = "G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED")]
    AttributeChanged,
    #[doc(alias = "G_FILE_MONITOR_EVENT_PRE_UNMOUNT")]
    PreUnmount,
    #[doc(alias = "G_FILE_MONITOR_EVENT_UNMOUNTED")]
    Unmounted,
    #[doc(alias = "G_FILE_MONITOR_EVENT_MOVED")]
    Moved,
    #[doc(alias = "G_FILE_MONITOR_EVENT_RENAMED")]
    Renamed,
    #[doc(alias = "G_FILE_MONITOR_EVENT_MOVED_IN")]
    MovedIn,
    #[doc(alias = "G_FILE_MONITOR_EVENT_MOVED_OUT")]
    MovedOut,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileMonitorEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileMonitorEvent::{}",
            match *self {
                Self::Changed => "Changed",
                Self::ChangesDoneHint => "ChangesDoneHint",
                Self::Deleted => "Deleted",
                Self::Created => "Created",
                Self::AttributeChanged => "AttributeChanged",
                Self::PreUnmount => "PreUnmount",
                Self::Unmounted => "Unmounted",
                Self::Moved => "Moved",
                Self::Renamed => "Renamed",
                Self::MovedIn => "MovedIn",
                Self::MovedOut => "MovedOut",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileMonitorEvent {
    type GlibType = ffi::GFileMonitorEvent;

    fn into_glib(self) -> ffi::GFileMonitorEvent {
        match self {
            Self::Changed => ffi::G_FILE_MONITOR_EVENT_CHANGED,
            Self::ChangesDoneHint => ffi::G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT,
            Self::Deleted => ffi::G_FILE_MONITOR_EVENT_DELETED,
            Self::Created => ffi::G_FILE_MONITOR_EVENT_CREATED,
            Self::AttributeChanged => ffi::G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED,
            Self::PreUnmount => ffi::G_FILE_MONITOR_EVENT_PRE_UNMOUNT,
            Self::Unmounted => ffi::G_FILE_MONITOR_EVENT_UNMOUNTED,
            Self::Moved => ffi::G_FILE_MONITOR_EVENT_MOVED,
            Self::Renamed => ffi::G_FILE_MONITOR_EVENT_RENAMED,
            Self::MovedIn => ffi::G_FILE_MONITOR_EVENT_MOVED_IN,
            Self::MovedOut => ffi::G_FILE_MONITOR_EVENT_MOVED_OUT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GFileMonitorEvent> for FileMonitorEvent {
    unsafe fn from_glib(value: ffi::GFileMonitorEvent) -> Self {
        match value {
            0 => Self::Changed,
            1 => Self::ChangesDoneHint,
            2 => Self::Deleted,
            3 => Self::Created,
            4 => Self::AttributeChanged,
            5 => Self::PreUnmount,
            6 => Self::Unmounted,
            7 => Self::Moved,
            8 => Self::Renamed,
            9 => Self::MovedIn,
            10 => Self::MovedOut,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FileMonitorEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_file_monitor_event_get_type()) }
    }
}

impl glib::value::ValueType for FileMonitorEvent {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileMonitorEvent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileMonitorEvent {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GFileType")]
pub enum FileType {
    #[doc(alias = "G_FILE_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "G_FILE_TYPE_REGULAR")]
    Regular,
    #[doc(alias = "G_FILE_TYPE_DIRECTORY")]
    Directory,
    #[doc(alias = "G_FILE_TYPE_SYMBOLIC_LINK")]
    SymbolicLink,
    #[doc(alias = "G_FILE_TYPE_SPECIAL")]
    Special,
    #[doc(alias = "G_FILE_TYPE_SHORTCUT")]
    Shortcut,
    #[doc(alias = "G_FILE_TYPE_MOUNTABLE")]
    Mountable,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileType::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Regular => "Regular",
                Self::Directory => "Directory",
                Self::SymbolicLink => "SymbolicLink",
                Self::Special => "Special",
                Self::Shortcut => "Shortcut",
                Self::Mountable => "Mountable",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FileType {
    type GlibType = ffi::GFileType;

    fn into_glib(self) -> ffi::GFileType {
        match self {
            Self::Unknown => ffi::G_FILE_TYPE_UNKNOWN,
            Self::Regular => ffi::G_FILE_TYPE_REGULAR,
            Self::Directory => ffi::G_FILE_TYPE_DIRECTORY,
            Self::SymbolicLink => ffi::G_FILE_TYPE_SYMBOLIC_LINK,
            Self::Special => ffi::G_FILE_TYPE_SPECIAL,
            Self::Shortcut => ffi::G_FILE_TYPE_SHORTCUT,
            Self::Mountable => ffi::G_FILE_TYPE_MOUNTABLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GFileType> for FileType {
    unsafe fn from_glib(value: ffi::GFileType) -> Self {
        match value {
            0 => Self::Unknown,
            1 => Self::Regular,
            2 => Self::Directory,
            3 => Self::SymbolicLink,
            4 => Self::Special,
            5 => Self::Shortcut,
            6 => Self::Mountable,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FileType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_file_type_get_type()) }
    }
}

impl glib::value::ValueType for FileType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GIOErrorEnum")]
pub enum IOErrorEnum {
    #[doc(alias = "G_IO_ERROR_FAILED")]
    Failed,
    #[doc(alias = "G_IO_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "G_IO_ERROR_EXISTS")]
    Exists,
    #[doc(alias = "G_IO_ERROR_IS_DIRECTORY")]
    IsDirectory,
    #[doc(alias = "G_IO_ERROR_NOT_DIRECTORY")]
    NotDirectory,
    #[doc(alias = "G_IO_ERROR_NOT_EMPTY")]
    NotEmpty,
    #[doc(alias = "G_IO_ERROR_NOT_REGULAR_FILE")]
    NotRegularFile,
    #[doc(alias = "G_IO_ERROR_NOT_SYMBOLIC_LINK")]
    NotSymbolicLink,
    #[doc(alias = "G_IO_ERROR_NOT_MOUNTABLE_FILE")]
    NotMountableFile,
    #[doc(alias = "G_IO_ERROR_FILENAME_TOO_LONG")]
    FilenameTooLong,
    #[doc(alias = "G_IO_ERROR_INVALID_FILENAME")]
    InvalidFilename,
    #[doc(alias = "G_IO_ERROR_TOO_MANY_LINKS")]
    TooManyLinks,
    #[doc(alias = "G_IO_ERROR_NO_SPACE")]
    NoSpace,
    #[doc(alias = "G_IO_ERROR_INVALID_ARGUMENT")]
    InvalidArgument,
    #[doc(alias = "G_IO_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    #[doc(alias = "G_IO_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "G_IO_ERROR_NOT_MOUNTED")]
    NotMounted,
    #[doc(alias = "G_IO_ERROR_ALREADY_MOUNTED")]
    AlreadyMounted,
    #[doc(alias = "G_IO_ERROR_CLOSED")]
    Closed,
    #[doc(alias = "G_IO_ERROR_CANCELLED")]
    Cancelled,
    #[doc(alias = "G_IO_ERROR_PENDING")]
    Pending,
    #[doc(alias = "G_IO_ERROR_READ_ONLY")]
    ReadOnly,
    #[doc(alias = "G_IO_ERROR_CANT_CREATE_BACKUP")]
    CantCreateBackup,
    #[doc(alias = "G_IO_ERROR_WRONG_ETAG")]
    WrongEtag,
    #[doc(alias = "G_IO_ERROR_TIMED_OUT")]
    TimedOut,
    #[doc(alias = "G_IO_ERROR_WOULD_RECURSE")]
    WouldRecurse,
    #[doc(alias = "G_IO_ERROR_BUSY")]
    Busy,
    #[doc(alias = "G_IO_ERROR_WOULD_BLOCK")]
    WouldBlock,
    #[doc(alias = "G_IO_ERROR_HOST_NOT_FOUND")]
    HostNotFound,
    #[doc(alias = "G_IO_ERROR_WOULD_MERGE")]
    WouldMerge,
    #[doc(alias = "G_IO_ERROR_FAILED_HANDLED")]
    FailedHandled,
    #[doc(alias = "G_IO_ERROR_TOO_MANY_OPEN_FILES")]
    TooManyOpenFiles,
    #[doc(alias = "G_IO_ERROR_NOT_INITIALIZED")]
    NotInitialized,
    #[doc(alias = "G_IO_ERROR_ADDRESS_IN_USE")]
    AddressInUse,
    #[doc(alias = "G_IO_ERROR_PARTIAL_INPUT")]
    PartialInput,
    #[doc(alias = "G_IO_ERROR_INVALID_DATA")]
    InvalidData,
    #[doc(alias = "G_IO_ERROR_DBUS_ERROR")]
    DbusError,
    #[doc(alias = "G_IO_ERROR_HOST_UNREACHABLE")]
    HostUnreachable,
    #[doc(alias = "G_IO_ERROR_NETWORK_UNREACHABLE")]
    NetworkUnreachable,
    #[doc(alias = "G_IO_ERROR_CONNECTION_REFUSED")]
    ConnectionRefused,
    #[doc(alias = "G_IO_ERROR_PROXY_FAILED")]
    ProxyFailed,
    #[doc(alias = "G_IO_ERROR_PROXY_AUTH_FAILED")]
    ProxyAuthFailed,
    #[doc(alias = "G_IO_ERROR_PROXY_NEED_AUTH")]
    ProxyNeedAuth,
    #[doc(alias = "G_IO_ERROR_PROXY_NOT_ALLOWED")]
    ProxyNotAllowed,
    #[doc(alias = "G_IO_ERROR_BROKEN_PIPE")]
    BrokenPipe,
    #[doc(alias = "G_IO_ERROR_NOT_CONNECTED")]
    NotConnected,
    #[doc(alias = "G_IO_ERROR_MESSAGE_TOO_LARGE")]
    MessageTooLarge,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IOErrorEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IOErrorEnum::{}",
            match *self {
                Self::Failed => "Failed",
                Self::NotFound => "NotFound",
                Self::Exists => "Exists",
                Self::IsDirectory => "IsDirectory",
                Self::NotDirectory => "NotDirectory",
                Self::NotEmpty => "NotEmpty",
                Self::NotRegularFile => "NotRegularFile",
                Self::NotSymbolicLink => "NotSymbolicLink",
                Self::NotMountableFile => "NotMountableFile",
                Self::FilenameTooLong => "FilenameTooLong",
                Self::InvalidFilename => "InvalidFilename",
                Self::TooManyLinks => "TooManyLinks",
                Self::NoSpace => "NoSpace",
                Self::InvalidArgument => "InvalidArgument",
                Self::PermissionDenied => "PermissionDenied",
                Self::NotSupported => "NotSupported",
                Self::NotMounted => "NotMounted",
                Self::AlreadyMounted => "AlreadyMounted",
                Self::Closed => "Closed",
                Self::Cancelled => "Cancelled",
                Self::Pending => "Pending",
                Self::ReadOnly => "ReadOnly",
                Self::CantCreateBackup => "CantCreateBackup",
                Self::WrongEtag => "WrongEtag",
                Self::TimedOut => "TimedOut",
                Self::WouldRecurse => "WouldRecurse",
                Self::Busy => "Busy",
                Self::WouldBlock => "WouldBlock",
                Self::HostNotFound => "HostNotFound",
                Self::WouldMerge => "WouldMerge",
                Self::FailedHandled => "FailedHandled",
                Self::TooManyOpenFiles => "TooManyOpenFiles",
                Self::NotInitialized => "NotInitialized",
                Self::AddressInUse => "AddressInUse",
                Self::PartialInput => "PartialInput",
                Self::InvalidData => "InvalidData",
                Self::DbusError => "DbusError",
                Self::HostUnreachable => "HostUnreachable",
                Self::NetworkUnreachable => "NetworkUnreachable",
                Self::ConnectionRefused => "ConnectionRefused",
                Self::ProxyFailed => "ProxyFailed",
                Self::ProxyAuthFailed => "ProxyAuthFailed",
                Self::ProxyNeedAuth => "ProxyNeedAuth",
                Self::ProxyNotAllowed => "ProxyNotAllowed",
                Self::BrokenPipe => "BrokenPipe",
                Self::NotConnected => "NotConnected",
                Self::MessageTooLarge => "MessageTooLarge",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for IOErrorEnum {
    type GlibType = ffi::GIOErrorEnum;

    fn into_glib(self) -> ffi::GIOErrorEnum {
        match self {
            Self::Failed => ffi::G_IO_ERROR_FAILED,
            Self::NotFound => ffi::G_IO_ERROR_NOT_FOUND,
            Self::Exists => ffi::G_IO_ERROR_EXISTS,
            Self::IsDirectory => ffi::G_IO_ERROR_IS_DIRECTORY,
            Self::NotDirectory => ffi::G_IO_ERROR_NOT_DIRECTORY,
            Self::NotEmpty => ffi::G_IO_ERROR_NOT_EMPTY,
            Self::NotRegularFile => ffi::G_IO_ERROR_NOT_REGULAR_FILE,
            Self::NotSymbolicLink => ffi::G_IO_ERROR_NOT_SYMBOLIC_LINK,
            Self::NotMountableFile => ffi::G_IO_ERROR_NOT_MOUNTABLE_FILE,
            Self::FilenameTooLong => ffi::G_IO_ERROR_FILENAME_TOO_LONG,
            Self::InvalidFilename => ffi::G_IO_ERROR_INVALID_FILENAME,
            Self::TooManyLinks => ffi::G_IO_ERROR_TOO_MANY_LINKS,
            Self::NoSpace => ffi::G_IO_ERROR_NO_SPACE,
            Self::InvalidArgument => ffi::G_IO_ERROR_INVALID_ARGUMENT,
            Self::PermissionDenied => ffi::G_IO_ERROR_PERMISSION_DENIED,
            Self::NotSupported => ffi::G_IO_ERROR_NOT_SUPPORTED,
            Self::NotMounted => ffi::G_IO_ERROR_NOT_MOUNTED,
            Self::AlreadyMounted => ffi::G_IO_ERROR_ALREADY_MOUNTED,
            Self::Closed => ffi::G_IO_ERROR_CLOSED,
            Self::Cancelled => ffi::G_IO_ERROR_CANCELLED,
            Self::Pending => ffi::G_IO_ERROR_PENDING,
            Self::ReadOnly => ffi::G_IO_ERROR_READ_ONLY,
            Self::CantCreateBackup => ffi::G_IO_ERROR_CANT_CREATE_BACKUP,
            Self::WrongEtag => ffi::G_IO_ERROR_WRONG_ETAG,
            Self::TimedOut => ffi::G_IO_ERROR_TIMED_OUT,
            Self::WouldRecurse => ffi::G_IO_ERROR_WOULD_RECURSE,
            Self::Busy => ffi::G_IO_ERROR_BUSY,
            Self::WouldBlock => ffi::G_IO_ERROR_WOULD_BLOCK,
            Self::HostNotFound => ffi::G_IO_ERROR_HOST_NOT_FOUND,
            Self::WouldMerge => ffi::G_IO_ERROR_WOULD_MERGE,
            Self::FailedHandled => ffi::G_IO_ERROR_FAILED_HANDLED,
            Self::TooManyOpenFiles => ffi::G_IO_ERROR_TOO_MANY_OPEN_FILES,
            Self::NotInitialized => ffi::G_IO_ERROR_NOT_INITIALIZED,
            Self::AddressInUse => ffi::G_IO_ERROR_ADDRESS_IN_USE,
            Self::PartialInput => ffi::G_IO_ERROR_PARTIAL_INPUT,
            Self::InvalidData => ffi::G_IO_ERROR_INVALID_DATA,
            Self::DbusError => ffi::G_IO_ERROR_DBUS_ERROR,
            Self::HostUnreachable => ffi::G_IO_ERROR_HOST_UNREACHABLE,
            Self::NetworkUnreachable => ffi::G_IO_ERROR_NETWORK_UNREACHABLE,
            Self::ConnectionRefused => ffi::G_IO_ERROR_CONNECTION_REFUSED,
            Self::ProxyFailed => ffi::G_IO_ERROR_PROXY_FAILED,
            Self::ProxyAuthFailed => ffi::G_IO_ERROR_PROXY_AUTH_FAILED,
            Self::ProxyNeedAuth => ffi::G_IO_ERROR_PROXY_NEED_AUTH,
            Self::ProxyNotAllowed => ffi::G_IO_ERROR_PROXY_NOT_ALLOWED,
            Self::BrokenPipe => ffi::G_IO_ERROR_BROKEN_PIPE,
            Self::NotConnected => ffi::G_IO_ERROR_NOT_CONNECTED,
            Self::MessageTooLarge => ffi::G_IO_ERROR_MESSAGE_TOO_LARGE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GIOErrorEnum> for IOErrorEnum {
    unsafe fn from_glib(value: ffi::GIOErrorEnum) -> Self {
        match value {
            0 => Self::Failed,
            1 => Self::NotFound,
            2 => Self::Exists,
            3 => Self::IsDirectory,
            4 => Self::NotDirectory,
            5 => Self::NotEmpty,
            6 => Self::NotRegularFile,
            7 => Self::NotSymbolicLink,
            8 => Self::NotMountableFile,
            9 => Self::FilenameTooLong,
            10 => Self::InvalidFilename,
            11 => Self::TooManyLinks,
            12 => Self::NoSpace,
            13 => Self::InvalidArgument,
            14 => Self::PermissionDenied,
            15 => Self::NotSupported,
            16 => Self::NotMounted,
            17 => Self::AlreadyMounted,
            18 => Self::Closed,
            19 => Self::Cancelled,
            20 => Self::Pending,
            21 => Self::ReadOnly,
            22 => Self::CantCreateBackup,
            23 => Self::WrongEtag,
            24 => Self::TimedOut,
            25 => Self::WouldRecurse,
            26 => Self::Busy,
            27 => Self::WouldBlock,
            28 => Self::HostNotFound,
            29 => Self::WouldMerge,
            30 => Self::FailedHandled,
            31 => Self::TooManyOpenFiles,
            32 => Self::NotInitialized,
            33 => Self::AddressInUse,
            34 => Self::PartialInput,
            35 => Self::InvalidData,
            36 => Self::DbusError,
            37 => Self::HostUnreachable,
            38 => Self::NetworkUnreachable,
            39 => Self::ConnectionRefused,
            40 => Self::ProxyFailed,
            41 => Self::ProxyAuthFailed,
            42 => Self::ProxyNeedAuth,
            43 => Self::ProxyNotAllowed,
            44 => Self::BrokenPipe,
            45 => Self::NotConnected,
            46 => Self::MessageTooLarge,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for IOErrorEnum {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::g_io_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(Self::Failed),
            1 => Some(Self::NotFound),
            2 => Some(Self::Exists),
            3 => Some(Self::IsDirectory),
            4 => Some(Self::NotDirectory),
            5 => Some(Self::NotEmpty),
            6 => Some(Self::NotRegularFile),
            7 => Some(Self::NotSymbolicLink),
            8 => Some(Self::NotMountableFile),
            9 => Some(Self::FilenameTooLong),
            10 => Some(Self::InvalidFilename),
            11 => Some(Self::TooManyLinks),
            12 => Some(Self::NoSpace),
            13 => Some(Self::InvalidArgument),
            14 => Some(Self::PermissionDenied),
            15 => Some(Self::NotSupported),
            16 => Some(Self::NotMounted),
            17 => Some(Self::AlreadyMounted),
            18 => Some(Self::Closed),
            19 => Some(Self::Cancelled),
            20 => Some(Self::Pending),
            21 => Some(Self::ReadOnly),
            22 => Some(Self::CantCreateBackup),
            23 => Some(Self::WrongEtag),
            24 => Some(Self::TimedOut),
            25 => Some(Self::WouldRecurse),
            26 => Some(Self::Busy),
            27 => Some(Self::WouldBlock),
            28 => Some(Self::HostNotFound),
            29 => Some(Self::WouldMerge),
            30 => Some(Self::FailedHandled),
            31 => Some(Self::TooManyOpenFiles),
            32 => Some(Self::NotInitialized),
            33 => Some(Self::AddressInUse),
            34 => Some(Self::PartialInput),
            35 => Some(Self::InvalidData),
            36 => Some(Self::DbusError),
            37 => Some(Self::HostUnreachable),
            38 => Some(Self::NetworkUnreachable),
            39 => Some(Self::ConnectionRefused),
            40 => Some(Self::ProxyFailed),
            41 => Some(Self::ProxyAuthFailed),
            42 => Some(Self::ProxyNeedAuth),
            43 => Some(Self::ProxyNotAllowed),
            44 => Some(Self::BrokenPipe),
            45 => Some(Self::NotConnected),
            46 => Some(Self::MessageTooLarge),
            _ => Some(Self::Failed),
        }
    }
}

impl StaticType for IOErrorEnum {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_io_error_enum_get_type()) }
    }
}

impl glib::value::ValueType for IOErrorEnum {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for IOErrorEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for IOErrorEnum {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GMemoryMonitorWarningLevel")]
pub enum MemoryMonitorWarningLevel {
    #[doc(alias = "G_MEMORY_MONITOR_WARNING_LEVEL_LOW")]
    Low,
    #[doc(alias = "G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM")]
    Medium,
    #[doc(alias = "G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL")]
    Critical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
impl fmt::Display for MemoryMonitorWarningLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MemoryMonitorWarningLevel::{}",
            match *self {
                Self::Low => "Low",
                Self::Medium => "Medium",
                Self::Critical => "Critical",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
#[doc(hidden)]
impl IntoGlib for MemoryMonitorWarningLevel {
    type GlibType = ffi::GMemoryMonitorWarningLevel;

    fn into_glib(self) -> ffi::GMemoryMonitorWarningLevel {
        match self {
            Self::Low => ffi::G_MEMORY_MONITOR_WARNING_LEVEL_LOW,
            Self::Medium => ffi::G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM,
            Self::Critical => ffi::G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
#[doc(hidden)]
impl FromGlib<ffi::GMemoryMonitorWarningLevel> for MemoryMonitorWarningLevel {
    unsafe fn from_glib(value: ffi::GMemoryMonitorWarningLevel) -> Self {
        match value {
            50 => Self::Low,
            100 => Self::Medium,
            255 => Self::Critical,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
impl StaticType for MemoryMonitorWarningLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_memory_monitor_warning_level_get_type()) }
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
impl glib::value::ValueType for MemoryMonitorWarningLevel {
    type Type = Self;
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
unsafe impl<'a> FromValue<'a> for MemoryMonitorWarningLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_64", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_64")))]
impl ToValue for MemoryMonitorWarningLevel {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GMountOperationResult")]
pub enum MountOperationResult {
    #[doc(alias = "G_MOUNT_OPERATION_HANDLED")]
    Handled,
    #[doc(alias = "G_MOUNT_OPERATION_ABORTED")]
    Aborted,
    #[doc(alias = "G_MOUNT_OPERATION_UNHANDLED")]
    Unhandled,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MountOperationResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MountOperationResult::{}",
            match *self {
                Self::Handled => "Handled",
                Self::Aborted => "Aborted",
                Self::Unhandled => "Unhandled",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for MountOperationResult {
    type GlibType = ffi::GMountOperationResult;

    fn into_glib(self) -> ffi::GMountOperationResult {
        match self {
            Self::Handled => ffi::G_MOUNT_OPERATION_HANDLED,
            Self::Aborted => ffi::G_MOUNT_OPERATION_ABORTED,
            Self::Unhandled => ffi::G_MOUNT_OPERATION_UNHANDLED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMountOperationResult> for MountOperationResult {
    unsafe fn from_glib(value: ffi::GMountOperationResult) -> Self {
        match value {
            0 => Self::Handled,
            1 => Self::Aborted,
            2 => Self::Unhandled,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MountOperationResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_mount_operation_result_get_type()) }
    }
}

impl glib::value::ValueType for MountOperationResult {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for MountOperationResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MountOperationResult {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GNetworkConnectivity")]
pub enum NetworkConnectivity {
    #[doc(alias = "G_NETWORK_CONNECTIVITY_LOCAL")]
    Local,
    #[doc(alias = "G_NETWORK_CONNECTIVITY_LIMITED")]
    Limited,
    #[doc(alias = "G_NETWORK_CONNECTIVITY_PORTAL")]
    Portal,
    #[doc(alias = "G_NETWORK_CONNECTIVITY_FULL")]
    Full,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NetworkConnectivity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NetworkConnectivity::{}",
            match *self {
                Self::Local => "Local",
                Self::Limited => "Limited",
                Self::Portal => "Portal",
                Self::Full => "Full",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for NetworkConnectivity {
    type GlibType = ffi::GNetworkConnectivity;

    fn into_glib(self) -> ffi::GNetworkConnectivity {
        match self {
            Self::Local => ffi::G_NETWORK_CONNECTIVITY_LOCAL,
            Self::Limited => ffi::G_NETWORK_CONNECTIVITY_LIMITED,
            Self::Portal => ffi::G_NETWORK_CONNECTIVITY_PORTAL,
            Self::Full => ffi::G_NETWORK_CONNECTIVITY_FULL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GNetworkConnectivity> for NetworkConnectivity {
    unsafe fn from_glib(value: ffi::GNetworkConnectivity) -> Self {
        match value {
            1 => Self::Local,
            2 => Self::Limited,
            3 => Self::Portal,
            4 => Self::Full,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NetworkConnectivity {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_network_connectivity_get_type()) }
    }
}

impl glib::value::ValueType for NetworkConnectivity {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NetworkConnectivity {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NetworkConnectivity {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GNotificationPriority")]
pub enum NotificationPriority {
    #[doc(alias = "G_NOTIFICATION_PRIORITY_NORMAL")]
    Normal,
    #[doc(alias = "G_NOTIFICATION_PRIORITY_LOW")]
    Low,
    #[doc(alias = "G_NOTIFICATION_PRIORITY_HIGH")]
    High,
    #[doc(alias = "G_NOTIFICATION_PRIORITY_URGENT")]
    Urgent,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NotificationPriority {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NotificationPriority::{}",
            match *self {
                Self::Normal => "Normal",
                Self::Low => "Low",
                Self::High => "High",
                Self::Urgent => "Urgent",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for NotificationPriority {
    type GlibType = ffi::GNotificationPriority;

    fn into_glib(self) -> ffi::GNotificationPriority {
        match self {
            Self::Normal => ffi::G_NOTIFICATION_PRIORITY_NORMAL,
            Self::Low => ffi::G_NOTIFICATION_PRIORITY_LOW,
            Self::High => ffi::G_NOTIFICATION_PRIORITY_HIGH,
            Self::Urgent => ffi::G_NOTIFICATION_PRIORITY_URGENT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GNotificationPriority> for NotificationPriority {
    unsafe fn from_glib(value: ffi::GNotificationPriority) -> Self {
        match value {
            0 => Self::Normal,
            1 => Self::Low,
            2 => Self::High,
            3 => Self::Urgent,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NotificationPriority {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_notification_priority_get_type()) }
    }
}

impl glib::value::ValueType for NotificationPriority {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NotificationPriority {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NotificationPriority {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GPasswordSave")]
pub enum PasswordSave {
    #[doc(alias = "G_PASSWORD_SAVE_NEVER")]
    Never,
    #[doc(alias = "G_PASSWORD_SAVE_FOR_SESSION")]
    ForSession,
    #[doc(alias = "G_PASSWORD_SAVE_PERMANENTLY")]
    Permanently,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PasswordSave {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PasswordSave::{}",
            match *self {
                Self::Never => "Never",
                Self::ForSession => "ForSession",
                Self::Permanently => "Permanently",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for PasswordSave {
    type GlibType = ffi::GPasswordSave;

    fn into_glib(self) -> ffi::GPasswordSave {
        match self {
            Self::Never => ffi::G_PASSWORD_SAVE_NEVER,
            Self::ForSession => ffi::G_PASSWORD_SAVE_FOR_SESSION,
            Self::Permanently => ffi::G_PASSWORD_SAVE_PERMANENTLY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GPasswordSave> for PasswordSave {
    unsafe fn from_glib(value: ffi::GPasswordSave) -> Self {
        match value {
            0 => Self::Never,
            1 => Self::ForSession,
            2 => Self::Permanently,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PasswordSave {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_password_save_get_type()) }
    }
}

impl glib::value::ValueType for PasswordSave {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PasswordSave {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PasswordSave {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GResolverRecordType")]
pub enum ResolverRecordType {
    #[doc(alias = "G_RESOLVER_RECORD_SRV")]
    Srv,
    #[doc(alias = "G_RESOLVER_RECORD_MX")]
    Mx,
    #[doc(alias = "G_RESOLVER_RECORD_TXT")]
    Txt,
    #[doc(alias = "G_RESOLVER_RECORD_SOA")]
    Soa,
    #[doc(alias = "G_RESOLVER_RECORD_NS")]
    Ns,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ResolverRecordType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ResolverRecordType::{}",
            match *self {
                Self::Srv => "Srv",
                Self::Mx => "Mx",
                Self::Txt => "Txt",
                Self::Soa => "Soa",
                Self::Ns => "Ns",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ResolverRecordType {
    type GlibType = ffi::GResolverRecordType;

    fn into_glib(self) -> ffi::GResolverRecordType {
        match self {
            Self::Srv => ffi::G_RESOLVER_RECORD_SRV,
            Self::Mx => ffi::G_RESOLVER_RECORD_MX,
            Self::Txt => ffi::G_RESOLVER_RECORD_TXT,
            Self::Soa => ffi::G_RESOLVER_RECORD_SOA,
            Self::Ns => ffi::G_RESOLVER_RECORD_NS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GResolverRecordType> for ResolverRecordType {
    unsafe fn from_glib(value: ffi::GResolverRecordType) -> Self {
        match value {
            1 => Self::Srv,
            2 => Self::Mx,
            3 => Self::Txt,
            4 => Self::Soa,
            5 => Self::Ns,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ResolverRecordType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_resolver_record_type_get_type()) }
    }
}

impl glib::value::ValueType for ResolverRecordType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ResolverRecordType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ResolverRecordType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GResourceError")]
pub enum ResourceError {
    #[doc(alias = "G_RESOURCE_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "G_RESOURCE_ERROR_INTERNAL")]
    Internal,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ResourceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ResourceError::{}",
            match *self {
                Self::NotFound => "NotFound",
                Self::Internal => "Internal",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ResourceError {
    type GlibType = ffi::GResourceError;

    fn into_glib(self) -> ffi::GResourceError {
        match self {
            Self::NotFound => ffi::G_RESOURCE_ERROR_NOT_FOUND,
            Self::Internal => ffi::G_RESOURCE_ERROR_INTERNAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GResourceError> for ResourceError {
    unsafe fn from_glib(value: ffi::GResourceError) -> Self {
        match value {
            0 => Self::NotFound,
            1 => Self::Internal,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for ResourceError {
    fn domain() -> Quark {
        unsafe { from_glib(ffi::g_resource_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(Self::NotFound),
            1 => Some(Self::Internal),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for ResourceError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_resource_error_get_type()) }
    }
}

impl glib::value::ValueType for ResourceError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ResourceError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ResourceError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GSocketClientEvent")]
pub enum SocketClientEvent {
    #[doc(alias = "G_SOCKET_CLIENT_RESOLVING")]
    Resolving,
    #[doc(alias = "G_SOCKET_CLIENT_RESOLVED")]
    Resolved,
    #[doc(alias = "G_SOCKET_CLIENT_CONNECTING")]
    Connecting,
    #[doc(alias = "G_SOCKET_CLIENT_CONNECTED")]
    Connected,
    #[doc(alias = "G_SOCKET_CLIENT_PROXY_NEGOTIATING")]
    ProxyNegotiating,
    #[doc(alias = "G_SOCKET_CLIENT_PROXY_NEGOTIATED")]
    ProxyNegotiated,
    #[doc(alias = "G_SOCKET_CLIENT_TLS_HANDSHAKING")]
    TlsHandshaking,
    #[doc(alias = "G_SOCKET_CLIENT_TLS_HANDSHAKED")]
    TlsHandshaked,
    #[doc(alias = "G_SOCKET_CLIENT_COMPLETE")]
    Complete,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketClientEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SocketClientEvent::{}",
            match *self {
                Self::Resolving => "Resolving",
                Self::Resolved => "Resolved",
                Self::Connecting => "Connecting",
                Self::Connected => "Connected",
                Self::ProxyNegotiating => "ProxyNegotiating",
                Self::ProxyNegotiated => "ProxyNegotiated",
                Self::TlsHandshaking => "TlsHandshaking",
                Self::TlsHandshaked => "TlsHandshaked",
                Self::Complete => "Complete",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SocketClientEvent {
    type GlibType = ffi::GSocketClientEvent;

    fn into_glib(self) -> ffi::GSocketClientEvent {
        match self {
            Self::Resolving => ffi::G_SOCKET_CLIENT_RESOLVING,
            Self::Resolved => ffi::G_SOCKET_CLIENT_RESOLVED,
            Self::Connecting => ffi::G_SOCKET_CLIENT_CONNECTING,
            Self::Connected => ffi::G_SOCKET_CLIENT_CONNECTED,
            Self::ProxyNegotiating => ffi::G_SOCKET_CLIENT_PROXY_NEGOTIATING,
            Self::ProxyNegotiated => ffi::G_SOCKET_CLIENT_PROXY_NEGOTIATED,
            Self::TlsHandshaking => ffi::G_SOCKET_CLIENT_TLS_HANDSHAKING,
            Self::TlsHandshaked => ffi::G_SOCKET_CLIENT_TLS_HANDSHAKED,
            Self::Complete => ffi::G_SOCKET_CLIENT_COMPLETE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketClientEvent> for SocketClientEvent {
    unsafe fn from_glib(value: ffi::GSocketClientEvent) -> Self {
        match value {
            0 => Self::Resolving,
            1 => Self::Resolved,
            2 => Self::Connecting,
            3 => Self::Connected,
            4 => Self::ProxyNegotiating,
            5 => Self::ProxyNegotiated,
            6 => Self::TlsHandshaking,
            7 => Self::TlsHandshaked,
            8 => Self::Complete,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SocketClientEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_client_event_get_type()) }
    }
}

impl glib::value::ValueType for SocketClientEvent {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SocketClientEvent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SocketClientEvent {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GSocketFamily")]
pub enum SocketFamily {
    #[doc(alias = "G_SOCKET_FAMILY_INVALID")]
    Invalid,
    #[doc(alias = "G_SOCKET_FAMILY_UNIX")]
    Unix,
    #[doc(alias = "G_SOCKET_FAMILY_IPV4")]
    Ipv4,
    #[doc(alias = "G_SOCKET_FAMILY_IPV6")]
    Ipv6,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketFamily {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SocketFamily::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::Unix => "Unix",
                Self::Ipv4 => "Ipv4",
                Self::Ipv6 => "Ipv6",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SocketFamily {
    type GlibType = ffi::GSocketFamily;

    fn into_glib(self) -> ffi::GSocketFamily {
        match self {
            Self::Invalid => ffi::G_SOCKET_FAMILY_INVALID,
            Self::Unix => ffi::G_SOCKET_FAMILY_UNIX,
            Self::Ipv4 => ffi::G_SOCKET_FAMILY_IPV4,
            Self::Ipv6 => ffi::G_SOCKET_FAMILY_IPV6,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketFamily> for SocketFamily {
    unsafe fn from_glib(value: ffi::GSocketFamily) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::Unix,
            2 => Self::Ipv4,
            10 => Self::Ipv6,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SocketFamily {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_family_get_type()) }
    }
}

impl glib::value::ValueType for SocketFamily {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SocketFamily {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SocketFamily {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GSocketListenerEvent")]
pub enum SocketListenerEvent {
    #[doc(alias = "G_SOCKET_LISTENER_BINDING")]
    Binding,
    #[doc(alias = "G_SOCKET_LISTENER_BOUND")]
    Bound,
    #[doc(alias = "G_SOCKET_LISTENER_LISTENING")]
    Listening,
    #[doc(alias = "G_SOCKET_LISTENER_LISTENED")]
    Listened,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketListenerEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SocketListenerEvent::{}",
            match *self {
                Self::Binding => "Binding",
                Self::Bound => "Bound",
                Self::Listening => "Listening",
                Self::Listened => "Listened",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SocketListenerEvent {
    type GlibType = ffi::GSocketListenerEvent;

    fn into_glib(self) -> ffi::GSocketListenerEvent {
        match self {
            Self::Binding => ffi::G_SOCKET_LISTENER_BINDING,
            Self::Bound => ffi::G_SOCKET_LISTENER_BOUND,
            Self::Listening => ffi::G_SOCKET_LISTENER_LISTENING,
            Self::Listened => ffi::G_SOCKET_LISTENER_LISTENED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketListenerEvent> for SocketListenerEvent {
    unsafe fn from_glib(value: ffi::GSocketListenerEvent) -> Self {
        match value {
            0 => Self::Binding,
            1 => Self::Bound,
            2 => Self::Listening,
            3 => Self::Listened,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SocketListenerEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_listener_event_get_type()) }
    }
}

impl glib::value::ValueType for SocketListenerEvent {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SocketListenerEvent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SocketListenerEvent {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GSocketProtocol")]
pub enum SocketProtocol {
    #[doc(alias = "G_SOCKET_PROTOCOL_UNKNOWN")]
    Unknown,
    #[doc(alias = "G_SOCKET_PROTOCOL_DEFAULT")]
    Default,
    #[doc(alias = "G_SOCKET_PROTOCOL_TCP")]
    Tcp,
    #[doc(alias = "G_SOCKET_PROTOCOL_UDP")]
    Udp,
    #[doc(alias = "G_SOCKET_PROTOCOL_SCTP")]
    Sctp,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketProtocol {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SocketProtocol::{}",
            match *self {
                Self::Unknown => "Unknown",
                Self::Default => "Default",
                Self::Tcp => "Tcp",
                Self::Udp => "Udp",
                Self::Sctp => "Sctp",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SocketProtocol {
    type GlibType = ffi::GSocketProtocol;

    fn into_glib(self) -> ffi::GSocketProtocol {
        match self {
            Self::Unknown => ffi::G_SOCKET_PROTOCOL_UNKNOWN,
            Self::Default => ffi::G_SOCKET_PROTOCOL_DEFAULT,
            Self::Tcp => ffi::G_SOCKET_PROTOCOL_TCP,
            Self::Udp => ffi::G_SOCKET_PROTOCOL_UDP,
            Self::Sctp => ffi::G_SOCKET_PROTOCOL_SCTP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketProtocol> for SocketProtocol {
    unsafe fn from_glib(value: ffi::GSocketProtocol) -> Self {
        match value {
            -1 => Self::Unknown,
            0 => Self::Default,
            6 => Self::Tcp,
            17 => Self::Udp,
            132 => Self::Sctp,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SocketProtocol {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_protocol_get_type()) }
    }
}

impl glib::value::ValueType for SocketProtocol {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SocketProtocol {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SocketProtocol {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GSocketType")]
pub enum SocketType {
    #[doc(alias = "G_SOCKET_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "G_SOCKET_TYPE_STREAM")]
    Stream,
    #[doc(alias = "G_SOCKET_TYPE_DATAGRAM")]
    Datagram,
    #[doc(alias = "G_SOCKET_TYPE_SEQPACKET")]
    Seqpacket,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SocketType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::Stream => "Stream",
                Self::Datagram => "Datagram",
                Self::Seqpacket => "Seqpacket",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SocketType {
    type GlibType = ffi::GSocketType;

    fn into_glib(self) -> ffi::GSocketType {
        match self {
            Self::Invalid => ffi::G_SOCKET_TYPE_INVALID,
            Self::Stream => ffi::G_SOCKET_TYPE_STREAM,
            Self::Datagram => ffi::G_SOCKET_TYPE_DATAGRAM,
            Self::Seqpacket => ffi::G_SOCKET_TYPE_SEQPACKET,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketType> for SocketType {
    unsafe fn from_glib(value: ffi::GSocketType) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::Stream,
            2 => Self::Datagram,
            3 => Self::Seqpacket,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SocketType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_type_get_type()) }
    }
}

impl glib::value::ValueType for SocketType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SocketType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SocketType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsAuthenticationMode")]
pub enum TlsAuthenticationMode {
    #[doc(alias = "G_TLS_AUTHENTICATION_NONE")]
    None,
    #[doc(alias = "G_TLS_AUTHENTICATION_REQUESTED")]
    Requested,
    #[doc(alias = "G_TLS_AUTHENTICATION_REQUIRED")]
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TlsAuthenticationMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsAuthenticationMode::{}",
            match *self {
                Self::None => "None",
                Self::Requested => "Requested",
                Self::Required => "Required",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for TlsAuthenticationMode {
    type GlibType = ffi::GTlsAuthenticationMode;

    fn into_glib(self) -> ffi::GTlsAuthenticationMode {
        match self {
            Self::None => ffi::G_TLS_AUTHENTICATION_NONE,
            Self::Requested => ffi::G_TLS_AUTHENTICATION_REQUESTED,
            Self::Required => ffi::G_TLS_AUTHENTICATION_REQUIRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsAuthenticationMode> for TlsAuthenticationMode {
    unsafe fn from_glib(value: ffi::GTlsAuthenticationMode) -> Self {
        match value {
            0 => Self::None,
            1 => Self::Requested,
            2 => Self::Required,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TlsAuthenticationMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_authentication_mode_get_type()) }
    }
}

impl glib::value::ValueType for TlsAuthenticationMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TlsAuthenticationMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TlsAuthenticationMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsCertificateRequestFlags")]
pub enum TlsCertificateRequestFlags {
    #[doc(alias = "G_TLS_CERTIFICATE_REQUEST_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TlsCertificateRequestFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsCertificateRequestFlags::{}",
            match *self {
                Self::None => "None",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for TlsCertificateRequestFlags {
    type GlibType = ffi::GTlsCertificateRequestFlags;

    fn into_glib(self) -> ffi::GTlsCertificateRequestFlags {
        match self {
            Self::None => ffi::G_TLS_CERTIFICATE_REQUEST_NONE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsCertificateRequestFlags> for TlsCertificateRequestFlags {
    unsafe fn from_glib(value: ffi::GTlsCertificateRequestFlags) -> Self {
        match value {
            0 => Self::None,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TlsCertificateRequestFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_certificate_request_flags_get_type()) }
    }
}

impl glib::value::ValueType for TlsCertificateRequestFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TlsCertificateRequestFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TlsCertificateRequestFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsChannelBindingType")]
pub enum TlsChannelBindingType {
    #[doc(alias = "G_TLS_CHANNEL_BINDING_TLS_UNIQUE")]
    Unique,
    #[doc(alias = "G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT")]
    ServerEndPoint,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
impl fmt::Display for TlsChannelBindingType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsChannelBindingType::{}",
            match *self {
                Self::Unique => "Unique",
                Self::ServerEndPoint => "ServerEndPoint",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
#[doc(hidden)]
impl IntoGlib for TlsChannelBindingType {
    type GlibType = ffi::GTlsChannelBindingType;

    fn into_glib(self) -> ffi::GTlsChannelBindingType {
        match self {
            Self::Unique => ffi::G_TLS_CHANNEL_BINDING_TLS_UNIQUE,
            Self::ServerEndPoint => ffi::G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
#[doc(hidden)]
impl FromGlib<ffi::GTlsChannelBindingType> for TlsChannelBindingType {
    unsafe fn from_glib(value: ffi::GTlsChannelBindingType) -> Self {
        match value {
            0 => Self::Unique,
            1 => Self::ServerEndPoint,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
impl StaticType for TlsChannelBindingType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_channel_binding_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
impl glib::value::ValueType for TlsChannelBindingType {
    type Type = Self;
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
unsafe impl<'a> FromValue<'a> for TlsChannelBindingType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_66", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_66")))]
impl ToValue for TlsChannelBindingType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsDatabaseLookupFlags")]
pub enum TlsDatabaseLookupFlags {
    #[doc(alias = "G_TLS_DATABASE_LOOKUP_NONE")]
    None,
    #[doc(alias = "G_TLS_DATABASE_LOOKUP_KEYPAIR")]
    Keypair,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TlsDatabaseLookupFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsDatabaseLookupFlags::{}",
            match *self {
                Self::None => "None",
                Self::Keypair => "Keypair",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for TlsDatabaseLookupFlags {
    type GlibType = ffi::GTlsDatabaseLookupFlags;

    fn into_glib(self) -> ffi::GTlsDatabaseLookupFlags {
        match self {
            Self::None => ffi::G_TLS_DATABASE_LOOKUP_NONE,
            Self::Keypair => ffi::G_TLS_DATABASE_LOOKUP_KEYPAIR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsDatabaseLookupFlags> for TlsDatabaseLookupFlags {
    unsafe fn from_glib(value: ffi::GTlsDatabaseLookupFlags) -> Self {
        match value {
            0 => Self::None,
            1 => Self::Keypair,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TlsDatabaseLookupFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_database_lookup_flags_get_type()) }
    }
}

impl glib::value::ValueType for TlsDatabaseLookupFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TlsDatabaseLookupFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TlsDatabaseLookupFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsInteractionResult")]
pub enum TlsInteractionResult {
    #[doc(alias = "G_TLS_INTERACTION_UNHANDLED")]
    Unhandled,
    #[doc(alias = "G_TLS_INTERACTION_HANDLED")]
    Handled,
    #[doc(alias = "G_TLS_INTERACTION_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TlsInteractionResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsInteractionResult::{}",
            match *self {
                Self::Unhandled => "Unhandled",
                Self::Handled => "Handled",
                Self::Failed => "Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for TlsInteractionResult {
    type GlibType = ffi::GTlsInteractionResult;

    fn into_glib(self) -> ffi::GTlsInteractionResult {
        match self {
            Self::Unhandled => ffi::G_TLS_INTERACTION_UNHANDLED,
            Self::Handled => ffi::G_TLS_INTERACTION_HANDLED,
            Self::Failed => ffi::G_TLS_INTERACTION_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsInteractionResult> for TlsInteractionResult {
    unsafe fn from_glib(value: ffi::GTlsInteractionResult) -> Self {
        match value {
            0 => Self::Unhandled,
            1 => Self::Handled,
            2 => Self::Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TlsInteractionResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_interaction_result_get_type()) }
    }
}

impl glib::value::ValueType for TlsInteractionResult {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TlsInteractionResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TlsInteractionResult {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg_attr(feature = "v2_60", deprecated = "Since 2.60")]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GTlsRehandshakeMode")]
pub enum TlsRehandshakeMode {
    #[doc(alias = "G_TLS_REHANDSHAKE_NEVER")]
    Never,
    #[doc(alias = "G_TLS_REHANDSHAKE_SAFELY")]
    Safely,
    #[doc(alias = "G_TLS_REHANDSHAKE_UNSAFELY")]
    Unsafely,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TlsRehandshakeMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TlsRehandshakeMode::{}",
            match *self {
                Self::Never => "Never",
                Self::Safely => "Safely",
                Self::Unsafely => "Unsafely",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for TlsRehandshakeMode {
    type GlibType = ffi::GTlsRehandshakeMode;

    fn into_glib(self) -> ffi::GTlsRehandshakeMode {
        match self {
            Self::Never => ffi::G_TLS_REHANDSHAKE_NEVER,
            Self::Safely => ffi::G_TLS_REHANDSHAKE_SAFELY,
            Self::Unsafely => ffi::G_TLS_REHANDSHAKE_UNSAFELY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsRehandshakeMode> for TlsRehandshakeMode {
    unsafe fn from_glib(value: ffi::GTlsRehandshakeMode) -> Self {
        match value {
            0 => Self::Never,
            1 => Self::Safely,
            2 => Self::Unsafely,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TlsRehandshakeMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_rehandshake_mode_get_type()) }
    }
}

impl glib::value::ValueType for TlsRehandshakeMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TlsRehandshakeMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TlsRehandshakeMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GUnixSocketAddressType")]
pub enum UnixSocketAddressType {
    #[doc(alias = "G_UNIX_SOCKET_ADDRESS_INVALID")]
    Invalid,
    #[doc(alias = "G_UNIX_SOCKET_ADDRESS_ANONYMOUS")]
    Anonymous,
    #[doc(alias = "G_UNIX_SOCKET_ADDRESS_PATH")]
    Path,
    #[doc(alias = "G_UNIX_SOCKET_ADDRESS_ABSTRACT")]
    Abstract,
    #[doc(alias = "G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED")]
    AbstractPadded,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for UnixSocketAddressType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "UnixSocketAddressType::{}",
            match *self {
                Self::Invalid => "Invalid",
                Self::Anonymous => "Anonymous",
                Self::Path => "Path",
                Self::Abstract => "Abstract",
                Self::AbstractPadded => "AbstractPadded",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for UnixSocketAddressType {
    type GlibType = ffi::GUnixSocketAddressType;

    fn into_glib(self) -> ffi::GUnixSocketAddressType {
        match self {
            Self::Invalid => ffi::G_UNIX_SOCKET_ADDRESS_INVALID,
            Self::Anonymous => ffi::G_UNIX_SOCKET_ADDRESS_ANONYMOUS,
            Self::Path => ffi::G_UNIX_SOCKET_ADDRESS_PATH,
            Self::Abstract => ffi::G_UNIX_SOCKET_ADDRESS_ABSTRACT,
            Self::AbstractPadded => ffi::G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GUnixSocketAddressType> for UnixSocketAddressType {
    unsafe fn from_glib(value: ffi::GUnixSocketAddressType) -> Self {
        match value {
            0 => Self::Invalid,
            1 => Self::Anonymous,
            2 => Self::Path,
            3 => Self::Abstract,
            4 => Self::AbstractPadded,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for UnixSocketAddressType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_unix_socket_address_type_get_type()) }
    }
}

impl glib::value::ValueType for UnixSocketAddressType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for UnixSocketAddressType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for UnixSocketAddressType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GZlibCompressorFormat")]
pub enum ZlibCompressorFormat {
    #[doc(alias = "G_ZLIB_COMPRESSOR_FORMAT_ZLIB")]
    Zlib,
    #[doc(alias = "G_ZLIB_COMPRESSOR_FORMAT_GZIP")]
    Gzip,
    #[doc(alias = "G_ZLIB_COMPRESSOR_FORMAT_RAW")]
    Raw,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ZlibCompressorFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ZlibCompressorFormat::{}",
            match *self {
                Self::Zlib => "Zlib",
                Self::Gzip => "Gzip",
                Self::Raw => "Raw",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ZlibCompressorFormat {
    type GlibType = ffi::GZlibCompressorFormat;

    fn into_glib(self) -> ffi::GZlibCompressorFormat {
        match self {
            Self::Zlib => ffi::G_ZLIB_COMPRESSOR_FORMAT_ZLIB,
            Self::Gzip => ffi::G_ZLIB_COMPRESSOR_FORMAT_GZIP,
            Self::Raw => ffi::G_ZLIB_COMPRESSOR_FORMAT_RAW,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GZlibCompressorFormat> for ZlibCompressorFormat {
    unsafe fn from_glib(value: ffi::GZlibCompressorFormat) -> Self {
        match value {
            0 => Self::Zlib,
            1 => Self::Gzip,
            2 => Self::Raw,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ZlibCompressorFormat {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_zlib_compressor_format_get_type()) }
    }
}

impl glib::value::ValueType for ZlibCompressorFormat {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ZlibCompressorFormat {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ZlibCompressorFormat {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
